===== Project Tree =====
.
├── android
│   ├── app
│   │   └── build.gradle
│   ├── build.gradle
│   └── settings.gradle
├── embedded
│   └── sine_wave_generator
│       └── myDebug.h
├── ios
│   └── Runner
│       └── Runner-Bridging-Header.h
├── lib
│   ├── constant
│   │   ├── colors_constant.dart
│   │   ├── const_export.dart
│   │   └── softwaretextstyle.dart
│   ├── core
│   │   └── webworker_test.dart
│   ├── dart_isolate_function
│   │   ├── isolate_manager
│   │   │   ├── isolate_manager_in_web.dart
│   │   │   └── js_isolated_worker.dart
│   │   └── isolated_worker.dart
│   ├── functionality
│   │   ├── device_functionality
│   │   │   └── device_status_functionality.dart
│   │   ├── functionality.dart
│   │   └── functionality_export.dart
│   ├── main.dart
│   ├── message_identifier.dart
│   ├── models
│   │   ├── audio_detail_model.dart
│   │   ├── bit_wise_util.dart
│   │   ├── circular_buffer.dart
│   │   ├── constant.dart
│   │   ├── data_pattern_util.dart
│   │   ├── debugging.dart
│   │   ├── default_config_model.dart
│   │   ├── device_com_listen.dart
│   │   ├── enum
│   │   │   └── notch_check_filter.dart
│   │   ├── envelop_data.dart
│   │   ├── escape_sequences
│   │   │   └── escape_sequence.dart
│   │   ├── frame_detect.dart
│   │   ├── generating_sample_data.dart
│   │   ├── global_buffer.dart
│   │   ├── int_extensions.dart
│   │   ├── local_plugins
│   │   │   ├── local_plugins.dart
│   │   │   ├── local_plugins_android.dart
│   │   │   ├── local_plugins_check.dart
│   │   │   ├── local_plugins_native.dart
│   │   │   ├── local_plugins_web.dart
│   │   │   └── local_plugins_window.dart
│   │   ├── microphone_stream
│   │   │   ├── microphone_stream.dart
│   │   │   ├── microphone_stream_android.dart
│   │   │   ├── microphone_stream_check.dart
│   │   │   ├── microphone_stream_native.dart
│   │   │   ├── microphone_stream_web.dart
│   │   │   └── microphone_stream_window.dart
│   │   ├── models.dart
│   │   ├── notch_filter_model.dart
│   │   ├── sample_buffer.dart
│   │   ├── serial_util
│   │   │   ├── serial_testing.dart
│   │   │   ├── serial_util.dart
│   │   │   ├── serial_util_android.dart
│   │   │   ├── serial_util_check.dart
│   │   │   ├── serial_util_native.dart
│   │   │   ├── serial_util_web.dart
│   │   │   └── serial_util_window.dart
│   │   ├── serialport_data_model.dart
│   │   ├── timing_util.dart
│   │   ├── usb_protocol
│   │   │   ├── commands.dart
│   │   │   └── usb_protocol.dart
│   │   └── web_sound_implementation.dart
│   ├── provider
│   │   ├── custom_slider_provider.dart
│   │   ├── data_type_status.dart
│   │   ├── debug_time_provider.dart
│   │   ├── devices_provider.dart
│   │   ├── enveloping_config_provider.dart
│   │   ├── graph_gain_provider.dart
│   │   ├── graph_stream_data.dart
│   │   ├── isgraphplay_provider.dart
│   │   ├── port_scan_provider.dart
│   │   ├── provider_export.dart
│   │   ├── sample_rate_provider.dart
│   │   ├── serial_provider.dart
│   │   ├── software_setting_provider.dart
│   │   └── vertical_dragprovider.dart
│   ├── screen
│   │   ├── admin_dashboard_screen
│   │   │   ├── admin_screen.dart
│   │   │   └── adminscreen.dart
│   │   ├── dart_isolate_screen
│   │   │   └── native_isolates.dart
│   │   ├── debug_data.dart
│   │   ├── graph_page_widget
│   │   │   └── sound_wave_view.dart
│   │   ├── graph_template.dart
│   │   ├── page_route_screen.dart
│   │   ├── screen_export.dart
│   │   ├── seria_package.dart
│   │   ├── setting_buttons.dart
│   │   ├── setting_page.dart
│   │   ├── spiker_box_ui.dart
│   │   └── web_platform
│   │       ├── isolates_screen
│   │       │   ├── isolate_sc_template.dart
│   │       │   ├── isolated_worker.dart
│   │       │   ├── isolates_manager.dart
│   │       │   ├── squadron
│   │       │   │   ├── identify_service.dart
│   │       │   │   ├── sample_service.dart
│   │       │   │   ├── sample_worker_vm.dart
│   │       │   │   └── sampleworker_pool.dart
│   │       │   └── squadron_package.dart
│   │       ├── js_library.dart
│   │       ├── js_listener_native.dart
│   │       ├── js_listener_web.dart
│   │       └── web_isolates
│   │           └── web_worker_page.dart
│   └── widget
│       ├── callback_button.dart
│       ├── chart.dart
│       ├── custom_button.dart
│       ├── custom_slider_widget.dart
│       ├── draggable_widget.dart
│       ├── show_dialog.dart
│       ├── spiker_box_button.dart
│       ├── theme_colors.dart
│       ├── water_droplet.dart
│       ├── white_checkbox_widget.dart
│       └── widget_export.dart
├── linux
│   ├── main.cc
│   ├── my_application.cc
│   └── my_application.h
├── native_implementation
│   └── pluggins
│       ├── flutter_audio_waveforms1.1.1.3
│       │   ├── lib
│       │   │   ├── flutter_audio_waveforms.dart
│       │   │   └── src
│       │   │       ├── const
│       │   │       │   └── colors.dart
│       │   │       ├── core
│       │   │       │   ├── audio_waveform.dart
│       │   │       │   └── waveform_painters_ab.dart
│       │   │       ├── util
│       │   │       │   ├── check_samples_equality.dart
│       │   │       │   └── waveform_alignment.dart
│       │   │       └── waveforms
│       │   │           ├── curved_polygon_waveform
│       │   │           │   ├── active_inactive_waveform_painter.dart
│       │   │           │   └── curved_polygon_waveform.dart
│       │   │           ├── polygon_waveform
│       │   │           │   ├── active_waveform_painter.dart
│       │   │           │   ├── inactive_waveform_painter.dart
│       │   │           │   └── polygon_waveform.dart
│       │   │           ├── rectangle_waveform
│       │   │           │   ├── active_waveform_painter.dart
│       │   │           │   ├── inactive_waveform_painter.dart
│       │   │           │   └── rectangle_waveform.dart
│       │   │           └── squiggly_waveform
│       │   │               ├── active_inactive_waveform_painter.dart
│       │   │               └── squiggly_waveform.dart
│       │   ├── pubspec.yaml
│       │   └── test
│       │       └── flutter_audio_waveforms_test.dart
│       └── native_add
│           ├── android
│           │   ├── build.gradle
│           │   └── settings.gradle
│           ├── example
│           │   ├── android
│           │   │   ├── app
│           │   │   │   └── build.gradle
│           │   │   ├── build.gradle
│           │   │   └── settings.gradle
│           │   ├── ios
│           │   │   └── Runner
│           │   │       └── Runner-Bridging-Header.h
│           │   ├── lib
│           │   │   └── main.dart
│           │   ├── linux
│           │   │   ├── main.cc
│           │   │   ├── my_application.cc
│           │   │   └── my_application.h
│           │   ├── pubspec.yaml
│           │   └── windows
│           │       └── runner
│           │           ├── flutter_window.cpp
│           │           ├── flutter_window.h
│           │           ├── main.cpp
│           │           ├── resource.h
│           │           ├── utils.cpp
│           │           ├── utils.h
│           │           ├── win32_window.cpp
│           │           └── win32_window.h
│           ├── ios
│           │   └── Classes
│           │       └── native_add.cpp
│           ├── lib
│           │   ├── allocation.dart
│           │   ├── main.dart
│           │   ├── mic_listening_isolate.dart
│           │   ├── model
│           │   │   ├── enveloping_data
│           │   │   │   └── enveloping_config.dart
│           │   │   ├── filter_model
│           │   │   │   ├── filter_base.dart
│           │   │   │   ├── filter_model_export.dart
│           │   │   │   ├── filter_select_enum.dart
│           │   │   │   └── filterbase_setting.dart
│           │   │   ├── model.dart
│           │   │   └── sending_data.dart
│           │   └── native_add.dart
│           ├── macos
│           │   └── Classes
│           │       └── native_add.cpp
│           ├── pubspec.yaml
│           └── src
│               ├── MyAudioSInk.h
│               ├── MyAudioSink.cpp
│               ├── capture_audio.cpp
│               ├── capture_audio.h
│               ├── envelope.cpp
│               ├── envelope.h
│               ├── filter_base.cpp
│               ├── filter_base.h
│               ├── filter_util.cpp
│               ├── filter_util.h
│               ├── high_pass_filter.cpp
│               ├── high_pass_filter.h
│               ├── low_pass_filter.cpp
│               ├── low_pass_filter.h
│               ├── mac_audio_sink.cpp
│               ├── mac_capture_audio.cpp
│               ├── notch_filter.cpp
│               ├── notch_filter.h
│               ├── sample_buffer.cpp
│               ├── sample_buffer.h
│               ├── timing_debug.cpp
│               └── timing_debug.h
├── pubspec.yaml
├── test
│   └── widget_test.dart
├── web
│   ├── envelope.cpp
│   ├── filter_base.cpp
│   ├── filter_base.h
│   ├── high_pass_filter.cpp
│   ├── low_pass_filter.cpp
│   ├── main_entry_file.cpp
│   ├── native_add.cpp
│   ├── notch_filter.cpp
│   ├── sample_buffer.cpp
│   ├── sample_buffer.h
│   └── worker6788.dart
└── windows
    ├── cmake_install.cmake
    ├── flutter
    │   └── cmake_install.cmake
    ├── plugins
    │   ├── flutter_libserialport
    │   │   ├── cmake_install.cmake
    │   │   └── libserialport
    │   │       └── cmake_install.cmake
    │   └── permission_handler_windows
    │       └── cmake_install.cmake
    └── runner
        ├── cmake_install.cmake
        ├── flutter_window.cpp
        ├── flutter_window.h
        ├── main.cpp
        ├── resource.h
        ├── utils.cpp
        ├── utils.h
        ├── win32_window.cpp
        └── win32_window.h

===== Begin Code Excerpts =====

----- BEGIN ./android/app/build.gradle -----
def localProperties = new Properties()
def localPropertiesFile = rootProject.file('local.properties')
if (localPropertiesFile.exists()) {
    localPropertiesFile.withReader('UTF-8') { reader ->
        localProperties.load(reader)
    }
}

def flutterRoot = localProperties.getProperty('flutter.sdk')
if (flutterRoot == null) {
    throw new GradleException("Flutter SDK not found. Define location with flutter.sdk in the local.properties file.")
}

def flutterVersionCode = localProperties.getProperty('flutter.versionCode')
if (flutterVersionCode == null) {
    flutterVersionCode = '1'
}

def flutterVersionName = localProperties.getProperty('flutter.versionName')
if (flutterVersionName == null) {
    flutterVersionName = '1.0'
}

apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply from: "$flutterRoot/packages/flutter_tools/gradle/flutter.gradle"

android {
    compileSdkVersion 33
    ndkVersion flutter.ndkVersion

    compileOptions {
        sourceCompatibility 1.8
        targetCompatibility 1.8
    }

    kotlinOptions {
        jvmTarget = '1.8'
    }

    sourceSets {
        main.java.srcDirs += 'src/main/kotlin'
    }

    defaultConfig {
            configurations.all {
    resolutionStrategy { force 'androidx.core:core-ktx:1.6.0' }
}
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId "com.example.spikerbox_architecture"
        // You can update the following values to match your application needs.
        // For more information, see: https://docs.flutter.dev/deployment/android#reviewing-the-gradle-build-configuration.
        minSdkVersion 21
        targetSdkVersion 30
        versionCode flutterVersionCode.toInteger()
        versionName flutterVersionName
    }

    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig signingConfigs.debug
        }
    }
}

flutter {
    source '../..'
}

dependencies {
    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"
}

----- END ./android/app/build.gradle -----

----- BEGIN ./android/build.gradle -----
buildscript {
    ext.kotlin_version = '1.7.10'
    repositories {
        google()
        mavenCentral()
    }

    dependencies {
        classpath 'com.android.tools.build:gradle:7.2.0'
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
    }
}

allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

rootProject.buildDir = '../build'
subprojects {
    project.buildDir = "${rootProject.buildDir}/${project.name}"
}
subprojects {
    project.evaluationDependsOn(':app')
}

tasks.register("clean", Delete) {
    delete rootProject.buildDir
}

----- END ./android/build.gradle -----

----- BEGIN ./android/settings.gradle -----
include ':app'

def localPropertiesFile = new File(rootProject.projectDir, "local.properties")
def properties = new Properties()

assert localPropertiesFile.exists()
localPropertiesFile.withReader("UTF-8") { reader -> properties.load(reader) }

def flutterSdkPath = properties.getProperty("flutter.sdk")
assert flutterSdkPath != null, "flutter.sdk not set in local.properties"
apply from: "$flutterSdkPath/packages/flutter_tools/gradle/app_plugin_loader.gradle"

----- END ./android/settings.gradle -----

----- BEGIN ./embedded/sine_wave_generator/myDebug.h -----
#ifndef myDebug_h
#define myDebug_h

#define debug true

#if debug
#define Dln(x) Serial.println(x)
#define D(x) Serial.print(x)
#define DTypeln(x,y) Serial.println(x,y)
#define DType(x,y) Serial.print(x,y)
#define Df(x,y) Serial.printf(x,y)
#else
#define Dln(x)
#define D(x)
#define DTypeln(x,y)
#define DType(x,y)
#define Df(x,y)
#endif

#endif

----- END ./embedded/sine_wave_generator/myDebug.h -----

----- BEGIN ./ios/Runner/Runner-Bridging-Header.h -----
#import "GeneratedPluginRegistrant.h"

----- END ./ios/Runner/Runner-Bridging-Header.h -----

----- BEGIN ./lib/constant/colors_constant.dart -----
import 'package:flutter/material.dart';

class SoftwareColors {
  static Color kGraphColor = const Color.fromRGBO(0, 225, 28, 1);
  static Color kBackGroundColor = Colors.black;
  static Color kButtonBackGroundColor = Colors.white;
  static Color kButtonColor = Colors.black;
  static Color kDropDownBackGroundColor = const Color.fromRGBO(46, 37, 37, 0.5);
}

----- END ./lib/constant/colors_constant.dart -----

----- BEGIN ./lib/constant/const_export.dart -----
export "colors_constant.dart";
export 'softwaretextstyle.dart';

----- END ./lib/constant/const_export.dart -----

----- BEGIN ./lib/constant/softwaretextstyle.dart -----
import 'package:flutter/material.dart';

class SoftwareTextStyle {
  TextStyle kWtMediumTextStyle =
      const TextStyle(fontSize: 16, color: Colors.white);
  TextStyle kBkMediumTextStyle =
      const TextStyle(fontSize: 16, color: Colors.black87);
  TextStyle kBBkMediumTextStyle = const TextStyle(
      fontSize: 16, color: Colors.black87, fontWeight: FontWeight.w500);
}

----- END ./lib/constant/softwaretextstyle.dart -----

----- BEGIN ./lib/core/webworker_test.dart -----
import 'dart:collection';
import 'package:flutter/foundation.dart';
import 'package:isolated_worker/js_isolated_worker.dart';

const List<String> _jsScripts = <String>['processing.js'];
const String _jsGetFunctionName = 'processingLoad';

class JsWebWorker {
  bool _areScriptsImported = false;

  Future<LinkedHashMap<dynamic, dynamic>> processingLoad(
      LinkedHashMap<dynamic, dynamic> arguments) async {
    if (kIsWeb) {
      if (!_areScriptsImported) {
        await JsIsolatedWorker().importScripts(_jsScripts);
        _areScriptsImported = true;
      }
      return await JsIsolatedWorker().run(
        functionName: _jsGetFunctionName,
        arguments: arguments,
      ) as LinkedHashMap<dynamic, dynamic>;
    }
    throw UnimplementedError(
      'JsWebWorker is not available for this platform.',
    );
  }
}

----- END ./lib/core/webworker_test.dart -----

----- BEGIN ./lib/dart_isolate_function/isolate_manager/isolate_manager_in_web.dart -----
// import 'dart:async';
// import 'dart:typed_data';

// import 'package:isolate_manager/isolate_manager.dart';

// class IsolateManagerInWeb {
//   final IsolateManager<Uint8List> isolateManager =
//       IsolateManager.createOwnIsolate(
//     concurrent: 1,
//     isolateFunction,
//     isDebug: false,
//   );

//   /// Create your own function here. This function will be called when your isolate started.
//   @pragma('vm:entry-point')
//   static void isolateFunction(dynamic params) {
//     // Initial the controller for child isolate
//     final IsolateManagerController<Uint8List> controller =
//         IsolateManagerController<Uint8List>(params, onDispose: () {
//       print('Dispose isolateFunction');
//     });

//     // Get your initialParams.
//     // Notice that this `initialParams` different from the `params` above.
//     final initialParams = controller.initialParams;

//     // Do your one-time stuff here, this area of code will be called only one-time when you `start`
//     // this instance of `IsolateManager`

//     // Listen to the message receiving from main isolate, this area of code will be called each time
//     // you use `compute` or `sendMessage`.
//     controller.onIsolateMessage.listen((message) {
//       if (message is Uint8List) {
//         // Create a completer
//         Completer completer = Completer();

//         // Handle the result an exceptions
//         completer.future.then(
//           (value) => controller.sendResult(value as Uint8List),
//           onError: (err, stack) =>
//               controller.sendResult(Uint8List.fromList(<int>[])
//                   // IsolateException(err, stack) as Uint8List
//                   ),
//         );

//         // Use try-catch to send the exception to the main app
//         try {
//           // print("Msg length : ${(message).length}");
//           // print("My msg received in isolate: $message");
//           // completer.complete(Uint8List.fromList(message.toList().map((e) => e~/2).toList()));
//           completer.complete(message);
//         } catch (err, stack) {
//           // Send the exception to your main app
//           controller.sendResult(Uint8List.fromList(<int>[]));
//         }
//       }
//     });
//   }
// }

----- END ./lib/dart_isolate_function/isolate_manager/isolate_manager_in_web.dart -----

----- BEGIN ./lib/dart_isolate_function/isolate_manager/js_isolated_worker.dart -----
import "dart:collection";
import "dart:typed_data";

import '../../core/webworker_test.dart';

class IsolatedWebWorker {
  final JsWebWorker _jsWebWorker = JsWebWorker();

  Future<dynamic> checkProcessing(Uint8List result) async {
    Stopwatch stopwatch = Stopwatch();
    stopwatch.start();

    LinkedHashMap<dynamic, dynamic> arguments =
        LinkedHashMap.from({"initialData": result});
    final LinkedHashMap<dynamic, dynamic> responseMap =
        await _jsWebWorker.processingLoad(arguments);
    final Object? error = responseMap['err'];
    if (error != null) {
      throw error;
    }
    // final dynamic totalTime = responseMap['totalTime'];
    final dynamic responseData = responseMap['response'];
    stopwatch.stop();
    // print('Response from JS: $responseData');
    // int timeTaken = stopwatch.elapsedMilliseconds;
    // print("TimeTaken for dart to dart: $timeTaken microseconds");
    // print("TimeTaken within JS: $totalTime microseconds");

    return responseData;
  }
}

----- END ./lib/dart_isolate_function/isolate_manager/js_isolated_worker.dart -----

----- BEGIN ./lib/dart_isolate_function/isolated_worker.dart -----
import 'dart:isolate';

class IsolatedWorkerAllPlatform {
  ReceivePort? receivePort;
  SendPort? sendPort;
  Isolate? isolate;

  void spawnIsolate() async {
    receivePort = ReceivePort();
    isolate = await Isolate.spawn(processingInIsolate, receivePort!.sendPort);
    receivePort!.listen((dynamic value) {
      if (value is SendPort) {
        sendPort = value;
      }
      // print("received from Isolate: $value");
    });
  }

  static void processingInIsolate(SendPort sendPort) {
    Stopwatch stopwatch = Stopwatch();
    ReceivePort receivePortIsolate = ReceivePort();

    sendPort.send(receivePortIsolate.sendPort);
    receivePortIsolate.listen((message) {
      if (message is String) {
        stopwatch.start();

        int a = 10;

        for (var i = 0; i < 100000; i++) {
          if (i == 0) {
            print("the condition is not satisfied");
          }
          a += 1;
        }
        stopwatch.stop();
        // int timeTaken = DateTime.now().microsecondsSinceEpoch - startTime;
        print(
            " within isolate: ${stopwatch.elapsedMicroseconds} microseconds, $a");
        sendPort.send(stopwatch.elapsedMicroseconds);
      }
    });
  }
}

----- END ./lib/dart_isolate_function/isolated_worker.dart -----

----- BEGIN ./lib/functionality/device_functionality/device_status_functionality.dart -----
import 'dart:async';
import 'dart:typed_data';

import 'package:spikerbox_architecture/models/models.dart';
import '../../provider/provider_export.dart';

class DeviceStatusFunctionality {
  final SerialUtil _serialUtil = SerialUtil();
  List<ComDataWithBoard> deviceDataWithCom = [];
  Stream<List<ComDataWithBoard>>? deviceList;
  StreamController<List<ComDataWithBoard>> deviceListStream =
      StreamController();

  bool _isDataIdentified = false;

  Future<void> listenDevice(
    bool dummyDataStatus,
    bool isAudioListen,
    String deviceName,
    int baudRate,
  ) async {
    Stream<Uint8List>? getData =
        await _serialUtil.openPortToListen(deviceName, baudRate);
    listenPort?.cancel();
    try {
      listenPort = getData!.listen((event) {
        if (!dummyDataStatus && !isAudioListen) {
          preEscapeSequenceBuffer.addBytes(event);

          if (_isDataIdentified) {
            // Debugging.printing('us: ${stopwatch.elapsedMicroseconds}, length : ${event.length}');
            // stopwatch.reset();
          } else {
            if (frameDetect != null) {
              return;
            }
            Uint8List? firstFrameData = frameDetect.addData(event);

            if (firstFrameData != null) {
              preEscapeSequenceBuffer.addBytes(firstFrameData);
              _isDataIdentified = true;
            }
          }
        }
      });
    } catch (error) {
      print("the error in Listening is ${error}");
    }
  }

  void connectDeviceList(
      List<String> connectedDevices,
      List<SerialPortDataModel> allDevices,
      SerialDataProvider serialDataProvider) {
    // Create a stream controller to manage the stream

    // Stream<List<ComDataWithBoard>>? deviceList;
    // Call the asynchronous function to get all device lists
    if (connectedDevices.isNotEmpty) {
      SetUpFunctionality().getAllDeviceList().then((value) {
        // Extract the list of boards from the result
        List<Board> allBoards = value.boards ?? [];
        // Filter the boards based on some condition (e.g., matching unique names)
        List<Board> connectedBoards = allBoards.where((board) {
          connectedDevices
              .removeWhere((element) => allDevices.contains(element));

          return connectedDevices.contains(board.uniqueName);
        }).toList();

        allDevices.removeWhere(
            (element) => !connectedDevices.contains(element.deviceDetect));

        deviceDataWithCom =
            createComDataWithBoardList(connectedBoards, allDevices);

        serialDataProvider.setDeviceWithComData(deviceDataWithCom);
      });
    }
  }

  List<ComDataWithBoard> createComDataWithBoardList(
      List<Board> connectedBoards, List<SerialPortDataModel> allDevices) {
    List<ComDataWithBoard> result = [];

    for (SerialPortDataModel device in allDevices) {
      Board matchingBoard = connectedBoards.firstWhere(
        (board) => board.uniqueName == device.deviceDetect,
        orElse: () => Board(
            /* Default values or handle the case when no match is found */),
      );

      ComDataWithBoard comDataWithBoard = ComDataWithBoard(
        connectDevices: matchingBoard,
        serialPortData: device,
      );

      result.add(comDataWithBoard);
    }

    return result;
  }
}

----- END ./lib/functionality/device_functionality/device_status_functionality.dart -----

----- BEGIN ./lib/functionality/functionality.dart -----
import 'package:flutter/services.dart';

import '../models/default_config_model.dart';

class SetUpFunctionality {
  Future<Board?> setTheDeviceSetting(String? deviceName) async {
    if (deviceName != null) {
      DefaultConfig data = await SetUpFunctionality().jsonLoad();
      deviceName = deviceName.split(";").first;
      Iterable<Board>? deviceConfiguration =
          data.config!.boards?.where((e) => e.uniqueName == deviceName);

      return deviceConfiguration?.first;
    }
    return null;
  }

  Future<Config> getAllDeviceList() async {
    DefaultConfig data = await SetUpFunctionality().jsonLoad();
    return data.config!;
  }

  Future<DefaultConfig> jsonLoad() async {
    String jsonString =
        await rootBundle.loadString('assets/default_config.json');
    DefaultConfig data = DefaultConfig.fromRawJson(jsonString);
    return data;
  }
}

----- END ./lib/functionality/functionality.dart -----

----- BEGIN ./lib/functionality/functionality_export.dart -----
export 'functionality.dart';
export 'device_functionality/device_status_functionality.dart';

----- END ./lib/functionality/functionality_export.dart -----

----- BEGIN ./lib/main.dart -----
import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import 'package:spikerbox_architecture/provider/custom_slider_provider.dart';
import 'package:spikerbox_architecture/screen/page_route_screen.dart';
import 'provider/provider_export.dart';
import 'screen/graph_template.dart';

enum Command {
  start,
  stop,
  change,
}

int screenWidth = 0;
void main() {
  WidgetsFlutterBinding.ensureInitialized();

  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => ConstantProvider()),
        ChangeNotifierProvider(create: (_) => GraphDataProvider()),
        ChangeNotifierProvider(create: (_) => VerticalDragProvider()),
        ChangeNotifierProvider(create: (_) => GraphGainProvider()),
        ChangeNotifierProvider(create: (_) => GraphResumePlayProvider()),
        ChangeNotifierProvider(create: (_) => DataStatusProvider()),
        ChangeNotifierProvider(create: (_) => SoftwareConfigProvider()),
        ChangeNotifierProvider(create: (_) => SerialDataProvider()),
        ChangeNotifierProvider(create: (_) => PortScanProvider()),
        ChangeNotifierProvider(create: (_) => SampleRateProvider()),
        ChangeNotifierProvider(create: (_) => CustomRangeSliderProvider()),
        ChangeNotifierProvider(create: (_) => DebugTimeProvider()),
        ChangeNotifierProvider(create: (_) => EnvelopConfigProvider()),
      ],
      child: const MyApp(),
    ),
  );
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  // late JavascriptRuntime jsRunTime = getJavascriptRuntime();

  String platForm = '';
  late int sumResult;
  late Future<int> sumAsyncResult;
  final number = ValueNotifier(0);

  @override
  void initState() {
    super.initState();
    SystemChrome.setEnabledSystemUIMode(SystemUiMode.immersiveSticky,
        overlays: []);
    // SchedulerBinding.instance.addTimingsCallback((timings) async {
    //   await requestToMic();
    // });
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
        debugShowCheckedModeBanner: false,
        title: 'Flutter Demo',
        theme: ThemeData(
          primarySwatch: Colors.blue,
          textTheme: const TextTheme(

              // for the body2 text
              // You can add other text styles here as needed
              ),
        ),
        home: kIsWeb
            ? const DashBoardPageRoute()
            // HomePage()
            : Consumer<ConstantProvider>(
                builder: (context, data, child) {
                  return GraphTemplate(
                    constantProvider: data,
                  );
                },
              ));
  }
}

----- END ./lib/main.dart -----

----- BEGIN ./lib/message_identifier.dart -----
import 'dart:typed_data';

enum MessageState {
  noSequence,
  inStartSequence,
  inMessage,
}

class MessageIdentifier {
  MessageIdentifier({
    required this.onDeviceData,
    required this.onDeviceMessage,
  });

  final Function(Uint8List) onDeviceData;
  final Function(Uint8List) onDeviceMessage;
  MessageState _messageState = MessageState.noSequence;

  /// 255, 255, 1, 1, 128, 255
  static final Uint8List startSequence = Uint8List.fromList([255, 255, 1, 1, 128, 255]);

  /// 255, 255, 1, 1, 129, 255
  static final Uint8List endSequence = Uint8List.fromList([255, 255, 1, 1, 129, 255]);

  final List<int> _deviceDataBuffer = [];
  final List<int> _messageBuffer = [];
  int _startSequenceFoundIndex = -1;

  void addPacket(Uint8List newPacket) {
    for (int i = 0; i < newPacket.length; i++) {
      switch (_messageState) {
        case MessageState.noSequence:
          if (newPacket[i] == startSequence.first) {
            _startSequenceFoundIndex = 0;
            _messageState = MessageState.inStartSequence;
          } else {
            _deviceDataBuffer.add(newPacket[i]);
          }
          break;

        case MessageState.inStartSequence:
          if (newPacket[i] == startSequence[_startSequenceFoundIndex + 1]) {
            if (_startSequenceFoundIndex == startSequence.length - 2) {
              _messageState = MessageState.inMessage;
            } else {
              _startSequenceFoundIndex++;
            }
          } else {
            // Adding the partial start sequence found to data
            _deviceDataBuffer.addAll(startSequence.sublist(0, _startSequenceFoundIndex + 1));
            _messageState = MessageState.noSequence;
          }
          break;

        case MessageState.inMessage:
          // Contingency if end sequence byte is dropped and
          // all the bytes keep on adding to _messageBuffer
          if (_messageBuffer.length > 50) {
            _messageBuffer.clear();
            _messageState = MessageState.noSequence;
            break;
          }

          // Keep on adding messages / end sequence bytes to _messageBuffer
          _messageBuffer.add(newPacket[i]);

          // When endSequence is found then remove the endSequence from _messageBuffer
          // and send the _messageBuffer
          bool isEndSequenceFound = containsUint8List(_messageBuffer, endSequence);
          if (isEndSequenceFound) {
            removeSublist(_messageBuffer, endSequence);
            onDeviceMessage(Uint8List.fromList(_messageBuffer));
            _messageBuffer.clear();
            _messageState = MessageState.noSequence;
          }
          break;
      }
    }
    if (_messageState != MessageState.noSequence) return;
    if (_deviceDataBuffer.isNotEmpty) {
      onDeviceData(Uint8List.fromList(_deviceDataBuffer));
      _deviceDataBuffer.clear();
    }
  }

  bool containsUint8List(List<int> mainList, List<int> subList) {
    if (mainList.length < subList.length) {
      return false; // The main list is shorter, so it can't contain the sublist.
    }

    for (int i = 0; i <= mainList.length - subList.length; i++) {
      bool found = true;

      for (int j = 0; j < subList.length; j++) {
        if (mainList[i + j] != subList[j]) {
          found = false;
          break;
        }
      }

      if (found) {
        return true; // Sublist found within the main list.
      }
    }

    return false; // Sublist not found within the main list.
  }

  void removeSublist(List<int> mainList, List<int> sublist) {
    for (int i = 0; i <= mainList.length - sublist.length; i++) {
      bool found = true;

      for (int j = 0; j < sublist.length; j++) {
        if (mainList[i + j] != sublist[j]) {
          found = false;
          break;
        }
      }

      if (found) {
        mainList.removeRange(i, i + sublist.length);
        return;
      }
    }
  }
}

----- END ./lib/message_identifier.dart -----

----- BEGIN ./lib/models/audio_detail_model.dart -----
class AudioDetail {
  final int avgTime;
  final int minTime;
  final int maxTime;

  AudioDetail(
      {required this.avgTime, required this.maxTime, required this.minTime});
}

----- END ./lib/models/audio_detail_model.dart -----

----- BEGIN ./lib/models/bit_wise_util.dart -----
import 'dart:typed_data';


class BitwiseUtil {
  const BitwiseUtil({
    required this.bitCount,
  });

  final int bitCount;

  /// Returns empty list if data has missing bytes
  ///
  /// Bit count is the resolution of data, eg. 16-bit
  /// Human Spikerbox - 14bit data
  /// Human-Human-Interface - 10bit data
  /// Data format - Big endian data is received
  /// 1xxx xxxx - 0xxx xxxx
  Uint8List convertToValue(Uint8List upcomingByte) {
    // To ensure that 16 bit data is received
    if (upcomingByte.length % 2 != 0) return Uint8List.fromList([]);

    for (int k = 0; k < upcomingByte.length; k += 2) {
      List<int> modifiedValue = getCustomValue(upcomingByte.elementAt(k), upcomingByte.elementAt(k + 1));
      upcomingByte.setAll(k, modifiedValue);
    }

    // Read the float values
    // Uint16List bufferView16Bit = upcomingByte.buffer.asUint16List();
    // for (int i = 0; i < bufferView16Bit.length; i++) {
    //   switch (bitCount) {
    //     case 14:
    //       bufferView16Bit[i] = bufferView16Bit[i] - 8192;
    //       break;

    //     case 10:
    //       bufferView16Bit[i] = (bufferView16Bit[i] * 30) - 15360; // (value - 512) * 30
    //       break;

    //     default:
    //       break;
    //   }
    // }
    return upcomingByte;
  }

  /// Returns the value as little endian
  static List<int> getCustomValue(int msb, int lsb) {
    int mMSB = (msb & 0x7f) >> 1; // Shifting the data right
    int modifiedLSB = (lsb & 0x7f) | ((msb & 0x1) << 7) & 0x80; // Dropping the 7th bit and 0th bit//
    return [modifiedLSB, mMSB];
  }
}

----- END ./lib/models/bit_wise_util.dart -----

----- BEGIN ./lib/models/circular_buffer.dart -----
import 'dart:typed_data';

import 'package:spikerbox_architecture/models/debugging.dart';

class CircularBuffer {
  final Uint8List _buffer;
  int _readIndex = 0;
  int _writeIndex = 0;

  CircularBuffer(int bufferSize) : _buffer = Uint8List(bufferSize);

  void write(Uint8List data) {
    // Debugging.printing("_writeIndex before writing: $_writeIndex");
    for (int i = 0; i < data.length; i++) {
      int indexToFill = _writeIndex + 1;
      if (indexToFill >= _buffer.length) {
        indexToFill = 0;
      }
      _writeIndex = indexToFill;
      _buffer[_writeIndex] = data[i];
    }
    // Debugging.printing("_writeIndex after writing: $_writeIndex");
    // Debugging.printing("Buffer after adding data: $_buffer");
  }

  Uint8List read(int length) {
    Uint8List dataRead = Uint8List(length);
    for (int i = 0; i < length; i++) {
      int indexToRead = _readIndex + 1;
      if (indexToRead >= _buffer.length) {
        indexToRead = 0;
      }
      _readIndex = indexToRead;
      dataRead[i] = _buffer[_readIndex];
    }
    // Debugging.printing("_readIndex: $_readIndex");
    return dataRead;
  }

  int get readableBytes {
    if (_writeIndex >= _readIndex) {
      return _writeIndex - _readIndex;
    } else {
      return ((_buffer.length - 1) - _readIndex) + _writeIndex;
    }
  }
}

class BufferHandler {
  final CircularBuffer _buffer;
  final void Function(Uint8List)? onDataAvailable;

  /// In bytes
  final int chunkReadSize;

  /// [chunkReadSize] - Number of bytes returned by the the buffer
  ///
  /// [bufferSize] - Total buffer length in bytes
  ///
  /// [onDataAvailable] - Callback function when next chunk of [chunkReadSize] is available
  BufferHandler(
      {required this.onDataAvailable,
      int bufferSize = 327680,
      this.chunkReadSize = 16})
      : _buffer = CircularBuffer(bufferSize),
        assert(chunkReadSize < bufferSize);

  void addBytes(Uint8List inputBytes) {
    _buffer.write(inputBytes);

    while (_buffer.readableBytes >= chunkReadSize) {
      Uint8List dtRead = _buffer.read(chunkReadSize);
      onDataAvailable?.call(dtRead);
    }
  }
}

class BufferHandlerOnDemand {
  BufferHandlerOnDemand(
      {required this.onDataAvailable,
      int bufferSize = 327680,
      this.chunkReadSize = 16})
      : _buffer = CircularBuffer(bufferSize),
        assert(chunkReadSize < bufferSize);

  final CircularBuffer _buffer;
  final void Function(Uint8List)? onDataAvailable;

  /// In bytes
  final int chunkReadSize;

  bool toFetchBytes = true;

  void addBytes(Uint8List inputBytes) {
    _buffer.write(inputBytes);
    if (toFetchBytes) requestData();
  }

  /// Request for next packet
  void requestData([int? chunkSize]) {
    int cl = chunkSize ?? chunkReadSize;
    if (_buffer.readableBytes >= cl) {
      Uint8List dtRead = _buffer.read(cl);
      onDataAvailable?.call(dtRead);
    }
  }
}

void checkCircularBuffer() {
  void onDataAvailable(Uint8List chunk) {
    print('Received chunk: $chunk');
  }

  BufferHandler buffer = BufferHandler(onDataAvailable: onDataAvailable);

  // Example input data
  Uint8List input1 =
      Uint8List.fromList([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);
  Uint8List input2 = Uint8List.fromList([13, 14, 15, 16, 17, 18, 19]);
  Uint8List input3 =
      Uint8List.fromList([20, 21, 22, 23, 24, 25, 26, 27, 28, 29]);
  Uint8List input4 = Uint8List.fromList(List.generate(15, (i) => i + 30));
  Uint8List input5 = Uint8List.fromList(List.generate(10, (i) => i + 45));

  List<Uint8List> exampleData = [input1, input2, input3, input4, input5];

  for (int i = 0; i < exampleData.length; i++) {
    Debugging.printing("input ${i + 1}: ${exampleData[i]}");
    buffer.addBytes(exampleData[i]);
  }
}

----- END ./lib/models/circular_buffer.dart -----

----- BEGIN ./lib/models/constant.dart -----
// const int kBaudRate = 222222;

/// Points to be shown on graph
const int kGraphPointsCount = 2048;

/// Number of 16bit points to be be updated
///
/// ie, [kGraphPointsCount] * 2 bytes
const int kGraphUpdateCount = 4000;

// TODO: Hardcoded values to be removed
const int channelCountBuffer = 6;

const int dummySamplingRate = 10000;
const int winMicSampleRate = 48000;
const int macMicSampleRate = 44100;
const int webMicSampleRate = 48000;
const int androidMicSampleRate = 44100;

----- END ./lib/models/constant.dart -----

----- BEGIN ./lib/models/data_pattern_util.dart -----
import 'dart:typed_data';

/// Identifies data is being received by checking
///
/// 1st byte - 7th bit is HIGH
///
/// 2nd byte - 7th bit is LOW
///
/// 3rd byte - 7th bit is LOW
///
/// 4th byte - 7th bit is LOW
class ChannelUtil {

  /// Will receive 4 bytes at a time
  ///
  /// Will identify the number of channels
  static int getChannelCount(Uint8List data) {
    if(data.isEmpty || data.length < 4) return 0;
    Uint8List startingData = data.sublist(0,4);
    int channelCount = 0;
    if(_is2ChPattern(startingData)) return 2;
    if(_is1ChPattern(startingData)) return 1;
    return channelCount;
  }


  static bool _is2ChPattern(List<int> data) {
    // Check if the 7th bit of the first byte is high (1)
    bool is7thBitHigh = (data[0] & 128) != 0;
    bool is7thBitLow = false;
    for(int i = 1; i < 4; i++) {
      // Check if the 7th bit of the second byte is low (0)
      is7thBitLow = (data[i] & 128) == 0;
    }
    return is7thBitHigh && is7thBitLow;
  }

  static bool _is1ChPattern(List<int> data) {
    bool is7thBitHigh = false;
    bool is7thBitLow = false;
    for(int i = 0 ; i < data.length; i+=2) {
      // Check if the 7th bit of the first byte is high (1)
      is7thBitHigh = (data[i] & 128) != 0;

      // Check if the 7th bit of the second byte is low (0)
      is7thBitLow = (data[i + 1] & 128) == 0;
    }
    return is7thBitHigh && is7thBitLow;
  }


  /// Bytes which are more multiple of 4 are dropped
  static Uint8List dropEveryOtherTwoBytes(Uint8List input) {
    int inputLength = input.length;
    int outputLength = inputLength ~/ 2; // Integer division to get half the size

    Uint8List output = Uint8List(outputLength);
    int outputIndex = 0;

    for (int i = 0; i < inputLength; i += 4) {
      // Check if there are at least 2 bytes remaining in the input
      if (i + 1 < inputLength) {
        output[outputIndex++] = input[i];
        output[outputIndex++] = input[i + 1];
      }
    }

    return output;
  }
}
----- END ./lib/models/data_pattern_util.dart -----

----- BEGIN ./lib/models/debugging.dart -----
class Debugging {
  static const bool _toPrint = true;

  static void printing(String message) {
    if (_toPrint) {
      print(message);
    }
  }
}

----- END ./lib/models/debugging.dart -----

----- BEGIN ./lib/models/default_config_model.dart -----
import 'dart:convert';

class DefaultConfig {
  final Config? config;

  DefaultConfig({
    this.config,
  });

  DefaultConfig copyWith({
    Config? config,
  }) =>
      DefaultConfig(
        config: config ?? this.config,
      );

  factory DefaultConfig.fromRawJson(String str) =>
      DefaultConfig.fromJson(json.decode(str));

  String toRawJson() => json.encode(toJson());

  factory DefaultConfig.fromJson(Map<String, dynamic> json) => DefaultConfig(
        config: json["config"] == null ? null : Config.fromJson(json["config"]),
      );

  Map<String, dynamic> toJson() => {
        "config": config?.toJson(),
      };
}

class Config {
  final Version? version;
  final List<Board>? boards;

  Config({
    this.version,
    this.boards,
  });

  Config copyWith({
    Version? version,
    List<Board>? boards,
  }) =>
      Config(
        version: version ?? this.version,
        boards: boards ?? this.boards,
      );

  factory Config.fromRawJson(String str) => Config.fromJson(json.decode(str));

  String toRawJson() => json.encode(toJson());

  factory Config.fromJson(Map<String, dynamic> json) => Config(
        version: versionValues.map[json["version"]]!,
        boards: json["boards"] == null
            ? []
            : List<Board>.from(json["boards"]!.map((x) => Board.fromJson(x))),
      );

  Map<String, dynamic> toJson() => {
        "version": versionValues.reverse[version],
        "boards": boards == null
            ? []
            : List<dynamic>.from(boards!.map((x) => x.toJson())),
      };
}

class Board {
  final String? uniqueName;
  final String? userFriendlyFullName;
  final String? userFriendlyShortName;
  final String? hardwareComProtocolType;
  final BybProtocolType? bybProtocolType;
  final Version? bybProtocolVersion;
  final String? maxSampleRate;
  final String? maxNumberOfChannels;
  final int? sampleResolution;
  final String? supportedPlatforms;
  final String? productUrl;
  final String? helpUrl;
  final String? firmwareUpdateUrl;
  final String? iconUrl;
  final String? defaultTimeScale;
  final Version? defaultAmplitudeScale;
  final int? sampleRateIsFunctionOfNumberOfChannels;
  final MiniOsAppVersion? miniOsAppVersion;
  final MinAppVersion? minAndroidAppVersion;
  final MinAppVersion? minWinAppVersion;
  final MinAppVersion? minMacAppVersion;
  final MinAppVersion? minLinuxAppVersion;
  final int? p300CapabilityPresent;
  final Filter? filter;
  final List<Channel>? channels;
  final List<ExpansionBoard>? expansionBoards;
  final Usb? usb;

  Board({
    this.uniqueName,
    this.userFriendlyFullName,
    this.userFriendlyShortName,
    this.hardwareComProtocolType,
    this.bybProtocolType,
    this.bybProtocolVersion,
    this.maxSampleRate,
    this.maxNumberOfChannels,
    this.sampleResolution,
    this.supportedPlatforms,
    this.productUrl,
    this.helpUrl,
    this.firmwareUpdateUrl,
    this.iconUrl,
    this.defaultTimeScale,
    this.defaultAmplitudeScale,
    this.sampleRateIsFunctionOfNumberOfChannels,
    this.miniOsAppVersion,
    this.minAndroidAppVersion,
    this.minWinAppVersion,
    this.minMacAppVersion,
    this.minLinuxAppVersion,
    this.p300CapabilityPresent,
    this.filter,
    this.channels,
    this.expansionBoards,
    this.usb,
  });

  Board copyWith({
    String? uniqueName,
    String? userFriendlyFullName,
    String? userFriendlyShortName,
    String? hardwareComProtocolType,
    BybProtocolType? bybProtocolType,
    Version? bybProtocolVersion,
    String? maxSampleRate,
    String? maxNumberOfChannels,
    int? sampleResolution,
    String? supportedPlatforms,
    String? productUrl,
    String? helpUrl,
    String? firmwareUpdateUrl,
    String? iconUrl,
    String? defaultTimeScale,
    Version? defaultAmplitudeScale,
    int? sampleRateIsFunctionOfNumberOfChannels,
    MiniOsAppVersion? miniOsAppVersion,
    MinAppVersion? minAndroidAppVersion,
    MinAppVersion? minWinAppVersion,
    MinAppVersion? minMacAppVersion,
    MinAppVersion? minLinuxAppVersion,
    int? p300CapabilityPresent,
    Filter? filter,
    List<Channel>? channels,
    List<ExpansionBoard>? expansionBoards,
    Usb? usb,
  }) =>
      Board(
        uniqueName: uniqueName ?? this.uniqueName,
        userFriendlyFullName: userFriendlyFullName ?? this.userFriendlyFullName,
        userFriendlyShortName:
            userFriendlyShortName ?? this.userFriendlyShortName,
        hardwareComProtocolType:
            hardwareComProtocolType ?? this.hardwareComProtocolType,
        bybProtocolType: bybProtocolType ?? this.bybProtocolType,
        bybProtocolVersion: bybProtocolVersion ?? this.bybProtocolVersion,
        maxSampleRate: maxSampleRate ?? this.maxSampleRate,
        maxNumberOfChannels: maxNumberOfChannels ?? this.maxNumberOfChannels,
        sampleResolution: sampleResolution ?? this.sampleResolution,
        supportedPlatforms: supportedPlatforms ?? this.supportedPlatforms,
        productUrl: productUrl ?? this.productUrl,
        helpUrl: helpUrl ?? this.helpUrl,
        firmwareUpdateUrl: firmwareUpdateUrl ?? this.firmwareUpdateUrl,
        iconUrl: iconUrl ?? this.iconUrl,
        defaultTimeScale: defaultTimeScale ?? this.defaultTimeScale,
        defaultAmplitudeScale:
            defaultAmplitudeScale ?? this.defaultAmplitudeScale,
        sampleRateIsFunctionOfNumberOfChannels:
            sampleRateIsFunctionOfNumberOfChannels ??
                this.sampleRateIsFunctionOfNumberOfChannels,
        miniOsAppVersion: miniOsAppVersion ?? this.miniOsAppVersion,
        minAndroidAppVersion: minAndroidAppVersion ?? this.minAndroidAppVersion,
        minWinAppVersion: minWinAppVersion ?? this.minWinAppVersion,
        minMacAppVersion: minMacAppVersion ?? this.minMacAppVersion,
        minLinuxAppVersion: minLinuxAppVersion ?? this.minLinuxAppVersion,
        p300CapabilityPresent:
            p300CapabilityPresent ?? this.p300CapabilityPresent,
        filter: filter ?? this.filter,
        channels: channels ?? this.channels,
        expansionBoards: expansionBoards ?? this.expansionBoards,
        usb: usb ?? this.usb,
      );

  factory Board.fromRawJson(String str) => Board.fromJson(json.decode(str));

  String toRawJson() => json.encode(toJson());

  factory Board.fromJson(Map<String, dynamic> json) => Board(
        uniqueName: json["uniqueName"],
        userFriendlyFullName: json["userFriendlyFullName"],
        userFriendlyShortName: json["userFriendlyShortName"],
        hardwareComProtocolType: json["hardwareComProtocolType"],
        bybProtocolType: bybProtocolTypeValues.map[json["bybProtocolType"]]!,
        bybProtocolVersion: versionValues.map[json["bybProtocolVersion"]]!,
        maxSampleRate: json["maxSampleRate"],
        maxNumberOfChannels: json["maxNumberOfChannels"],
        sampleResolution: json["sampleResolution"],
        supportedPlatforms: json["supportedPlatforms"],
        productUrl: json["productURL"],
        helpUrl: json["helpURL"],
        firmwareUpdateUrl: json["firmwareUpdateUrl"],
        iconUrl: json["iconURL"],
        defaultTimeScale: json["defaultTimeScale"],
        defaultAmplitudeScale:
            versionValues.map[json["defaultAmplitudeScale"]]!,
        sampleRateIsFunctionOfNumberOfChannels:
            json["sampleRateIsFunctionOfNumberOfChannels"],
        miniOsAppVersion: miniOsAppVersionValues.map[json["miniOSAppVersion"]]!,
        minAndroidAppVersion:
            minAppVersionValues.map[json["minAndroidAppVersion"]]!,
        minWinAppVersion: minAppVersionValues.map[json["minWinAppVersion"]]!,
        minMacAppVersion: minAppVersionValues.map[json["minMacAppVersion"]]!,
        minLinuxAppVersion:
            minAppVersionValues.map[json["minLinuxAppVersion"]]!,
        p300CapabilityPresent: json["p300CapabilityPresent"],
        filter: json["filter"] == null ? null : Filter.fromJson(json["filter"]),
        channels: json["channels"] == null
            ? []
            : List<Channel>.from(
                json["channels"]!.map((x) => Channel.fromJson(x))),
        expansionBoards: json["expansionBoards"] == null
            ? []
            : List<ExpansionBoard>.from(json["expansionBoards"]!
                .map((x) => ExpansionBoard.fromJson(x))),
        usb: json["usb"] == null ? null : Usb.fromJson(json["usb"]),
      );

  Map<String, dynamic> toJson() => {
        "uniqueName": uniqueName,
        "userFriendlyFullName": userFriendlyFullName,
        "userFriendlyShortName": userFriendlyShortName,
        "hardwareComProtocolType": hardwareComProtocolType,
        "bybProtocolType": bybProtocolTypeValues.reverse[bybProtocolType],
        "bybProtocolVersion": versionValues.reverse[bybProtocolVersion],
        "maxSampleRate": maxSampleRate,
        "maxNumberOfChannels": maxNumberOfChannels,
        "sampleResolution": sampleResolution,
        "supportedPlatforms": supportedPlatforms,
        "productURL": productUrl,
        "helpURL": helpUrl,
        "firmwareUpdateUrl": firmwareUpdateUrl,
        "iconURL": iconUrl,
        "defaultTimeScale": defaultTimeScale,
        "defaultAmplitudeScale": versionValues.reverse[defaultAmplitudeScale],
        "sampleRateIsFunctionOfNumberOfChannels":
            sampleRateIsFunctionOfNumberOfChannels,
        "miniOSAppVersion": miniOsAppVersionValues.reverse[miniOsAppVersion],
        "minAndroidAppVersion":
            minAppVersionValues.reverse[minAndroidAppVersion],
        "minWinAppVersion": minAppVersionValues.reverse[minWinAppVersion],
        "minMacAppVersion": minAppVersionValues.reverse[minMacAppVersion],
        "minLinuxAppVersion": minAppVersionValues.reverse[minLinuxAppVersion],
        "p300CapabilityPresent": p300CapabilityPresent,
        "filter": filter?.toJson(),
        "channels": channels == null
            ? []
            : List<dynamic>.from(channels!.map((x) => x.toJson())),
        "expansionBoards": expansionBoards == null
            ? []
            : List<dynamic>.from(expansionBoards!.map((x) => x.toJson())),
        "usb": usb?.toJson(),
      };
}

enum BybProtocolType { BYB1, EMPTY }

final bybProtocolTypeValues =
    EnumValues({"BYB1": BybProtocolType.BYB1, "": BybProtocolType.EMPTY});

enum Version { EMPTY, THE_10 }

final versionValues = EnumValues({"": Version.EMPTY, "1.0": Version.THE_10});

class Channel {
  final String? userFriendlyFullName;
  final String? userFriendlyShortName;
  final int? activeByDefault;
  final int? filtered;
  final double? calibrationCoef;
  final int? channelIsCalibrated;
  final double? defaultVoltageScale;

  Channel({
    this.userFriendlyFullName,
    this.userFriendlyShortName,
    this.activeByDefault,
    this.filtered,
    this.calibrationCoef,
    this.channelIsCalibrated,
    this.defaultVoltageScale,
  });

  Channel copyWith({
    String? userFriendlyFullName,
    String? userFriendlyShortName,
    int? activeByDefault,
    int? filtered,
    double? calibrationCoef,
    int? channelIsCalibrated,
    double? defaultVoltageScale,
  }) =>
      Channel(
        userFriendlyFullName: userFriendlyFullName ?? this.userFriendlyFullName,
        userFriendlyShortName:
            userFriendlyShortName ?? this.userFriendlyShortName,
        activeByDefault: activeByDefault ?? this.activeByDefault,
        filtered: filtered ?? this.filtered,
        calibrationCoef: calibrationCoef ?? this.calibrationCoef,
        channelIsCalibrated: channelIsCalibrated ?? this.channelIsCalibrated,
        defaultVoltageScale: defaultVoltageScale ?? this.defaultVoltageScale,
      );

  factory Channel.fromRawJson(String str) => Channel.fromJson(json.decode(str));

  String toRawJson() => json.encode(toJson());

  factory Channel.fromJson(Map<String, dynamic> json) => Channel(
        userFriendlyFullName: json["userFriendlyFullName"],
        userFriendlyShortName: json["userFriendlyShortName"],
        activeByDefault: json["activeByDefault"],
        filtered: json["filtered"],
        calibrationCoef: json["calibrationCoef"],
        channelIsCalibrated: json["channelIsCalibrated"],
        defaultVoltageScale: json["defaultVoltageScale"]?.toDouble(),
      );

  Map<String, dynamic> toJson() => {
        "userFriendlyFullName": userFriendlyFullName,
        "userFriendlyShortName": userFriendlyShortName,
        "activeByDefault": activeByDefault,
        "filtered": filtered,
        "calibrationCoef": calibrationCoef,
        "channelIsCalibrated": channelIsCalibrated,
        "defaultVoltageScale": defaultVoltageScale,
      };
}

class ExpansionBoard {
  final String? boardType;
  final UserFriendlyFullName? userFriendlyFullName;
  final UserFriendlyShortName? userFriendlyShortName;
  final SupportedPlatforms? supportedPlatforms;
  final String? maxNumberOfChannels;
  final String? maxSampleRate;
  final String? productUrl;
  final String? helpUrl;
  final String? iconUrl;
  final String? defaultTimeScale;
  final Version? defaultAmplitudeScale;
  final List<Channel>? channels;

  ExpansionBoard({
    this.boardType,
    this.userFriendlyFullName,
    this.userFriendlyShortName,
    this.supportedPlatforms,
    this.maxNumberOfChannels,
    this.maxSampleRate,
    this.productUrl,
    this.helpUrl,
    this.iconUrl,
    this.defaultTimeScale,
    this.defaultAmplitudeScale,
    this.channels,
  });

  ExpansionBoard copyWith({
    String? boardType,
    UserFriendlyFullName? userFriendlyFullName,
    UserFriendlyShortName? userFriendlyShortName,
    SupportedPlatforms? supportedPlatforms,
    String? maxNumberOfChannels,
    String? maxSampleRate,
    String? productUrl,
    String? helpUrl,
    String? iconUrl,
    String? defaultTimeScale,
    Version? defaultAmplitudeScale,
    List<Channel>? channels,
  }) =>
      ExpansionBoard(
        boardType: boardType ?? this.boardType,
        userFriendlyFullName: userFriendlyFullName ?? this.userFriendlyFullName,
        userFriendlyShortName:
            userFriendlyShortName ?? this.userFriendlyShortName,
        supportedPlatforms: supportedPlatforms ?? this.supportedPlatforms,
        maxNumberOfChannels: maxNumberOfChannels ?? this.maxNumberOfChannels,
        maxSampleRate: maxSampleRate ?? this.maxSampleRate,
        productUrl: productUrl ?? this.productUrl,
        helpUrl: helpUrl ?? this.helpUrl,
        iconUrl: iconUrl ?? this.iconUrl,
        defaultTimeScale: defaultTimeScale ?? this.defaultTimeScale,
        defaultAmplitudeScale:
            defaultAmplitudeScale ?? this.defaultAmplitudeScale,
        channels: channels ?? this.channels,
      );

  factory ExpansionBoard.fromRawJson(String str) =>
      ExpansionBoard.fromJson(json.decode(str));

  String toRawJson() => json.encode(toJson());

  factory ExpansionBoard.fromJson(Map<String, dynamic> json) => ExpansionBoard(
        boardType: json["boardType"],
        userFriendlyFullName:
            userFriendlyFullNameValues.map[json["userFriendlyFullName"]]!,
        userFriendlyShortName:
            userFriendlyShortNameValues.map[json["userFriendlyShortName"]]!,
        supportedPlatforms:
            supportedPlatformsValues.map[json["supportedPlatforms"]],
        maxNumberOfChannels: json["maxNumberOfChannels"],
        maxSampleRate: json["maxSampleRate"],
        productUrl: json["productURL"],
        helpUrl: json["helpURL"],
        iconUrl: json["iconURL"],
        defaultTimeScale: json["defaultTimeScale"],
        defaultAmplitudeScale:
            versionValues.map[json["defaultAmplitudeScale"]] ?? Version.EMPTY,
        channels: json["channels"] == null
            ? []
            : List<Channel>.from(
                json["channels"]!.map((x) => Channel.fromJson(x))),
      );

  Map<String, dynamic> toJson() => {
        "boardType": boardType,
        "userFriendlyFullName":
            userFriendlyFullNameValues.reverse[userFriendlyFullName],
        "userFriendlyShortName":
            userFriendlyShortNameValues.reverse[userFriendlyShortName],
        "supportedPlatforms":
            supportedPlatformsValues.reverse[supportedPlatforms],
        "maxNumberOfChannels": maxNumberOfChannels,
        "maxSampleRate": maxSampleRate,
        "productURL": productUrl,
        "helpURL": helpUrl,
        "iconURL": iconUrl,
        "defaultTimeScale": defaultTimeScale,
        "defaultAmplitudeScale": versionValues.reverse[defaultAmplitudeScale],
        "channels": channels == null
            ? []
            : List<dynamic>.from(channels!.map((x) => x.toJson())),
      };
}

enum SupportedPlatforms { ANDROID_IOS_WIN_MAC_LINUX, IOS, WIN }

final supportedPlatformsValues = EnumValues({
  "android,ios,win,mac,linux": SupportedPlatforms.ANDROID_IOS_WIN_MAC_LINUX,
  "ios": SupportedPlatforms.IOS,
  "win": SupportedPlatforms.WIN
});

enum UserFriendlyFullName {
  ADDITIONAL_ANALOG_INPUT_CHANNELS,
  DEFAULT_EVENTS_DETECTION_EXPANSION_BOARD,
  THE_JOYSTICK_CONTROL,
  THE_REFLEX_HAMMER
}

final userFriendlyFullNameValues = EnumValues({
  "Additional analog input channels":
      UserFriendlyFullName.ADDITIONAL_ANALOG_INPUT_CHANNELS,
  "Default - events detection expansion board":
      UserFriendlyFullName.DEFAULT_EVENTS_DETECTION_EXPANSION_BOARD,
  "The Joystick control": UserFriendlyFullName.THE_JOYSTICK_CONTROL,
  "The Reflex Hammer": UserFriendlyFullName.THE_REFLEX_HAMMER
});

enum UserFriendlyShortName { ANALOG_X_2, EVENTS_DETECTION, HAMMER, JOYSTICK }

final userFriendlyShortNameValues = EnumValues({
  "Analog x 2": UserFriendlyShortName.ANALOG_X_2,
  "Events detection": UserFriendlyShortName.EVENTS_DETECTION,
  "Hammer": UserFriendlyShortName.HAMMER,
  "Joystick": UserFriendlyShortName.JOYSTICK
});

class Filter {
  final String? signalType;
  final int? lowPassOn;
  final String? lowPassCutoff;
  final int? highPassOn;
  final String? highPassCutoff;
  final NotchFilterState? notchFilterState;

  Filter({
    this.signalType,
    this.lowPassOn,
    this.lowPassCutoff,
    this.highPassOn,
    this.highPassCutoff,
    this.notchFilterState,
  });

  Filter copyWith({
    String? signalType,
    int? lowPassOn,
    String? lowPassCutoff,
    int? highPassOn,
    String? highPassCutoff,
    NotchFilterState? notchFilterState,
  }) =>
      Filter(
        signalType: signalType ?? this.signalType,
        lowPassOn: lowPassOn ?? this.lowPassOn,
        lowPassCutoff: lowPassCutoff ?? this.lowPassCutoff,
        highPassOn: highPassOn ?? this.highPassOn,
        highPassCutoff: highPassCutoff ?? this.highPassCutoff,
        notchFilterState: notchFilterState ?? this.notchFilterState,
      );

  factory Filter.fromRawJson(String str) => Filter.fromJson(json.decode(str));

  String toRawJson() => json.encode(toJson());

  factory Filter.fromJson(Map<String, dynamic> json) => Filter(
        signalType: json["signalType"],
        lowPassOn: json["lowPassON"],
        lowPassCutoff: json["lowPassCutoff"],
        highPassOn: json["highPassON"],
        highPassCutoff: json["highPassCutoff"],
        notchFilterState: notchFilterStateValues.map[json["notchFilterState"]]!,
      );

  Map<String, dynamic> toJson() => {
        "signalType": signalType,
        "lowPassON": lowPassOn,
        "lowPassCutoff": lowPassCutoff,
        "highPassON": highPassOn,
        "highPassCutoff": highPassCutoff,
        "notchFilterState": notchFilterStateValues.reverse[notchFilterState],
      };
}

enum NotchFilterState { NOTCH60_HZ, NOTCH_OFF }

final notchFilterStateValues = EnumValues({
  "notch60Hz": NotchFilterState.NOTCH60_HZ,
  "notchOff": NotchFilterState.NOTCH_OFF
});

enum MinAppVersion { THE_100 }

final minAppVersionValues = EnumValues({"1.0.0": MinAppVersion.THE_100});

enum MiniOsAppVersion { THE_300 }

final miniOsAppVersionValues = EnumValues({"3.0.0": MiniOsAppVersion.THE_300});

class Usb {
  final String? vid;
  final String? pid;

  Usb({
    this.vid,
    this.pid,
  });

  Usb copyWith({
    String? vid,
    String? pid,
  }) =>
      Usb(
        vid: vid ?? this.vid,
        pid: pid ?? this.pid,
      );

  factory Usb.fromRawJson(String str) => Usb.fromJson(json.decode(str));

  String toRawJson() => json.encode(toJson());

  factory Usb.fromJson(Map<String, dynamic> json) => Usb(
        vid: json["VID"],
        pid: json["PID"],
      );

  Map<String, dynamic> toJson() => {
        "VID": vid,
        "PID": pid,
      };
}

class EnumValues<T> {
  Map<String, T> map;
  late Map<T, String> reverseMap;

  EnumValues(this.map);

  Map<T, String> get reverse {
    reverseMap = map.map((k, v) => MapEntry(v, k));
    return reverseMap;
  }
}

----- END ./lib/models/default_config_model.dart -----

----- BEGIN ./lib/models/device_com_listen.dart -----
import 'dart:async';

import 'package:flutter/services.dart';

StreamSubscription<Uint8List>? listenPort;

----- END ./lib/models/device_com_listen.dart -----

----- BEGIN ./lib/models/enum/notch_check_filter.dart -----
class NotchSetFrequencySetting {
  NotchSetFrequencyEnum setFrequency;
  bool isNotchFrequency;

  NotchSetFrequencySetting(
      {required this.isNotchFrequency, required this.setFrequency});
}

enum NotchSetFrequencyEnum { fiftyHertz, sixtyHertz }

----- END ./lib/models/enum/notch_check_filter.dart -----

----- BEGIN ./lib/models/envelop_data.dart -----
import 'dart:typed_data';

class Enveloping {
  List<Int16List> envelopes = [];
  List<Int16List> outSamples = [];
  List<Int16List> tempSamples = [];
  List<int> skipCounts = [];
  List<int> envelopeSizes = [];

  int channelCount = 0;
  double divider = 0;
  int current_start = 0;
  List<Int16List> outSamplesPtr = [];
  List<Int16List> tempSamplesPtr = [];

  void resetEnvelope(int channelIdx, int forceLevel) {
    int sizeOfEnvelope = (2 * envelopeSizes[forceLevel]).floor();
    for (int i = 0; i < sizeOfEnvelope; i++) {
      envelopes[channelIdx][forceLevel] = 0;
    }
  }

  void resetOutSamples(int channelIdx, int outSampleCount) {
    for (int i = 0; i < outSampleCount; i++) {
      outSamples[channelIdx][i] = 0;
    }
  }

  void envelopingSamples(
      int head, int sample, int channelIdx, int sizeLogs, int forceLevel) {
    int j = forceLevel;
    int skipCount = skipCounts[j];
    int envelopeSampleIndex = (head / skipCount).floor();
    int interleavedSignalIdx = envelopeSampleIndex * 2;

    if (head % skipCount == 0) {
      envelopes[j][interleavedSignalIdx] = sample;
      envelopes[j][interleavedSignalIdx + 1] = sample;
    } else {
      if (sample < envelopes[j][interleavedSignalIdx]) {
        envelopes[j][interleavedSignalIdx] = sample;
      }

      if (sample > envelopes[j][interleavedSignalIdx + 1]) {
        envelopes[j][interleavedSignalIdx + 1] = sample;
      }
    }
  }

  Int16List getSamplesThresholdProcess(int channelIdx, Int16List data,
      int forceLevel, double _divider, int currentStart, int sampleNeeded) {
    divider = _divider;
    current_start = currentStart.floor();
    int sizeOfEnvelope = sampleNeeded;
    int rawSizeOfEnvelope =
        ((sampleNeeded / 2) * skipCounts[forceLevel]).toInt();

    int maxEnvelopeSize = (envelopeSizes[0] / 2).floor();
    int samplesLength = rawSizeOfEnvelope;
    int sampleStart = 0;
    int sampleEnd = samplesLength;

    tempSamplesPtr[channelIdx]
        .setAll(0, outSamplesPtr[channelIdx].sublist(0, maxEnvelopeSize));

    try {
      for (int i = 0; i < channelCount; i++) {
        if (i == channelIdx) {
          sampleStart = 0;
          sampleEnd = samplesLength;
          if (current_start != 0) {
            sampleStart = current_start.abs();
            if (sampleStart < 0) {
              sampleStart = 0;
            }
            sampleEnd = sampleStart + samplesLength;
            if (sampleEnd > maxEnvelopeSize) {}
          }
          int j = 0;
          resetEnvelope(channelIdx, forceLevel);

          for (int jj = sampleStart; jj < sampleEnd; jj++) {
            envelopingSamples(
                jj, tempSamplesPtr[i][jj], channelIdx, 45, forceLevel);
            j++;
          }
        }
      }

      Int16List result = Int16List(sizeOfEnvelope);
      result.setAll(0, envelopes[channelIdx][forceLevel] as Iterable<int>);
      resetEnvelope(channelIdx, forceLevel);

      return result;
    } catch (e) {
      // Handle the exception
      return Int16List(1);
    }
  }

  void main() {
    // Initialize your variables and data structures before using the functions
  }
}

----- END ./lib/models/envelop_data.dart -----

----- BEGIN ./lib/models/escape_sequences/escape_sequence.dart -----
import 'dart:typed_data';
import '../models.dart';

class EscapeSequence {
  EscapeSequence({
    this.onDeviceData,
    this.onDeviceMessage,
  });

  final Function(Uint8List)? onDeviceData;
  final Function(Uint8List)? onDeviceMessage;

  /// 255, 255, 1, 1, 128, 255
  static final Uint8List startSequence = Uint8List.fromList([255, 255, 1, 1, 128, 255]);

  /// 255, 255, 1, 1, 129, 255
  static final Uint8List endSequence = Uint8List.fromList([255, 255, 1, 1, 129, 255]);

  SequenceIndexes _startSequenceIndexes = const SequenceIndexes();
  SequenceIndexes _endSequenceIndexes = const SequenceIndexes();
  Uint8List _responseBytes = Uint8List(0);
  Uint8List _messageBuffer = Uint8List.fromList([]);

  /// Adds data to [_responseBytes]
  void _addDataToBuffer(List<int> dataToAdd) {
    // Debugging.printing("Existing buffer: $_responseBytes\nData added to buffer: $dataToAdd");
    _responseBytes = Uint8List.fromList([..._responseBytes, ...dataToAdd]);
  }

  /// Adds data to [_messageBuffer]
  void _addDataToMessageBuffer(List<int> dataToAdd) {
    // Debugging.printing("Existing MESSAGE buffer: $_messageBuffer\nData added to MESSAGE buffer: $dataToAdd");
    _messageBuffer = Uint8List.fromList([..._messageBuffer, ...dataToAdd]);
  }

  void _sendDataAndClearBuffer() {
    if (onDeviceData == null) return;
    if (_responseBytes.isEmpty) return;

    onDeviceData!(_responseBytes);
    _responseBytes = Uint8List.fromList([]);
    _endSequenceIndexes = const SequenceIndexes();
    _startSequenceIndexes = const SequenceIndexes();
  }

  void sendMessageAndClearBuffer() {
    if (onDeviceMessage == null) return;
    if (_messageBuffer.isEmpty) return;
    onDeviceMessage!(_messageBuffer);
    _messageBuffer = Uint8List.fromList([]);
  }

  /// Checks packet for escape sequences
  /// Adds the data to buffer [_responseBytes]
  void addPacket(Uint8List newPacket) {
    if (_startSequenceIndexes.endIndex == -1) {
      // Either start sequence has NOT been found or PARTIALLY found
      _searchStartSequence(newPacket);
    } else {
      // Start sequence has been found
      // End sequence needs to be found
      _searchEndSequence(newPacket, false);
    }
  }

  void _searchStartSequence(Uint8List newPacket) {
    if (_startSequenceIndexes.startIndex == -1) {
      // Check for escape sequence before adding data to buffer
      _startSequenceIndexes = _checkForEscapeSequenceStart(newPacket: newPacket);
      if (_startSequenceIndexes.endIndex != -1) {
        // Entire start sequence is found

        // Add data to message list also
        _addDataToMessageBuffer(newPacket.getRange(_startSequenceIndexes.endIndex + 1, newPacket.length).toList(growable: false));
        // Find the end sequence
        _searchEndSequence(newPacket);
      } else {
        // Add the data to buffer
        _addDataToBuffer(newPacket);

        if (_startSequenceIndexes.startIndex == -1) {
          // No start sequence is found
          // Return the data using callback
          _sendDataAndClearBuffer();
        }
      }
    } else {
      // Check the start of packet for continuing escape sequence
      bool isFoundAtStart = _checkBeginningForSequence(newPacket: newPacket);
      if (isFoundAtStart) {
        // Add data to message list also
        _addDataToMessageBuffer(newPacket.getRange(_startSequenceIndexes.endIndex + 1, newPacket.length).toList(growable: false));

        // Start adding data to response buffer - Including the partial part of start sequence
        _addDataToBuffer(newPacket.toList(growable: false));

        // Find the end sequence
        _searchEndSequence(newPacket);
      } else {
        _startSequenceIndexes = const SequenceIndexes();
        // Search the entire packet for start sequence
        _searchStartSequence(newPacket);
      }
    }
  }

  void _searchEndSequence(Uint8List newPacket, [bool isSamePacket = true]) {
    if (_endSequenceIndexes.startIndex == -1) {
      // Check for end of escape sequence before adding data to buffer
      _endSequenceIndexes = _checkForEscapeSequenceStart(newPacket: newPacket, isStartSequence: false);
      if (_endSequenceIndexes.endIndex != -1) {
        // Entire end sequence found
        // Find the response
        _addDataToBuffer(newPacket);
        Debugging.printing('COMPLETE end sequence found');
        _removeEndSequenceAndAddResponse(newPacket, isSamePacket);
      } else {
        _addDataToBuffer(newPacket);
      }
    } else {
      // Check the start of packet for continuing escape sequence
      bool isFoundAtStart = _checkBeginningForSequence(newPacket: newPacket, isStartSequence: false);
      if (isFoundAtStart) {
        // Entire end sequence found
        // Find the response
        _addDataToBuffer(newPacket);
        Debugging.printing('COMPLETE end sequence found AT beginning');
        Debugging.printing("adding newPacket: $newPacket");
        _adjustBuffersAndCallbacks();
      } else {
        // Remaining part of end sequence NOT found
        _endSequenceIndexes = const SequenceIndexes();
        _addDataToBuffer(newPacket);
        _resetAndCheckRemainingData();
      }
    }
  }

  /// Finds the index of End sequence
  /// Adds message to message buffer
  /// Adds the incoming bytes including data and message to [_responseBytes]
  /// Then removes the messages and sequences from the [_responseBytes]
  /// CALLBACKS - sends message and sends data
  void _removeEndSequenceAndAddResponse(Uint8List bytes, bool isSamePacket) {
    // final Uint8List secondSequences = Uint8List.fromList([255, 255, 1, 1, 129, 255]);
    int matchingIndex = -1;
    int indexTillWhichCheck = bytes.length - endSequence.length;
    for (int i = 0; i <= indexTillWhichCheck; i++) {
      bool match = true;
      for (int j = 0; j < endSequence.length; j++) {
        int a = bytes[i + j];
        int b = endSequence[j];
        if (a != b) {
          match = false;
          break;
        }
      }
      if (match) {
        matchingIndex = i;
        break;
      }
    }

    if (matchingIndex == -1) {
      // Empty the message buffer
      _messageBuffer = Uint8List.fromList([]);
      return;
    }

    if (isSamePacket) {
      // Remove [end sequence +  bytes after that] from Message
      _removeEndSeqAndBytesAfter();
    } else {
      // To be added to message received buffer
      List<int> beforeEndSequence = bytes.sublist(0, matchingIndex);
      _addDataToMessageBuffer(beforeEndSequence);
    }

    // // To be added to response data buffer
    // List<int> afterEndSequence = bytes.sublist(matchingIndex + endSequence.length);
    // addDataToBuffer(afterEndSequence);

    _adjustBuffersAndCallbacks();
  }

  void _adjustBuffersAndCallbacks() {
    removeMessageAndSequencesFromResponseBuffer();

    // Message can be sent through callback but data needs to be checked again for sequence
    sendMessageAndClearBuffer();
    // sendDataAndClearBuffer();

    _resetAndCheckRemainingData();
  }

  void _resetAndCheckRemainingData() {
    // Data buffer needs to be added back as a new packet to check for next starting sequence
    Uint8List dataToRecheck = Uint8List(_responseBytes.length);
    dataToRecheck.setAll(0, _responseBytes);

    _responseBytes = Uint8List.fromList([]);
    _endSequenceIndexes = const SequenceIndexes();
    _startSequenceIndexes = const SequenceIndexes();
    addPacket(dataToRecheck);
  }

  /// Removes start sequence,
  /// Removes message,
  /// Removes end sequence
  removeMessageAndSequencesFromResponseBuffer() {
    List<int> a = _responseBytes.toList();
    List<int> b = [...startSequence, ..._messageBuffer, ...endSequence];

    // Check if 'a' contains 'b'
    int index = -1;
    for (int i = 0; i <= a.length - b.length; i++) {
      if (a[i] == b[0]) {
        bool match = true;
        for (int j = 1; j < b.length; j++) {
          if (a[i + j] != b[j]) {
            match = false;
            break;
          }
        }
        if (match) {
          index = i;
          break;
        }
      }
    }

    // If 'a' contains 'b', remove the first instance of 'b' from 'a'
    if (index != -1) {
      a.removeRange(index, index + b.length);
      _responseBytes = Uint8List.fromList(a);
    }
  }

  /// Searches for end sequence in message buffer,
  /// Removes bytes of end sequence and also the bytes after end sequence
  void _removeEndSeqAndBytesAfter() {
    List<int> a = _messageBuffer.toList();
    List<int> b = endSequence;
    if (a.isEmpty || b.isEmpty || b.length > a.length) {
      return; // 'b' is not present in 'a', or invalid input
    }

    // Check if 'a' contains 'b'
    int index = -1;
    for (int i = 0; i <= a.length - b.length; i++) {
      if (a[i] == b[0]) {
        bool match = true;
        for (int j = 1; j < b.length; j++) {
          if (a[i + j] != b[j]) {
            match = false;
            break;
          }
        }
        if (match) {
          index = i;
          break;
        }
      }
    }

    if (index != -1) {
      a.removeRange(index, a.length);
      _messageBuffer = Uint8List.fromList(a);
    }
  }

  /// isStartSequence - Defines the pattern to be founc
  /// TRUE - uses start sequence pattern
  /// FALSE - uses end sequence pattern
  /// Returns the first sequence start in the packet
  SequenceIndexes _checkForEscapeSequenceStart({required Uint8List newPacket, bool isStartSequence = true}) {
    Uint8List sequenceToFind;
    if (isStartSequence) {
      sequenceToFind = startSequence;
    } else {
      sequenceToFind = endSequence;
    }
    int beginIndex = -1;
    int endIndex = -1;
    int sequenceCharacterIndex = -1;
    List<int> seqFound = [];

    // Checking for sequence start
    outerLoop:
    for (int i = 0; i < newPacket.length; i++) {
      for (int j = 0; j < sequenceToFind.length; j++) {
        if (i + j >= newPacket.length) {
          // break loop if end of packet is reached
          break outerLoop;
        }
        if (newPacket[i + j] != sequenceToFind[j]) {
          // Next character did not match. Resetting the variables.
          beginIndex = -1;
          seqFound.clear();
          break;
        }
        // Adding the characters found
        seqFound.add(sequenceToFind[j]);

        // Only when the first index is found
        if (beginIndex == -1) beginIndex = i + j;

        // Only when the last index is found
        if (j == sequenceToFind.length - 1) {
          endIndex = i + j;
          break outerLoop;
        }
      }
    }

    SequenceIndexes si = SequenceIndexes(
      endIndex: endIndex,
      startIndex: beginIndex,
      sequenceCharacterIndex: sequenceCharacterIndex,
      seqFound: seqFound,
    );

    // Debugging.printing("SequenceIndex in checkForEscapeSequenceStart() : $si");

    return si;
  }

  /// isStartSequence - TRUE - uses start sequence pattern
  /// FALSE - uses end sequence pattern
  bool _checkBeginningForSequence({required Uint8List newPacket, bool isStartSequence = true}) {
    Uint8List sequenceToFind;
    int bytesFound;
    if (isStartSequence) {
      sequenceToFind = startSequence;
      bytesFound = _startSequenceIndexes.seqFound.length;
    } else {
      sequenceToFind = endSequence;
      bytesFound = _endSequenceIndexes.seqFound.length;
    }
    int bytesToMatch = sequenceToFind.length - bytesFound;
    bool remainingFound = true;
    for (int i = 0; i < bytesToMatch; i++) {
      if (newPacket[i] != sequenceToFind[bytesFound + i]) {
        remainingFound = false;
        break;
      }
    }
    if (remainingFound) {
      if (isStartSequence) {
        _startSequenceIndexes = _startSequenceIndexes.copyWith(endIndex: bytesToMatch - 1);
      } else {
        _endSequenceIndexes = _endSequenceIndexes.copyWith(endIndex: bytesToMatch - 1);
      }
    }
    return remainingFound;
  }
}

class SequenceIndexes {
  const SequenceIndexes({
    this.seqFound = const [],
    this.endIndex = -1,
    this.startIndex = -1,
    this.sequenceCharacterIndex = -1,
  });

  final int startIndex;
  final int endIndex;
  final int sequenceCharacterIndex;
  final List<int> seqFound;

  SequenceIndexes copyWith({int? startIndex, int? endIndex, int? sequenceCharacterIndex, List<int>? seqFound}) {
    return SequenceIndexes(
      startIndex: startIndex ?? this.startIndex,
      endIndex: endIndex ?? this.endIndex,
      sequenceCharacterIndex: sequenceCharacterIndex ?? this.sequenceCharacterIndex,
      seqFound: seqFound ?? this.seqFound,
    );
  }

  @override
  String toString() {
    super.toString();
    return "Sequence Indexes: startIndex: $startIndex, endIndex: $endIndex, sequenceCharIndex: $sequenceCharacterIndex, seqFound: $seqFound";
  }
}

// TODO: Remove this test function
/// Function to test Escape Sequence class
void checkEscapeSequence() {
  EscapeSequence escapeSequence = EscapeSequence(
    onDeviceData: (Uint8List devData) {
      Debugging.printing("Device data callback: $devData");
    },
    onDeviceMessage: (Uint8List msg) {
      Debugging.printing("Device message callback: $msg");
    },
  );
  Uint8List bytes0 = Uint8List.fromList(List.generate(10, (index) => 40 + index));
  Uint8List bytes1 = Uint8List.fromList([255, 255, 1, 1, ...List.generate(7, (index) => 50 + index)]);
  Uint8List bytes2 = Uint8List.fromList([255, 255, 1, 1, 128, 255, ...List.generate(11, (index) => 100 + index)]);
  Uint8List bytes3 = Uint8List.fromList([...List.generate(8, (index) => 111 + index), 255, 255, 1, 1, 129, 255, 192, 36, 63, 80, 255, 255, 1, 1, 128, 255, 1, 2, 3, 4, 5, 255, 255, 1]);
  Uint8List bytes4 = Uint8List.fromList([1, 129, 255, 70, 87, 86, 58, 49, 46, 48, 53, 59, 72, 87, 84, 58, 72, 85, 77, 65, 78, 83, 66, 59, 72, 87, 86, 58, 51, 46, 49, 48, 59]);
  List<Uint8List> addedList = [bytes0, bytes1, bytes2, bytes3, bytes4];
  for (int i = 0; i < addedList.length; i++) {
    Debugging.printing("packet added: $i");
    escapeSequence.addPacket(addedList[i]);
    Debugging.printing("\n");
  }
}

----- END ./lib/models/escape_sequences/escape_sequence.dart -----

----- BEGIN ./lib/models/frame_detect.dart -----
import 'dart:typed_data';

class FrameDetect {
  FrameDetect({
    required this.channelCount,
    this.minimumBytesToCheck,
  }) : _channelBytes = channelCount * 2;

  final int channelCount;
  final int _channelBytes;
  final List<int> _data = List.empty(growable: true);
  final int? minimumBytesToCheck;

  /// Waits for atleast 50 bytes before checking the data for Frame Flag
  Uint8List? addData(Uint8List newData) {
    _data.addAll(newData);
    if(minimumBytesToCheck != null ) if(_data.length < minimumBytesToCheck!) return null;
    return _detectFrameFlag();
  }

  /// Returns data from the index first frame flag is identified
  Uint8List? _detectFrameFlag() {
    int frameFlag = _data.indexWhere((element) => element > 127);
    if(frameFlag == -1) return null;
    int remainingBytesInFrame = (_channelBytes) - 1;
    bool is7thBitLow = false;
    for(int i = 0; i < remainingBytesInFrame; i++) {
      is7thBitLow  =  _data[(frameFlag + 1) + i] < 128;
      if(!is7thBitLow) break;
    }
    if(is7thBitLow) {
      return Uint8List.fromList(_data.sublist(frameFlag));
    }
    return null;
  }
}

----- END ./lib/models/frame_detect.dart -----

----- BEGIN ./lib/models/generating_sample_data.dart -----
import 'dart:math' as math;
import 'dart:typed_data';

abstract class GenerateSampleData {
  /// [frequencies] list of frequencies to be included in the signal
  static List<double> sineWaveDouble(
      {required int samplingRate,
      required List<int> frequencies,
      int samplesGenerated = 4096}) {
    List<double> wave =
        List.generate(samplesGenerated, (index) => 0, growable: false);

    for (int k = 0; k < frequencies.length; k++) {
      for (int i = 0; i < samplesGenerated; i++) {
        double hz_1 = (math.sin((2 * 3.14159265358979323846264338328) *
            frequencies[k] *
            i /
            samplingRate));
        wave[i] += hz_1;
      }
    }
    return wave;
  }

  static Uint16List sineWaveUint16(
      {required int samplingRate,
      required List<int> frequencies,
      int samplesGenerated = 4096}) {
    return doubleListToUint16List(sineWaveDouble(
      samplingRate: samplingRate,
      frequencies: frequencies,
      samplesGenerated: samplesGenerated,
    ));
  }

  static Uint16List sineWaveUint14(
      {required int samplingRate,
      required List<int> frequencies,
      int samplesGenerated = 4096}) {
    return scaleUint16ListTo14Bit(sineWaveUint16(
      samplingRate: samplingRate,
      frequencies: frequencies,
      samplesGenerated: samplesGenerated,
    ));
  }

  static Uint16List scaleUint16ListTo14Bit(Uint16List input) {
    final int maxInput = input.reduce(
        (a, b) => a > b ? a : b); // Find the maximum value in the input list

    // Scale the values to the range [0, 16383]
    final scaledValues = input.map((value) => (value ~/ 4)).toList();
    final int maxScaledValues = scaledValues.reduce(
        (a, b) => a > b ? a : b); // Find the maximum value in the input list
    final int minScaledValues = scaledValues.reduce(
        (a, b) => a < b ? a : b); // Find the minimum value in the input list

    // Create a Uint16List from the scaled values
    final uint14List = Uint16List.fromList(scaledValues);

    return uint14List;
  }

  static Uint16List doubleListToUint16List(List<double> input) {
    final double maxInput = input.reduce(
        (a, b) => a > b ? a : b); // Find the maximum value in the input list
    final double minInput = input.reduce(
        (a, b) => a < b ? a : b); // Find the minimum value in the input list

    // Normalize the values to the range [minInput, maxInput]
    final List<double> zeroBasedValues =
        input.map((value) => (value - minInput)).toList();
    final double maxZeroBasedValues = zeroBasedValues.reduce(
        (a, b) => a > b ? a : b); // Find the maximum value in the input list
    final double minZeroBasedValues = zeroBasedValues.reduce(
        (a, b) => a < b ? a : b); // Find the minimum value in the input list

    final List<double> normalizedValues =
        zeroBasedValues.map((value) => (value / maxZeroBasedValues)).toList();
    final double maxNormalizedValues = normalizedValues.reduce(
        (a, b) => a > b ? a : b); // Find the maximum value in the input list
    final double minNormalizedValues = normalizedValues.reduce(
        (a, b) => a < b ? a : b); // Find the minimum value in the input list

    // Scale the normalized values to the range [0, 65535]
    final List<int> scaledValues =
        normalizedValues.map((value) => (value * 65535).round()).toList();
    final int maxScaledValues = scaledValues.reduce(
        (a, b) => a > b ? a : b); // Find the maximum value in the input list
    final int minScaledValues = scaledValues.reduce(
        (a, b) => a < b ? a : b); // Find the minimum value in the input list

    // Create a Uint16List from the scaled values
    final uint16List = Uint16List.fromList(scaledValues);

    return uint16List;
  }
}

----- END ./lib/models/generating_sample_data.dart -----

----- BEGIN ./lib/models/global_buffer.dart -----
import 'package:spikerbox_architecture/models/models.dart';

late final BufferHandler preEscapeSequenceBuffer;

FrameDetect frameDetect = FrameDetect(channelCount: 1);
final SerialUtil serialUtil = SerialUtil();
bool isDataIdentified = false;
LocalPlugin localPlugin = LocalPlugin();

----- END ./lib/models/global_buffer.dart -----

----- BEGIN ./lib/models/int_extensions.dart -----
extension MyIntExtensions on int {
  String get intToBinary => toRadixString(2).padLeft(8, "0");
}
----- END ./lib/models/int_extensions.dart -----

----- BEGIN ./lib/models/local_plugins/local_plugins.dart -----
import 'local_plugins_check.dart';

LocalPlugin getLocalPlugins() =>
    throw UnimplementedError('PlatForm is not Implemented');

----- END ./lib/models/local_plugins/local_plugins.dart -----

----- BEGIN ./lib/models/local_plugins/local_plugins_android.dart -----
import 'dart:async';
import 'dart:typed_data';
import 'package:native_add/model/model.dart';
import 'package:native_add/native_add.dart' as native_add;
import 'package:spikerbox_architecture/models/models.dart';
import 'package:spikerbox_architecture/provider/provider_export.dart';

class LocalPluginAndroid implements LocalPlugin {
  final List<BufferHandlerOnDemand?> _bufferHandlerOnDemand =
      List.filled(channelCountBuffer, null);

  @override
  Future<void> spawnHelperIsolate(EnvelopConfigProvider envelopConfig) async {
    postFilterStream = postFilterStreamController.stream.asBroadcastStream();

    await native_add.spawnHelperIsolate();
    for (int i = 0; i < channelCountBuffer; i++) {
      _bufferHandlerOnDemand[i] = BufferHandlerOnDemand(
        chunkReadSize: 4000,
        onDataAvailable: (Uint8List newList) {
          onPacketAvailable(newList, i, envelopConfig);
        },
      );
    }
  }

  @override
  Future<bool> initNotchFilters(FilterSetup filterBaseSettingsModel) async {
    bool checkInit = native_add.initNotchPassFilter(filterBaseSettingsModel);
    return checkInit;
  }

  @override
  Future<void> filterArrayElements(
      {required List<int> array,
      required int arrayLength,
      required int channelIdx}) async {
    _bufferHandlerOnDemand[channelIdx]
        ?.addBytes(Int16List.fromList(array).buffer.asUint8List());
    return;
  }

  @override
  Future<bool> initHighPassFilters(FilterSetup filterBaseSettingsModel) async {
    bool checkInit = native_add.initHighPassFilter(filterBaseSettingsModel);
    return checkInit;
  }

  @override
  Future<bool> initLowPassFilters(FilterSetup filterBaseSettingsModel) async {
    bool checkInit = native_add.initLowPassFilter(filterBaseSettingsModel);
    return checkInit;
  }

  @override
  Stream<Uint8List>? postFilterStream;

  @override
  StreamController<Uint8List> postFilterStreamController =
      StreamController<Uint8List>();

  /// When another packet is available for processing from buffer
  void onPacketAvailable(Uint8List array, int channelIndex,
      EnvelopConfigProvider envelopConfig) async {
    _bufferHandlerOnDemand[channelIndex]?.toFetchBytes = false;

    Int16List listToFilter = array.buffer.asInt16List();

    Uint8List? filterElement = await native_add.filterArrayElements(
        array: listToFilter,
        length: listToFilter.length,
        channelIndex: channelIndex,
        upComingSampleLength: envelopConfig.sampleLength,
        upComingSkipCount: envelopConfig.skipCount);

    // TODO: currently data of all channels being added to the same stream
    postFilterStreamController.add(filterElement);

    onProcessingDone(channelIndex);
  }

  /// Called from JS when processing completed on a packet
  void onProcessingDone(dynamic channelIdx) {
    _bufferHandlerOnDemand[channelIdx]?.toFetchBytes = true;
    _bufferHandlerOnDemand[channelIdx]?.requestData();
  }

  @override
  Future<void> resetPositioning() async {
    await native_add.positionSinceBeginningSet();
  }
}

----- END ./lib/models/local_plugins/local_plugins_android.dart -----

----- BEGIN ./lib/models/local_plugins/local_plugins_check.dart -----
import 'dart:async';
import 'dart:typed_data';
import 'package:native_add/model/model.dart';
import 'package:spikerbox_architecture/models/local_plugins/local_plugins.dart'
    if (dart.library.io) 'package:spikerbox_architecture/models/local_plugins/local_plugins_native.dart'
    if (dart.library.html) 'package:spikerbox_architecture/models/local_plugins/local_plugins_web.dart';

import '../../provider/enveloping_config_provider.dart';

abstract class LocalPlugin {
  factory LocalPlugin() => getLocalPlugins();

  final StreamController<Uint8List> postFilterStreamController =
      StreamController<Uint8List>();

  /// To be listened only after call [spawnHelperIsolate]
  Stream<Uint8List>? postFilterStream;

  /// Spawns helper Isolate on windows, macOS, android, iOS
  ///
  /// Spawns helper Web Worker on Web
  Future<void> spawnHelperIsolate(EnvelopConfigProvider envelopConfig) async {}

  /// Add packet to circular buffer for filtering
  ///
  /// [array] should be the list of Int16 on which filtering needs to be done
  ///
  /// [arrayLength] is the number of Int16 values in [array]
  Future<void> filterArrayElements(
      {required List<int> array,
      required int arrayLength,
      required int channelIdx}) async {
    return;
  }

  /// Initialise or modify high pass filter settings
  Future<bool> initHighPassFilters(FilterSetup filterBaseSettingsModel) async {
    return false;
  }

  /// Initialise or modify high pass filter settings
  Future<bool> initLowPassFilters(FilterSetup filterBaseSettingsModel) async {
    return false;
  }

  Future<bool> initNotchFilters(FilterSetup filterBaseSettingsModel) async {
    return false;
  }

  Future<void> resetPositioning() async {
    // await native_add.positionSinceBeginningSet();
  }
}

----- END ./lib/models/local_plugins/local_plugins_check.dart -----

----- BEGIN ./lib/models/local_plugins/local_plugins_native.dart -----
import 'dart:io';
import 'package:spikerbox_architecture/models/local_plugins/local_plugins_check.dart';
import 'local_plugins_window.dart';
import 'local_plugins_android.dart';

LocalPlugin getLocalPlugins() {
  if (Platform.isWindows) {
    return LocalPluginWindow();
  } else if (Platform.isAndroid) {
    return LocalPluginAndroid();
  }
  return LocalPluginAndroid();
}

----- END ./lib/models/local_plugins/local_plugins_native.dart -----

----- BEGIN ./lib/models/local_plugins/local_plugins_web.dart -----
import 'dart:async';
import 'dart:typed_data';
import 'package:native_add/model/model.dart';
import 'package:spikerbox_architecture/models/models.dart';
import 'package:spikerbox_architecture/provider/provider_export.dart';
import 'dart:js' as js;

import '../../provider/enveloping_config_provider.dart';

LocalPlugin getLocalPlugins() => LocalPluginWeb();

class LocalPluginWeb implements LocalPlugin {
  FilterSetup? _highPassFilterSetup;
  FilterSetup? _lowPassFilterSetup;
  FilterSetup? _notchFilterSetup;

  static final List<Int16List?> _dataBuffer =
      List.generate(channelCountBuffer, (index) => null);

  final List<BufferHandlerOnDemand?> _bufferHandlerOnDemand =
      List.generate(channelCountBuffer, (index) => null);

  /// Starts web worker
  ///
  /// Sets up buffer also
  @override
  Future<void> spawnHelperIsolate(EnvelopConfigProvider envelopConfig) async {
    postFilterStream = postFilterStreamController.stream.asBroadcastStream();
    for (int i = 0; i < channelCountBuffer; i++) {
      _bufferHandlerOnDemand[i] = BufferHandlerOnDemand(
        chunkReadSize: 4000,
        onDataAvailable: (Uint8List newList) {
          onPacketAvailable(newList, i, envelopConfig);
        },
      );
    }
    js.context.callMethod("initializeModule", []);
    js.context['onDataBufferAllocated'] = onDataBufferAllocated;
    js.context['onProcessingDone'] = onProcessingDone;
  }

  @override
  Future<void> filterArrayElements({
    required List<int> array,
    required int arrayLength,
    required int channelIdx,
  }) async {
    Int16List iList = Int16List.fromList(array);

    // Add data to circular buffer
    _bufferHandlerOnDemand[channelIdx]?.addBytes(iList.buffer.asUint8List());
    return;
  }

  @override
  Future<bool> initHighPassFilters(FilterSetup filterBaseSettingsModel) async {
    _highPassFilterSetup = filterBaseSettingsModel;

    js.context.callMethod("sendToWebInitHighPassFilter", [
      filterBaseSettingsModel.channelCount,
      filterBaseSettingsModel.filterConfiguration.sampleRate,
      filterBaseSettingsModel.filterConfiguration.cutOffFrequency,
      0.5
    ]);
    return true;
  }

  @override
  Future<bool> initLowPassFilters(FilterSetup filterBaseSettingsModel) async {
    _lowPassFilterSetup = filterBaseSettingsModel;

    js.context.callMethod("sendToWebInitLowPassFilter", [
      filterBaseSettingsModel.channelCount,
      filterBaseSettingsModel.filterConfiguration.sampleRate,
      filterBaseSettingsModel.filterConfiguration.cutOffFrequency,
      0.5
    ]);
    return true;
  }

  @override
  Future<bool> initNotchFilters(FilterSetup filterBaseSettingsModel) async {
    _notchFilterSetup = filterBaseSettingsModel;
    js.context.callMethod("sendToWebInitNotchFilter", [
      filterBaseSettingsModel.channelCount,
      filterBaseSettingsModel.filterConfiguration.sampleRate,
      filterBaseSettingsModel.filterConfiguration.cutOffFrequency,
      0.5
    ]);
    return true;
  }

  @override
  Stream<Uint8List>? postFilterStream;

  @override
  StreamController<Uint8List> postFilterStreamController =
      StreamController<Uint8List>();

  /// When another packet is available for processing from buffer
  void onPacketAvailable(
      Uint8List packet, int channelIndex, EnvelopConfigProvider envelopConfig) {
    _bufferHandlerOnDemand[channelIndex]?.toFetchBytes = false;

    Int16List listFromBuffer = packet.buffer.asInt16List();

    if (_dataBuffer[channelIndex]!.isEmpty) {
      _bufferHandlerOnDemand[channelIndex]?.toFetchBytes = true;
      _bufferHandlerOnDemand[channelIndex]?.requestData();
      return;
    }

    for (int i = 0; i < listFromBuffer.length; i++) {
      _dataBuffer[channelIndex]![i] = listFromBuffer[i];
    }

    bool toApplyHighPass = false;
    bool toApplyLowPass = false;
    bool toApplyNotch = false;
    if (_highPassFilterSetup != null) {
      if (_highPassFilterSetup!.isFilterOn) {
        toApplyHighPass = true;
      }
    }
    if (_lowPassFilterSetup != null) {
      if (_lowPassFilterSetup!.isFilterOn) {
        toApplyLowPass = true;
      }
    }
    if (_notchFilterSetup != null) {
      if (_notchFilterSetup!.isFilterOn) {
        toApplyNotch = true;
      }
    }
    js.context.callMethod("sendToWorkerApplyFilter", [
      channelIndex,
      listFromBuffer.length,
      toApplyHighPass,
      toApplyLowPass,
      toApplyNotch,
      envelopConfig.sampleLength,
      envelopConfig.skipCount,
    ]);
  }

  /// Called only once in the beginning to send address of buffer to dart
  void onDataBufferAllocated(Int16List dataBuffer, final channelIndex) {
    print("the length of int16 buffer ${dataBuffer.length}");
    _dataBuffer[channelIndex] = dataBuffer;
  }

  /// Called from JS when processing completed on a packet
  void onProcessingDone(int channelIdx) {
    Int16List returnList = Int16List(_dataBuffer[channelIdx]?.length ?? 0);
    for (int i = 0; i < returnList.length; i++) {
      returnList[i] = _dataBuffer[channelIdx]![i];
    }

    postFilterStreamController.add(returnList.buffer.asUint8List());

    _bufferHandlerOnDemand[channelIdx]?.toFetchBytes = true;
    _bufferHandlerOnDemand[channelIdx]?.requestData();
  }

  @override
  Future<void> resetPositioning() async {
    // await native_add.positionSinceBeginningSet();
  }
}

----- END ./lib/models/local_plugins/local_plugins_web.dart -----

----- BEGIN ./lib/models/local_plugins/local_plugins_window.dart -----
import 'dart:async';
import 'dart:typed_data';
import 'package:native_add/model/model.dart';
import 'package:native_add/native_add.dart' as native_add;
import 'package:spikerbox_architecture/models/models.dart';
import 'package:spikerbox_architecture/provider/provider_export.dart';

class LocalPluginWindow implements LocalPlugin {
  EnvelopConfigProvider envelopConfig = EnvelopConfigProvider();
  final List<BufferHandlerOnDemand?> _bufferHandlerOnDemand =
      List.filled(channelCountBuffer, null);

  @override
  Future<void> spawnHelperIsolate(EnvelopConfigProvider envelopConfig) async {
    postFilterStream = postFilterStreamController.stream.asBroadcastStream();

    await native_add.spawnHelperIsolate();
    for (int i = 0; i < channelCountBuffer; i++) {
      _bufferHandlerOnDemand[i] = BufferHandlerOnDemand(
        chunkReadSize: 4000,
        onDataAvailable: (Uint8List newList) {
          onPacketAvailable(newList, i, envelopConfig);
        },
      );
    }
  }

  @override
  Future<void> resetPositioning() async {
    await native_add.positionSinceBeginningSet();
  }

  @override
  Future<void> filterArrayElements(
      {required List<int> array,
      required int arrayLength,
      required int channelIdx}) async {
    Int16List iList = Int16List.fromList(array);

    _bufferHandlerOnDemand[channelIdx]?.addBytes(iList.buffer.asUint8List());
    return;
  }

  @override
  Future<bool> initHighPassFilters(FilterSetup filterBaseSettingsModel) async {
    bool checkInit = native_add.initHighPassFilter(filterBaseSettingsModel);
    return checkInit;
  }

  @override
  Future<bool> initNotchFilters(FilterSetup filterBaseSettingsModel) async {
    // native_add.SetUpNotchFilter();
    bool checkInit = native_add.initNotchPassFilter(filterBaseSettingsModel);

    return checkInit;
  }

  @override
  Future<bool> initLowPassFilters(FilterSetup filterBaseSettingsModel) async {
    bool checkInit = native_add.initLowPassFilter(filterBaseSettingsModel);
    return checkInit;
  }

  @override
  Stream<Uint8List>? postFilterStream;

  @override
  StreamController<Uint8List> postFilterStreamController =
      StreamController<Uint8List>();

  /// When another packet is available for processing from buffer
  void onPacketAvailable(Uint8List array, int channelIndex,
      EnvelopConfigProvider envelopConfig) async {
    _bufferHandlerOnDemand[channelIndex]?.toFetchBytes = false;

    Int16List listToFilter = array.buffer.asInt16List();

    Uint8List? filterElement = await native_add.filterArrayElements(
        array: listToFilter,
        length: listToFilter.length,
        channelIndex: channelIndex,
        upComingSampleLength: envelopConfig.sampleLength,
        upComingSkipCount: envelopConfig.skipCount);

    // print("The filter element is ${filterElement.length}");
    // TODO: currently data of all channels being added to the same stream
    postFilterStreamController.add(filterElement);

    onProcessingDone(channelIndex);
  }

  /// Called from JS when processing completed on a packet
  void onProcessingDone(dynamic channelIdx) {
    _bufferHandlerOnDemand[channelIdx]?.toFetchBytes = true;
    _bufferHandlerOnDemand[channelIdx]?.requestData();
  }
}

----- END ./lib/models/local_plugins/local_plugins_window.dart -----

----- BEGIN ./lib/models/microphone_stream/microphone_stream.dart -----
import "microphone_stream_check.dart";

MicrophoneUtil getMicrophoneStreams() =>
    throw UnimplementedError('PlatForm is not Implemented');

----- END ./lib/models/microphone_stream/microphone_stream.dart -----

----- BEGIN ./lib/models/microphone_stream/microphone_stream_android.dart -----
import 'dart:async';
import 'dart:io';
import 'dart:typed_data';
import 'package:sound_stream_now/sound_stream_now.dart';
import 'package:permission_handler/permission_handler.dart';

import 'package:native_add/model/sending_data.dart';
import 'package:spikerbox_architecture/models/models.dart';
import 'microphone_stream_check.dart';

class MicrophoneUtilAndroid implements MicrophoneUtil {
  // late ffi.Pointer<ffi.Pointer<ffi.Float>> audioData;
  @override
  StreamController<Uint8List> addListenAudioStreamController =
      StreamController();

  @override
  int sampleRateFromWeb = 0;

  @override
  Stream<Uint8List>? micStream;

  @override
  Stream<PacketAddDetailModel>? packetAddDetail;

  @override
  StreamController<PacketAddDetailModel> addPacketDetailCalculate =
      StreamController();
  @override
  void resetTheClass() {
    // native_MicListen.resetClassInstance();
  }

  List<double>? waveSamples;
  List<double>? intensitySamples;
  Stream<Uint8List>? stream;
  int _counter = 0;
  int totalTimeAudio = 0;
  int maxTimeAudio = 0;
  int minTimeAudio = int.parse('9223372036854775807');
  int avgTimeAudio = 0;
  Stopwatch stopwatch = Stopwatch();
  late StreamSubscription<Uint8List>? listen;

  final RecorderStream _recorder = RecorderStream();
  // PlayerStream _player = PlayerStream();
  late StreamSubscription _recorderStatus;

  @override
  Future<void> init() async {
    await requestMicrophonePermission();

    // _recorderStatus = _recorder.status.listen((status) {
    //   status == SoundStreamStatus.Playing;
    // });
    packetAddDetail = addPacketDetailCalculate.stream.asBroadcastStream();

    micStream = addListenAudioStreamController.stream.asBroadcastStream();
    stopwatch.start();
    _recorder.audioStream.listen((data) {
      int elapsedTime = stopwatch.elapsedMilliseconds;
      addElapsedTime(elapsedTime);
      stopwatch.reset();
      PacketAddDetailModel packetAddDetailModel = PacketAddDetailModel(
          averageTime: avgTimeAudio,
          maxTime: maxTimeAudio,
          minTime: minTimeAudio);
      addPacketDetailCalculate.add(packetAddDetailModel);

      addListenAudioStreamController.add(data);
    });

    await Future.wait([
      _recorder.initialize(showLogs: true, sampleRate: androidMicSampleRate),
    ]);
    _recorder.audioStream.asBroadcastStream();

    await _recorder.start();
  }

  Future<void> requestMicrophonePermission() async {
    if (!Platform.isAndroid && !Platform.isIOS) return;
    PermissionStatus status = await Permission.microphone.request();

    if (status.isGranted) {
      // Microphone permission granted
    } else if (status.isDenied) {
      // Microphone permission denied
    } else if (status.isPermanentlyDenied) {
      // The user opted to never again see the permission request dialog for this
      // app. The only way to change the permission's status now is to let the
      // user manually enable it in the system settings.
      openAppSettings();
    }
  }

  void setMaxTime(int latestTime) {
    if (maxTimeAudio < latestTime) {
      maxTimeAudio = latestTime;
    }
  }

  int setMinTime(int latestTime) {
    if (latestTime < minTimeAudio) {
      minTimeAudio = latestTime;
    }
    return minTimeAudio;
  }

  void averageCalculateTime(int latestTime) {
    _counter++;
    totalTimeAudio += latestTime;
    avgTimeAudio = (totalTimeAudio ~/ _counter);
  }

  void addElapsedTime(int latestTime) {
    setMaxTime(latestTime);
    setMinTime(latestTime);
    averageCalculateTime(latestTime);
  }

  Future<void> checkPointerValue() async {}
}

----- END ./lib/models/microphone_stream/microphone_stream_android.dart -----

----- BEGIN ./lib/models/microphone_stream/microphone_stream_check.dart -----
import 'dart:async';
import 'dart:typed_data';

import 'package:native_add/model/model.dart';
import 'package:spikerbox_architecture/models/microphone_stream/microphone_stream.dart'
    if (dart.library.io) 'package:spikerbox_architecture/models/microphone_stream/microphone_stream_native.dart'
    if (dart.library.html) 'package:spikerbox_architecture/models/microphone_stream/microphone_stream_web.dart';

abstract class MicrophoneUtil {
  factory MicrophoneUtil() => getMicrophoneStreams();

  final StreamController<Uint8List> addListenAudioStreamController =
      StreamController();
  Stream<Uint8List>? micStream;
  int sampleRateFromWeb = 0;

  final StreamController<PacketAddDetailModel> addPacketDetailCalculate =
      StreamController();

  void resetTheClass() {
    // native_MicListen.resetClassInstance();
  }
  Stream<PacketAddDetailModel>? packetAddDetail;

  Future<void> init() async {}

  Future<void> checkPointerValue() async {}
}

----- END ./lib/models/microphone_stream/microphone_stream_check.dart -----

----- BEGIN ./lib/models/microphone_stream/microphone_stream_native.dart -----
import 'dart:io';
import 'package:spikerbox_architecture/models/microphone_stream/microphone_stream_android.dart';
import 'microphone_stream_check.dart';
import 'package:spikerbox_architecture/models/microphone_stream/microphone_stream_window.dart';

MicrophoneUtil getMicrophoneStreams() {
  if (Platform.isAndroid || Platform.isIOS) {
    return MicrophoneUtilAndroid();
  } else if (Platform.isMacOS || Platform.isWindows) {
    return MicrophoneUtilWindow();
  }
  return MicrophoneUtilWindow();
}

----- END ./lib/models/microphone_stream/microphone_stream_native.dart -----

----- BEGIN ./lib/models/microphone_stream/microphone_stream_web.dart -----
import 'dart:async';
import 'dart:typed_data';
import 'microphone_stream_check.dart';
import 'dart:js' as js;

import 'package:native_add/model/model.dart';

MicrophoneUtil getMicrophoneStreams() => MicrophoneUtilWeb();

class MicrophoneUtilWeb implements MicrophoneUtil {
  Int16List? _micDataBuffer;
  int sampleRateFromWeb = 0;

  @override
  StreamController<Uint8List> addListenAudioStreamController =
      StreamController();

  @override
  Stream<PacketAddDetailModel>? packetAddDetail;

  @override
  StreamController<PacketAddDetailModel> addPacketDetailCalculate =
      StreamController();

  @override
  Stream<Uint8List>? micStream;

  @override
  Future<void> init() async {
    packetAddDetail = addPacketDetailCalculate.stream.asBroadcastStream();
    micStream = addListenAudioStreamController.stream.asBroadcastStream();
    js.context['onDataBufferAllocated'] = onDataBufferAllocated;
    js.context['onDataReceived'] = onDataReceived;
    js.context['getSampleRate'] = getSampleRate;
    Future.delayed(const Duration(seconds: 1), () {
      js.context.callMethod('startListeningToMicrophone', []);
    });
  }

  @override
  void resetTheClass() {
    // native_MicListen.resetClassInstance();
  }

  void getSampleRate(int sampleRate) {
    sampleRateFromWeb = sampleRate;
    print("the sample rate from the web $sampleRate");
  }

  /// Called only once in the beginning to send address of buffer to dart
  void onDataBufferAllocated(Int16List dataBuffer) {
    _micDataBuffer = dataBuffer;
  }

  void onDataReceived() {
    if (_micDataBuffer == null) {
      return;
    }

    // Convert Int16List to Uint8List

    // Add Uint8List to the stream
    Uint8List uList = Uint8List.fromList(_micDataBuffer!.buffer.asUint8List());
    addListenAudioStreamController.add(uList);
  }

  @override
  Future<void> checkPointerValue() async {}
}

----- END ./lib/models/microphone_stream/microphone_stream_web.dart -----

----- BEGIN ./lib/models/microphone_stream/microphone_stream_window.dart -----
import 'dart:async';
import 'dart:typed_data';
import 'package:native_add/model/model.dart';

import 'microphone_stream_check.dart';
// ignore: library_prefixes

import 'package:native_add/mic_listening_isolate.dart' as native_MicListen;

class MicrophoneUtilWindow implements MicrophoneUtil {
  @override
  Stream<Uint8List>? micStream;

  @override
  int sampleRateFromWeb = 0;

  @override
  Stream<PacketAddDetailModel>? packetAddDetail;

  @override
  StreamController<PacketAddDetailModel> addPacketDetailCalculate =
      StreamController();

  @override
  StreamController<Uint8List> addListenAudioStreamController =
      StreamController();

  // List<int> intList = List<int>.generate(2000, (index) => index);
  Int16List? data;
  @override
  void resetTheClass() {
    native_MicListen.resetClassInstance();
  }

  @override
  Future<void> init() async {
    packetAddDetail = addPacketDetailCalculate.stream.asBroadcastStream();
    micStream = addListenAudioStreamController.stream.asBroadcastStream();
    // await native_add.setTheMicData();
    // await native_add.listenMic(_bufferData);
    await native_MicListen.mainIsolateForMic(
        addListenAudioStreamController, addPacketDetailCalculate);
    await native_MicListen.listenMicOfAudio();
  }

  @override
  Future<void> checkPointerValue() async {
    // Int16List _bufferData = Int16List.fromList(intList);
    // final valueis = await native_add.setTheMicData(_bufferData);
    // print("the value is getted $valueis");
  }
}

----- END ./lib/models/microphone_stream/microphone_stream_window.dart -----

----- BEGIN ./lib/models/models.dart -----
export 'constant.dart';
export 'timing_util.dart';
export 'usb_protocol/usb_protocol.dart';
export 'int_extensions.dart';
export 'debugging.dart';
export 'circular_buffer.dart';
export 'generating_sample_data.dart';
export 'usb_protocol/commands.dart';
export 'local_plugins/local_plugins_check.dart';
export 'serial_util/serial_util_check.dart';
export 'package:spikerbox_architecture/functionality/functionality.dart';
export 'default_config_model.dart';
export 'serialport_data_model.dart';
export 'frame_detect.dart';
export 'bit_wise_util.dart';
export 'data_pattern_util.dart';
export 'sample_buffer.dart';
export 'enum/notch_check_filter.dart';
export 'device_com_listen.dart';
export 'audio_detail_model.dart';
export 'global_buffer.dart';

----- END ./lib/models/models.dart -----

----- BEGIN ./lib/models/notch_filter_model.dart -----
class NotchSetFrequencySetting {
  NotchSetFrequencyEnum setFrequency;
  bool isNotchFrequency;

  NotchSetFrequencySetting(
      {required this.isNotchFrequency, required this.setFrequency});
}

enum NotchSetFrequencyEnum { fiftyHertz, sixtyHertz }

----- END ./lib/models/notch_filter_model.dart -----

----- BEGIN ./lib/models/sample_buffer.dart -----
import 'dart:math';

// typedef outside the class
typedef int16_t = int;

class SampleBuffer {
  static const int NUMBER_OF_SEGMENTS = 120;
  static const int SEGMENT_SIZE = 44100;

  static const int SIZE = NUMBER_OF_SEGMENTS * SEGMENT_SIZE;
  static const int SIZE_LOG2 = 21;

  int _pos;
  int _head;
  List<int> _buffer;
  late List<List<Point<int>>> _envelopes;
  bool _notEmpty;
  List<int> segmentsState = List<int>.filled(NUMBER_OF_SEGMENTS, 0);

  SampleBuffer({int pos = 0})
      : _pos = pos,
        _head = 0,
        _buffer = List<int>.filled(SIZE, 0),
        _notEmpty = false {
    _envelopes = List.generate(
      SIZE_LOG2,
      (i) => List<Point<int>>.generate(
        SIZE ~/ pow(2, i + 1) + 1,
        (j) => Point<int>(0, 0),
      ),
    );
  }

  SampleBuffer copy() {
    SampleBuffer copy = SampleBuffer();
    copy._pos = _pos;
    copy._head = _head;
    copy._buffer = List<int>.from(_buffer);
    copy.segmentsState = List<int>.from(segmentsState);
    copy._envelopes = List.generate(
      SIZE_LOG2,
      (i) => List<Point<int>>.from(_envelopes[i]),
    );
    copy._notEmpty = _notEmpty;
    return copy;
  }

  void addData(List<int> src, int len) {
    if (len > 0) _notEmpty = true;
    for (int i = 0; i < len; i++) {
      for (int j = 1; j <= SIZE_LOG2; j++) {
        final skipCount = pow(2, j);
        final envelopeIndex = j - 1;
        final envelopeSampleIndex = _head ~/ skipCount;

        if (envelopeSampleIndex >= _envelopes[envelopeIndex].length) {
          continue;
        }

        var dst = _envelopes[envelopeIndex][envelopeSampleIndex];
        if (_head % skipCount == 0) {
          dst = Point(src[0], src[0]);
        } else {
          dst = Point(min(dst.x, src[0]), max(dst.y, src[0]));
        }
      }

      _buffer[_head++] = src[0];
      if (_head == SIZE) _head = 0;
      src.removeAt(0);
    }
    _pos += len;
  }

  void simpleAddData(List<int> src, int len, int stride) {
    if (len > 0) _notEmpty = true;
    for (int i = 0; i < len; i++) {
      _buffer[_head++] = src[0];
      src.removeAt(0);
      if (_head == SIZE) _head = 0;
    }
    _pos += len;
  }

  void getData(List<int> dst, int offset, int len, int skip) {
    final lllleft = offset - _pos;
    final rrrright = offset - _pos + len;
    int j = 0;
    for (int i = lllleft; i < rrrright; j++) {
      if (i < -SIZE || i >= _pos) {
        dst[j] = 0;
      } else if (i >= 0) {
        dst[j] = _buffer[(_head + -1 + SIZE) % SIZE];
      } else {
        dst[j] = _buffer[(_head + i + SIZE) % SIZE];
      }
      i += skip;
    }
  }

  List<int> getDataWithoutDst(int offset, int len, int skip) {
    final result = List<int>.filled(len ~/ skip, 0);
    getData(result, offset, len, skip);
    return result;
  }

  int at(int pos) {
    if (pos <= _pos - SIZE || pos >= _pos) return 0;
    return _buffer[(_head + pos - _pos + SIZE) % SIZE];
  }

  int pos() => _pos;

  void setPos(int pos) {
    _pos = pos;
  }

  int head() => _head;

  void setHead(int head) {
    _head = head % SIZE;
  }

  void reset() {
    _pos = 0;
    _head = 0;
    segmentsState.fillRange(0, NUMBER_OF_SEGMENTS, 0);
    if (_notEmpty) {
      _notEmpty = false;
      _buffer.fillRange(0, SIZE, 0);

      for (int i = 0, size = SIZE ~/ 2; i < SIZE_LOG2; i++, size ~/= 2) {
        _envelopes[i] = List<Point<int>>.filled(size + 1, Point<int>(0, 0));
      }
    }
  }

  bool empty() => !_notEmpty;
}

----- END ./lib/models/sample_buffer.dart -----

----- BEGIN ./lib/models/serial_util/serial_testing.dart -----
import 'dart:async';
// ignore: avoid_web_libraries_in_flutter
import 'dart:html';
import 'package:flutter/services.dart';
import 'package:serial/serial.dart';

class SerialUtilWebCheck {
  SerialPort? _port;
  SerialPortInfo? portInfo;

  Future<void> openPortToListen(String name) async {
    _port = await window.navigator.serial.requestPort();
    try {
      await _port?.open(baudRate: 500000, bufferSize: 8192);
    } catch (e) {
      print("Port opening failed: $e");
    }
    portInfo = _port?.getInfo();
    readFromPort();
  }

  Future<void> writeToPort(
      {required Uint8List bytesMesage, required String address}) async {
    if (_port == null) {
      return;
    }

    final writer = _port!.writable.writer;

    await writer.ready;
    await writer.write(bytesMesage);
    await writer.ready;
  }
  Future<void> readFromPort() async {
    if (_port == null) {
      return;
    }
    try {
      final reader = _port!.readable.reader;

      while (true) {
//  if(isListen){

        final ReadableStreamDefaultReadResult result = await reader.read();
        String message = String.fromCharCodes(result.value);

        //  if(message.contains(":")&& message.contains(";")){

        print(
            "the upcoming print is event ${result.value}, as String: $message");

        //  }
        // timingUtil.addPacket(result.value);
        // int dReceived = timingUtil.getTotalBytesReceived();

        // if (timingUtil.stopwatch.elapsedMilliseconds >= (100)) {
        // if (dReceived >= 128 && dReceived % 2 == 0) {
        //   //   if ((timingUtil.getTotalBytesReceived() % 2) == 0) {
        //   // TODO: implement sending of data to web worker
        //   //     Uint8List responseOnSend = await isolateManagerInWeb.isolateManager
        //   //         .sendMessage(timingUtil.getAllData());

        //   // print('Response on sending to isolate: $responseOnSend');
        //   // if (toListenStream) {
        //   //   // _streamControllerGraph.add(timingUtil.getAllData());
        //   // }
        //   timingUtil.printStatistics();
        //   // try {
        //   //   for (int i = 0; i < timingUtil.packets.length; i++) {
        //   //     if (i < 10 || i > (timingUtil.packets.length - 10)) {
        //   //       print("$i : ${timingUtil.packets[i].buffer.asUint16List().first} - ${timingUtil.packets[i].buffer.asUint16List().last}");
        //   //     }
        //   //   }
        //   // } catch (e) {
        //   //   print("Reading buffer values failed.");
        //   // }
        //   timingUtil.reset();
        //   }
      }

      //  else {
      //  await Future.delayed(const Duration(milliseconds:500));
      //  }
      // }
    } catch (e) {
      print("Reading port failed with exception: \n$e");
    }
  }
}

----- END ./lib/models/serial_util/serial_testing.dart -----

----- BEGIN ./lib/models/serial_util/serial_util.dart -----
import 'serial_util_check.dart';


SerialUtil getSerialUtil() => throw UnimplementedError('getWorker');





----- END ./lib/models/serial_util/serial_util.dart -----

----- BEGIN ./lib/models/serial_util/serial_util_android.dart -----
import 'dart:async';
import 'package:flutter/services.dart';
import 'package:spikerbox_architecture/models/serial_util/serial_util_check.dart';
import 'package:usb_serial/usb_serial.dart';
import 'package:usb_serial/transaction.dart';

import '../../functionality/functionality_export.dart';
import '../../provider/provider_export.dart';
import '../default_config_model.dart';

// import 'package:serial_communication/serial_communication.dart';

class SerialUtilAndroid implements SerialUtil {
  UsbPort? _port;
  UsbDevice? _device;
  StreamSubscription<String>? _subscription;
  Transaction<String>? _transaction;
  List<UsbDevice> devices = [];
  int _baudRate = 0;

  @override
  Future<void> connectToPort() async {
    await _connectTo(devices.first);
  }

  @override
  void writeToPort({required Uint8List bytesMessage, String? address}) async {
    try {
      await _port!.write(Uint8List.fromList(bytesMessage));
    } catch (err, _) {
      _port!.close();
    }
  }

  @override
  Stream<Uint8List>? dataStream;

  @override
  List<String> availablePorts = [];

  @override
  Future<List<String>> startPortCheck(int baudRate) async {
    devices = await UsbSerial.listDevices();

    if (!devices.contains(_device)) {
      await _connectTo(null);
    }
    availablePorts = devices.map((e) {
      return e.deviceName;
    }).toList();

    return availablePorts;
  }

  /// Pass the device name to this function
  @override
  Future<Stream<Uint8List>?> openPortToListen(
      String? name, int baudRate) async {
    for (var element in devices) {
      if (element.deviceName == name) {
        _baudRate = baudRate;

        await connectToPort();
        break;
      }
    }
    if (_port == null) {
      return null;
    } else {
      return _port!.inputStream;
    }
  }

  @override
  Future<void> getAvailablePorts(int baudRate) async {
    availablePorts =
        await startPortCheck(_baudRate); // Adjust baudRate as needed
  }

  @override
  void setConfig() {
    // TODO: implement setConfig
  }

  @override
  void streamListen({required Stream<Uint8List>? getData}) {
    // TODO: implement streamListen
  }

  Future<bool> _connectTo(device) async {
    if (_subscription != null) {
      _subscription!.cancel();
      _subscription = null;
    }

    if (_transaction != null) {
      _transaction!.dispose();
      _transaction = null;
    }

    if (_port != null) {
      _port!.close();
      _port = null;
    }

    if (device == null) {
      _device = null;

      return true;
    }

    _port = await device.create();

    if (await (_port!.open()) != true) {
      return false;
    }
    _device = device;

    await _port!.setDTR(true);
    await _port!.setRTS(true);
    print("the baudRate is $_baudRate");
    await _port!.setPortParameters(
        _baudRate, UsbPort.DATABITS_8, UsbPort.STOPBITS_1, UsbPort.PARITY_NONE);

    // _transaction = Transaction.stringTerminated(_port!.inputStream as Stream<Uint8List>, Uint8List.fromList([13, 10]));
    // _transaction!.stream.listen((line){ });

    return true;
  }

  @override
  Future<void> deviceConnectWithPort(SampleRateProvider sampleRateProvider,
      ConstantProvider constantProvider) async {
    devices = await UsbSerial.listDevices();
    print("the devices is ${devices.first.productName}");

    Config deviceConfig = await SetUpFunctionality().getAllDeviceList();
    List<Board> allBoards = deviceConfig.boards ?? [];
    if (devices.last.productName == "Human Human Interface") {
      Board matchingBoards = allBoards.firstWhere((board) {
        return board.userFriendlyFullName == devices.first.productName;
      });

      sampleRateProvider
          .setSampleRate(int.parse(matchingBoards.maxSampleRate.toString()));
      constantProvider.setBaudRate(500000);
    } else {
      constantProvider.setBaudRate(222222);
    }
  }
}

----- END ./lib/models/serial_util/serial_util_android.dart -----

----- BEGIN ./lib/models/serial_util/serial_util_check.dart -----
import 'dart:typed_data';
import 'package:spikerbox_architecture/models/serial_util/serial_util.dart'
    if (dart.library.io) 'package:spikerbox_architecture/models/serial_util/serial_util_native.dart'
    if (dart.library.html) 'package:spikerbox_architecture/models/serial_util/serial_util_web.dart';

import '../../provider/provider_export.dart';

abstract class SerialUtil {
  factory SerialUtil() => getSerialUtil();

  Future<void> getAvailablePorts(int baudRate) async => [];

  void writeToPort({required Uint8List bytesMessage, String? address}) async {}

  void connectToPort() {}

  void setConfig() {}

  Future<Stream<Uint8List>?> openPortToListen(
      String? portName, int baudRate) async {
    return null;
  }

  List<String> availablePorts = [];

  Future<List<String>> startPortCheck(int baudRate) async {
    List<String> availablePorts = [];
    return availablePorts;
  }

  Stream<Uint8List>? dataStream;

  void streamListen({required Stream<Uint8List>? getData}) {}

  Future<void> deviceConnectWithPort(SampleRateProvider sampleRateProvider,
      ConstantProvider constantProvider) async {}
}

----- END ./lib/models/serial_util/serial_util_check.dart -----

----- BEGIN ./lib/models/serial_util/serial_util_native.dart -----
import 'dart:io';

import 'package:spikerbox_architecture/models/serial_util/serial_util_android.dart';
import 'package:spikerbox_architecture/models/serial_util/serial_util_window.dart';
import 'serial_util_check.dart';

SerialUtil getSerialUtil() {
  if(Platform.isWindows || Platform.isMacOS) {
    return SerialUtilWindow();
  } else if (Platform.isAndroid) {
    return SerialUtilAndroid();
  }
  return SerialUtilAndroid();
}

----- END ./lib/models/serial_util/serial_util_native.dart -----

----- BEGIN ./lib/models/serial_util/serial_util_web.dart -----
import 'dart:async';
import 'dart:html';
import 'package:flutter/services.dart';
import 'package:serial/serial.dart';
import 'package:spikerbox_architecture/models/debugging.dart';
import '../../provider/provider_export.dart';
import 'serial_util_check.dart';

SerialUtil getSerialUtil() => SerialUtilWeb();

class SerialUtilWeb implements SerialUtil {
  SerialPort? _port;
  SerialPortInfo? portInfo;

  StreamController<Uint8List> streamController = StreamController();
  @override
  Stream<Uint8List>? dataStream;

  WritableStreamDefaultWriter? writer;
  bool isPortOpen = false;
  int _baudRate = 500000;
  ReadableStreamReader? reader;
  bool isListenPort = false;
  ReadableStream? readable;
  bool isSetBaudRate = false;

  @override
  Future<void> connectToPort() async {
    final port1 = await window.navigator.serial.requestPort();

    try {
      await port1.open(
        baudRate: _baudRate,
      );

      isPortOpen = true;
    } catch (e) {
      print("Port opening failed: $e");
    }
    portInfo = port1.getInfo();
    int? pid = portInfo?.usbProductId;
    await setBaudRate(pid);

    await port1.close();
    _port = await window.navigator.serial.requestPort();

    try {
      await _port?.open(
        baudRate: _baudRate,
        dataBits: DataBits.eight,
        stopBits: StopBits.one,
        bufferSize: 255,
        flowControl: FlowControl.hardware,
      );
      isSetBaudRate = true;

      // isPortOpen = true;
    } catch (e) {
      print("Port opening failed: $e");
    }

    if (isSetBaudRate) {
      portInfo = _port?.getInfo();
      openPortToListen(" ", _baudRate);
    }
  }

  @override
  void writeToPort({required Uint8List bytesMessage, String? address}) async {
    if (_port == null) {
      return;
    }

    writer ??= _port!.writable.writer;

    await writer!.ready;
    await writer!.write(bytesMessage);
    await writer!.ready;
    await writer!.close();
    Debugging.printing("message sent : ${String.fromCharCodes(bytesMessage)}");
  }

  final startTime = DateTime.now();

  @override
  List<String> availablePorts = [];

  @override
  Future<List<String>> startPortCheck(int baudRate) async {
    List<String> availablePorts = [];
    return availablePorts;
  }

  @override
  Future<Stream<Uint8List>?> openPortToListen(
      String? name, int baudRate) async {
    _baudRate = baudRate;
    if (_port == null) {
      return null;
    }

    try {
      readable = _port!.readable;

      reader = readable?.reader;
      if (streamController.stream.isBroadcast) {
        streamController.close();
        dataStream = streamController.stream.asBroadcastStream();
      } else {
        dataStream = streamController.stream.asBroadcastStream();
      }
      isListenPort = true;

      while (isListenPort) {
        ReadableStreamDefaultReadResult result = await reader!.read();

        final currentTime = DateTime.now();
        currentTime.difference(startTime);
        if (result.value.isNotEmpty) {
          streamController.add(result.value.buffer.asUint8List());
        }
      }
    } catch (e) {
      print("Reading port failed with exception: \n$e");
      return null;
    }
    return null;
  }

  /// Connection is directly established with the selected port
  @override
  Future<void> getAvailablePorts(int baudRate) async {
    _baudRate = baudRate;
    await connectToPort();

    availablePorts = [_port!.getInfo().usbProductId!.toString()];
  }

  @override
  void setConfig() {
    // TODO: implement setConfig
  }

  @override
  void streamListen({required Stream<Uint8List>? getData}) {
    // TODO: implement streamListen
  }

  Future<void> closePort() async {
    try {
      // Release the reader lock first
      isListenPort = false;
      if (reader != null) {
        print("the port is Listen $isListenPort");
        reader?.releaseLock();
        readable?.close();
      }

      // Close the serial port
      if (_port != null) {
        await _port!.close();
      }

      _port = null; // Reset the port reference
    } catch (e) {
      print("Error closing port: $e");
    }
  }

  @override
  Future<void> deviceConnectWithPort(SampleRateProvider sampleRateProvider,
      ConstantProvider constantProvider) async {
    int? productId = portInfo!.usbProductId;

    print("the manufacture is $productId");
  }

  Future<void> setBaudRate(int? pid) async {
    if (pid == 24597) {
      print("the manufacture is $pid");
      _baudRate = 500000;
    } else {
      _baudRate = 222222;
    }
  }
}

----- END ./lib/models/serial_util/serial_util_web.dart -----

----- BEGIN ./lib/models/serial_util/serial_util_window.dart -----
// ignore_for_file: empty_catches

import 'dart:async';
import 'dart:typed_data';
import 'package:flutter_libserialport/flutter_libserialport.dart';
import 'package:spikerbox_architecture/provider/provider_export.dart';
import '../../functionality/functionality_export.dart';
import '../default_config_model.dart';
import 'serial_util_check.dart';

class SerialUtilWindow implements SerialUtil {
  SerialPort? port;
  int _baudRate = 0;

  @override
  List<String> availablePorts = [];

  @override
  Stream<Uint8List>? dataStream;

  @override
  Future<List<String>> startPortCheck(int baudRate) async {
    availablePorts = SerialPort.availablePorts;

    return availablePorts;
  }

  // get the list of current ports
  @override
  Future<void> getAvailablePorts(int baudRate) async {
    availablePorts = await startPortCheck(9600); // Adjust baudRate as needed

    // Wait for 3 seconds before the next check
  }

  @override
  void writeToPort({required Uint8List bytesMessage, String? address}) {
    if (port?.name == address) {
      try {
        final intsize = port?.write(bytesMessage);
        print("command is sent. Length: $intsize, cmd: ${intsize}");
      } catch (err, _) {
        port!.close();
      }
    }
  }

  @override
  void setConfig() {
    SerialPortConfig config = SerialPortConfig();
    config.baudRate = _baudRate;
    config.bits = 8;
    config.stopBits = 1;
    port!.config = config;
  }

  bool _openPort() {
    bool isOpen = false;
    if (!port!.isOpen) {
      isOpen = port!.openReadWrite();
    }
    setConfig();
    return isOpen;
  }

  @override
  void connectToPort() {}

  @override
  Future<Stream<Uint8List>?> openPortToListen(
      String? portName, int baudRate) async {
    _baudRate = baudRate;
    port?.close();
    // checkEscapeSequence();
    if (portName == null) return null;
    port = SerialPort(portName);

    if (port?.name == portName) {
      if (!port!.isOpen) !_openPort();
      SerialPortReader reader = SerialPortReader(port!);
      return reader.stream.asBroadcastStream();
    }
    return null;
  }

  @override
  void streamListen({required Stream<Uint8List>? getData}) {
    try {
      getData?.listen((event) {
        String message = String.fromCharCodes(event);

        // print("serial received value: $event, as String: $message");
        //         escapdeinstance.addPacket(Uint8List.fromList(message.codeUnits));
        //         escapdeinstance.addPacket(Uint8List.fromList(message.codeUnits));
        //         if(message.contains(":")&&message.contains(";")){
        // print("the upcoming print is event ${event}, as String: $message");
        //         }
        // escapdeinstance.addPacket(Uint8List.fromList(message.codeUnits));
        // BitwiseUtil().readBytes(Uint8List.fromList([44,255,55,69]), 10);
        if (message.contains(":") && message.contains(";")) {}
      });
    } catch (e) {}
  }

  @override
  Future<void> deviceConnectWithPort(SampleRateProvider sampleRateProvider,
      ConstantProvider constantProvider) async {
    port = SerialPort(availablePorts.last);

    Config deviceConfig = await SetUpFunctionality().getAllDeviceList();
    List<Board> allBoards = deviceConfig.boards ?? [];
    if (port?.productName == "Human Human Interface") {
      Board matchingBoards = allBoards.firstWhere((board) {
        return board.userFriendlyFullName == port?.productName;
      });

      sampleRateProvider
          .setSampleRate(int.parse(matchingBoards.maxSampleRate.toString()));
      constantProvider.setBaudRate(500000);
    } else if (port?.productId == 29597) {
    } else {
      constantProvider.setBaudRate(222222);
    }

    // port!.name;
    // final devices = SerialPort.fromAddress(port!.address);
    // devices.name;

    // print(
    //     "the macAddress ${devices.macAddress}, busNumber ${devices.busNumber}, vendorid ${devices.vendorId},serial number ${devices.serialNumber}, address ${devices.address} ComName ${devices.name}, manufacture ${devices.manufacturer} and product name ${devices.productName}");
    // devices.productName;
  }
}

----- END ./lib/models/serial_util/serial_util_window.dart -----

----- BEGIN ./lib/models/serialport_data_model.dart -----
import 'models.dart';

class SerialPortDataModel {
  final String portCom;
  final String deviceDetect;

  SerialPortDataModel({required this.portCom, required this.deviceDetect});
  SerialPortDataModel copyWith({String? portCom, String? deviceDetect}) {
    return SerialPortDataModel(
      portCom: portCom ?? this.portCom,
      deviceDetect: deviceDetect ?? this.deviceDetect,
    );
  }
}

class ComDataWithBoard {
  final SerialPortDataModel serialPortData;
  final Board connectDevices;

  ComDataWithBoard(
      {required this.connectDevices, required this.serialPortData});
}

----- END ./lib/models/serialport_data_model.dart -----

----- BEGIN ./lib/models/timing_util.dart -----
import 'dart:typed_data';

class TimingUtil {
  List<Uint8List> packets = [];
  Stopwatch stopwatch = Stopwatch();
  int totalTimeElapsed = 0;
  Uint8List carryForward = Uint8List(0);

  Uint8List getAllData() {
    Uint8List combinedData = packets.fold(
        carryForward,
        (previousList, currentList) =>
            Uint8List.fromList([...previousList, ...currentList]));
    // if (carryForward.isNotEmpty) carryForward = Uint8List(0);
    // int combinedLength = combinedData.length;
    // if (combinedLength % 2 != 0) {
    //   carryForward = Uint8List.fromList([combinedData.last]);
    //   print("combined data length : $combinedLength, carryForward length: ${carryForward.length}");
    //   return combinedData.sublist(0, combinedLength - 1);
    // }
    // print("combined data length : $combinedLength, carryForward length: ${carryForward.length}");
    return combinedData;
  }

  void addPacket(Uint8List packet) {
    if (!stopwatch.isRunning) {
      stopwatch.start();
    }
    packets.add(packet);
  }

  int getTotalPacketsReceived() {
    return packets.length;
  }

  int getTotalBytesReceived() {
    int totalBytes = 0;
    for (var packet in packets) {
      totalBytes += packet.length;
    }
    return totalBytes;
  }

  double getAveragePacketLength() {
    if (packets.isEmpty) {
      return 0;
    }

    int totalLength = 0;
    for (var packet in packets) {
      totalLength += packet.length;
    }
    return totalLength / packets.length;
  }

  int getMinimumPacketSize() {
    if (packets.isEmpty) {
      return 0;
    }

    int minSize = packets[0].length;
    for (var packet in packets) {
      if (packet.length < minSize) {
        minSize = packet.length;
      }
    }
    return minSize;
  }

  int getMaximumPacketSize() {
    if (packets.isEmpty) {
      return 0;
    }

    int maxSize = packets[0].length;
    for (var packet in packets) {
      if (packet.length > maxSize) {
        maxSize = packet.length;
      }
    }
    return maxSize;
  }

  void printStatistics() {
    if (stopwatch.isRunning) {
      print(
          "Total Time Elapsed: ${stopwatch.elapsedMicroseconds} us, ${stopwatch.elapsedMilliseconds} ms, ${stopwatch.elapsedMilliseconds / 1000} s");
    }
    int totalPackets = getTotalPacketsReceived();
    int totalBytes = getTotalBytesReceived();
    double avgPacketLength = getAveragePacketLength();
    int minPacketSize = getMinimumPacketSize();
    int maxPacketSize = getMaximumPacketSize();

    print("Total Packets Received: $totalPackets");
    print("Total Bytes Received: $totalBytes");
    print("Average Packet Length: $avgPacketLength");
    print("Minimum Packet Size: $minPacketSize");
    print("Maximum Packet Size: $maxPacketSize");
    print("\n");
  }

  void reset() {
    packets.clear();
    stopwatch.stop();
    stopwatch.reset();
    stopwatch.start();
  }
}

----- END ./lib/models/timing_util.dart -----

----- BEGIN ./lib/models/usb_protocol/commands.dart -----
import 'dart:typed_data';

abstract class UsbCommand {
  //message SpikerBox will reply with messages that contain information about hardware type:
  ///this command is for the HHIBOX only
  static const hwTypeInquiry = MessageValueSet(message: 'b');

  /// this command is only for Human spiker Box
  static const hwVersionInquiry = MessageValueSet(message: '?');

  /// received only from human spiker box
  static const eventMessage = MessageValueSet(message: 'EVNT');

  /// this only for human spiker box
  static const deviceConnection = MessageValueSet(message: 'board');

  /// this response is from human spiker box for game controller
  static const joystick = MessageValueSet(message: 'JOY');

  static const List<MessageValueSet> commandList = [
    hwTypeInquiry,
    hwVersionInquiry,
    eventMessage,
    deviceConnection,
  ];

  static String _generatedCommand(
      {required List<MessageValueSet> messageList}) {
    return messageList.map((e) => e.toString()).join(";");
  }

  /// Parse the message received from device
  static List<MessageValueSet> parseCommand({required String cmd}) {
    return cmd
        .split(";")
        .map((e) => MessageValueSet.fromStringCommand(message: e))
        .toList();
  }
}

class MessageValueSet {
  final String message;
  final String value;

  const MessageValueSet({required this.message, this.value = ""});

  factory MessageValueSet.fromStringCommand({required String message}) {
    final List<String> splitString = message.split(':');
    final String msg = splitString.first;
    final String value = splitString.last;
    return MessageValueSet(message: msg, value: value);
  }

  factory MessageValueSet.fromUint8ListCommand({required Uint8List message}) {
    return MessageValueSet.fromStringCommand(
        message: String.fromCharCodes(message));
  }

  @override
  String toString() {
    String generatedCommand = '$message:$value;\n';
    return generatedCommand;
  }

  Uint8List cmdAsBytes() {
    return Uint8List.fromList(toString().codeUnits);
  }
}

----- END ./lib/models/usb_protocol/commands.dart -----

----- BEGIN ./lib/models/usb_protocol/usb_protocol.dart -----
export 'commands.dart';
----- END ./lib/models/usb_protocol/usb_protocol.dart -----

----- BEGIN ./lib/models/web_sound_implementation.dart -----
// // import 'dart:async';
// // import 'dart:typed_data';

// // import 'package:flutter/material.dart';

// // import 'package:just_audio/just_audio.dart';
// // import 'package:microphone/microphone.dart';

// // /// Example app demonstrating how to use the `microphone` plugin and with that
// // /// a [MicrophoneRecorder].
// // ///
// // /// The example app listens to realtime updates of the recording and based on
// // /// that provides functionality to start, stop, and listen to a recording.
// // class MicrophoneExampleApp extends StatefulWidget {
// //   /// Constructs [MicrophoneExampleApp].
// //   const MicrophoneExampleApp({Key? key}) : super(key: key);

// //   @override
// //   _MicrophoneExampleAppState createState() => _MicrophoneExampleAppState();
// // }

// // class _MicrophoneExampleAppState extends State<MicrophoneExampleApp> {
// //   MicrophoneRecorder? _recorder;
// //   AudioPlayer? _audioPlayer;
// //   StreamController<Uint8List> addListenAudioStream = StreamController();

// //   @override
// //   void initState() {
// //     super.initState();

// //     _initRecorder();
// //     listenEvent();
// //   }

// //   @override
// //   void dispose() {
// //     _recorder?.dispose();
// //     _audioPlayer?.dispose();

// //     super.dispose();
// //   }

// //   void listenEvent() {
// //     micStream.listen((event) {
// //       print("the event is $event");
// //     });
// //   }

// //   late final Stream<Uint8List> micStream;

// //   void _initRecorder() {
// //     micStream = addListenAudioStream.stream.asBroadcastStream();
// //     // Dispose the previous recorder.
// //     _recorder?.dispose();

// //     _recorder = MicrophoneRecorder()
// //       ..init()
// //       ..addListener(() async {
// //         final byteAdded = await _recorder?.toBytes();
// //         addListenAudioStream.add(byteAdded!);
// //         setState(() {});
// //       });
// //   }

// //   @override
// //   Widget build(BuildContext context) {
// //     final value = _recorder!.value;

// //     Widget result;

// //     if (value.started) {
// //       if (value.stopped) {
// //         result = Column(
// //           mainAxisAlignment: MainAxisAlignment.center,
// //           children: [
// //             OutlinedButton(
// //               onPressed: () {
// //                 setState(_initRecorder);
// //               },
// //               child: Text('Restart recorder'),
// //             ),
// //             Padding(
// //               padding: const EdgeInsets.only(
// //                 top: 16,
// //               ),
// //               child: OutlinedButton(
// //                 onPressed: () async {
// //                   _audioPlayer?.dispose();

// //                   _audioPlayer = AudioPlayer();

// //                   await _audioPlayer?.setUrl(value.recording!.url);
// //                   await _audioPlayer!.play();
// //                 },
// //                 child: Text('Play recording'),
// //               ),
// //             ),
// //           ],
// //         );
// //       } else {
// //         result = OutlinedButton(
// //           onPressed: () {
// //             _recorder!.stop();
// //           },
// //           child: Text('Stop recording'),
// //         );
// //       }
// //     } else {
// //       result = OutlinedButton(
// //         onPressed: () {
// //           _recorder!.start();

// //           _recorder?.toBytes().asStream().listen((event) {
// //             print("the event is $event");
// //           });
// //         },
// //         child: Text('Start recording'),
// //       );
// //     }

// //     return MaterialApp(
// //       home: Scaffold(
// //         body: Center(
// //           child: result,
// //         ),
// //       ),
// //     );
// //   }
// // }

// import 'package:flutter/foundation.dart';
// import 'package:flutter/material.dart';
// import 'dart:js' as js;

// class ListenInWeb extends StatefulWidget {
//   const ListenInWeb({super.key});

//   @override
//   State<ListenInWeb> createState() => _ListenInWebState();
// }

// class _ListenInWebState extends State<ListenInWeb> {
//   int isOpeningFile = 0;

//   String versionNumber = '1.2.1';

//   int _counter = 0;

//   int extraChannels = 0;
//   int minChannels = 0;
//   int maxChannels = 0;

//   int localChannel = 1;

//   double prevY = 0.0;

//   List<double> channelGains = [10000, 10000, 10000, 10000, 10000, 10000];

//   int minIndexSerial = 1;
//   int maxIndexSerial = 25;

//   int minIndexHid = 1;
//   int maxIndexHid = 15;

//   int minIndexAudio = 1;
//   int maxIndexAudio = 20;

//   List<double> listIndexSerial = [5, 5, 5, 5, 5, 5];
//   List<double> listIndexHid = [7, 7, 7, 7, 7, 7];
//   List<double> listIndexAudio = [9, 9];

//   List<double> levelMedian = [-1, -1, -1, -1, -1, -1];
//   List<double> initialLevelMedian = [0, 0, 0, 0, 0, 0];

//   List<double> chartData = [];
//   List<List<double>> channelsData = [];

//   var horizontalDiff = 0;

//   num timeScale = 10000; //10ms to 10 seconds
//   num curTimeScaleBar = 1000; //10ms to 10 seconds
//   num curSkipCounts = 256;
//   num curFps = 30;
//   int sampleRate = 44100;
//   List<double> arrDataMax = []; //10 seconds
//   List<double> arrData = []; // current

//   int capacity = 1;
//   int capacityMin = 1;
//   int capacityMax = 1;

//   int isPlaying = 0;
//   int isRecording = 0;
//   int deviceType = 0; // 0 - audio | 1 - serial

//   callbackIsOpeningWavFile(params) {
//     isOpeningFile = params[0];
//     setState(() {});
//   }

//   var settingParams = {
//     "channelCount": -1,
//     "maxAudioChannels": 2,
//     "maxSerialChannels": 6,
//     "initialMaxSerialChannels": 6,
//     "muteSpeakers": true,
//     "lowFilterValue": "0",
//     "highFilterValue": "1000",
//     "notchFilter50": false,
//     "notchFilter60": false,
//     "defaultMicrophoneLeftColor": 0,
//     "defaultMicrophoneRightColor": 1,
//     "defaultSerialColor1": 0,
//     "defaultSerialColor2": 1,
//     "defaultSerialColor3": 2,
//     "defaultSerialColor4": 3,
//     "defaultSerialColor5": 4,
//     "defaultSerialColor6": 5,
//     "flagDisplay1": 1,
//     "flagDisplay2": 0,
//     "flagDisplay3": 0,
//     "flagDisplay4": 0,
//     "flagDisplay5": 0,
//     "flagDisplay6": 0,
//     "strokeWidth": 1.25,
//     "strokeOptions": [1, 1.25, 1.5, 1.75, 2],
//     "enableDeviceLegacy": false
//   };

//   callbackAudioInit(params) {
//     deviceType = params[0];
//     isPlaying = params[1];
//     // startRecordingTime = (DateTime.now());
//     channelGains = [10000, 10000, 10000, 10000, 10000, 10000];
//     listIndexSerial = [5, 5, 5, 5, 5, 5];
//     listIndexHid = [7, 7, 7, 7, 7, 7];
//     listIndexAudio = [9, 9];

//     settingParams["flagDisplay1"] = 1;
//     settingParams["flagDisplay2"] = 0;
//     settingParams["defaultMicrophoneLeftColor"] = 0;
//     settingParams["defaultMicrophoneRightColor"] = 1;
//     // channelsColor[0] = audioChannelColors[0];
//     // channelsColor[1] = audioChannelColors[1];
//     // print("channelsColor[0] : "+channelsColor[0].toString());
//     // print("channelsColor[1] : "+channelsColor[1].toString());

//     js.context.callMethod('setFlagChannelDisplay', [
//       settingParams["flagDisplay1"],
//       settingParams["flagDisplay2"],
//       settingParams["flagDisplay3"],
//       settingParams["flagDisplay4"],
//       settingParams["flagDisplay5"],
//       settingParams["flagDisplay6"]
//     ]);
//     // if (initFPS){
//     //   initFPS = false;
//     //   Fps.instance.start();
//     //   Fps.instance.addFpsCallback((FpsInfo fpsInfo) async {
//     //     // print("fpsInfo.fps");
//     //     // print(fpsInfo.fps);
//     //     if (curFps == fpsInfo.fps){
//     //       return;
//     //     }
//     //     curFps = fpsInfo.fps;
//     //     int incSkip = 0;
//     //     if (curFps < 30){

//     //     }else
//     //     if (curFps <15){
//     //       incSkip++;
//     //     }

//     //     // if (curFps <15){
//     //     //   incSkip++;
//     //     // }
//     //     if (!isFeedback)
//     //       ( await js.context.callMethod('setFps', [ curFps, incSkip ]) );
//     //   });

//     // }

//     setState(() {});
//   }

//   @override
//   void initState() {
//     // TODO: implement initState
//     super.initState();
//     js.context['callbackAudioInit'] = callbackAudioInit;
//     js.context['callbackIsOpeningWavFile'] = callbackIsOpeningWavFile;
//     Future.delayed(const Duration(seconds: 2), () {
//       isPlaying = 1;
//       js.context
//           .callMethod('recordAudio', ['Flutter is calling upon JavaScript!']);
//     });
//   }

//   @override
//   Widget build(BuildContext context) {
//     return Scaffold();
//   }
// }

----- END ./lib/models/web_sound_implementation.dart -----

----- BEGIN ./lib/provider/custom_slider_provider.dart -----
import 'package:flutter/material.dart';

class CustomRangeSliderProvider extends ChangeNotifier {
  double _startValue = 0;
  double get startValue => _startValue;
  double _endValue = 0;
  double get endValue => _endValue;
  setStartValue(double startValue) {
    _startValue = startValue;
    notifyListeners();
  }

  setEndValue(double endValue) {
    _endValue = endValue;
    notifyListeners();
  }
}

----- END ./lib/provider/custom_slider_provider.dart -----

----- BEGIN ./lib/provider/data_type_status.dart -----
import 'package:flutter/foundation.dart';
import 'package:native_add/model/model.dart';
import '../models/constant.dart';

class DataStatusProvider extends ChangeNotifier {
  bool _isMicrophoneData = true;
  bool _isSampleDataOn = false;
  bool _isDeviceDataOn = false;
  bool _is50Hertz = false;
  bool _is60Hertz = false;
  bool _isDebugging = false;

  //

  FilterSetup _highPassFilterSettings = const FilterSetup(
      isFilterOn: false,
      filterType: FilterType.highPassFilter,
      filterConfiguration:
          FilterConfiguration(cutOffFrequency: 500, sampleRate: 10000),
      channelCount: channelCountBuffer);

  FilterSetup _lowPassFilterSettings = const FilterSetup(
      isFilterOn: false,
      filterType: FilterType.lowPassFilter,
      filterConfiguration:
          FilterConfiguration(cutOffFrequency: 500, sampleRate: 10000),
      channelCount: channelCountBuffer);

  FilterSetup _notchPassFilterSettings = const FilterSetup(
      isFilterOn: false,
      filterType: FilterType.notchFilter,
      filterConfiguration:
          FilterConfiguration(cutOffFrequency: 500, sampleRate: 10000),
      channelCount: channelCountBuffer);

  bool get isDeviceDataOn => _isDeviceDataOn;
  bool get is60Hertz => _is60Hertz;
  bool get is50Hertz => _is50Hertz;
  bool get isSampleDataOn => _isSampleDataOn;
  bool get isMicrophoneData => _isMicrophoneData;
  FilterSetup get lowPassFilterSettings => _lowPassFilterSettings;
  FilterSetup get highPassFilterSettings => _highPassFilterSettings;

  FilterSetup get notchPassFilterSettings => _notchPassFilterSettings;
  bool get isDebugging => _isDebugging;

  setSampleDataStatus(bool sampleDataStatus) {
    _isSampleDataOn = sampleDataStatus;
    notifyListeners();
  }

  setDebuggingDataStatus(bool newStatus) {
    _isDebugging = newStatus;
    notifyListeners();
  }

  set50HertzStatus(bool is50Hertz) {
    _is50Hertz = is50Hertz;
    notifyListeners();
  }

  set60HertzStatus(bool is60Hertz) {
    _is60Hertz = is60Hertz;
    notifyListeners();
  }

  setMicrophoneDataStatus(bool microphoneDataStatus) {
    _isMicrophoneData = microphoneDataStatus;
    notifyListeners();
  }

  setDeviceDataStatus(bool isDeviceDataOn) {
    _isDeviceDataOn = isDeviceDataOn;
    notifyListeners();
  }

  setLowPassFilterSetting(FilterSetup filterConfiguration) {
    _lowPassFilterSettings = filterConfiguration;
    notifyListeners();
  }

  setHighPassFilterSetting(FilterSetup filterConfiguration) {
    _highPassFilterSettings = filterConfiguration;
    notifyListeners();
  }

  setNotchPassFilterSetting(FilterSetup filterConfiguration) {
    _notchPassFilterSettings = filterConfiguration;
    notifyListeners();
  }
}

----- END ./lib/provider/data_type_status.dart -----

----- BEGIN ./lib/provider/debug_time_provider.dart -----
import 'package:flutter/foundation.dart';
import 'package:spikerbox_architecture/models/audio_detail_model.dart';

class DebugTimeProvider extends ChangeNotifier {
  int _totalTime = 0;
  int _counter = 0;
  int _averageTime = 0;
  static final int maxIntValue =
      kIsWeb ? int.parse('9007199254740991') : int.parse('9223372036854775807');
  int _minTime = maxIntValue;
  int _maxTime = 0;

  int get averageTime => _averageTime;
  int get minTime => _minTime;
  int get maxTime => _maxTime;

//* audioDetail constant

  // int _audioAvgTime = 0;
  // int _audioMaxTime = 0;
  // int _audioMinTime = 0;

  AudioDetail? _audioDetail;

  AudioDetail get audioDetail => _audioDetail!;

  setAudioDetail(AudioDetail audioDetail) {
    _audioDetail = audioDetail;
    notifyListeners();
  }
  // int get audioAvgTime => _audioAvgTime;
  // int get audioMaxTime => _audioMaxTime;
  // int get audioMinTIme => _audioMinTime;

// *   provider for  render data in calculation  on the graph
  addGraphTime(
    int time,
  ) {
    if (_totalTime + time > maxIntValue) {
      resetCounter();
    }
    _averageTimeTaken(time);
    _minMaxTimeTaken(time);
  }

  _averageTimeTaken(int time) {
    _counter++;
    _totalTime += time;
    _averageTime = (_totalTime ~/ _counter);
    notifyListeners();
  }

  _minMaxTimeTaken(int time) {
    if (time < minTime) {
      int min = time;
      setMin(min);
    }
    if (time > maxTime) {
      int max = time;
      setMax(max);
    }
  }

  resetCounter() {
    _counter = 0;
    _totalTime = 0;
    _averageTime = 0;
    _maxTime = 0;
    _minTime = 0;
  }

  setMax(int max) {
    _maxTime = max;
    notifyListeners();
  }

  setMin(int min) {
    _minTime = min;
    notifyListeners();
  }

  //*

  addMicrophoneTiming() {}
}

----- END ./lib/provider/debug_time_provider.dart -----

----- BEGIN ./lib/provider/devices_provider.dart -----
import 'package:flutter/foundation.dart';

class ConstantProvider extends ChangeNotifier {
  int _bitData = 10;
  int _channelCount = 1;
  int _baudRate = 222222;
  bool _isDeviceConnected = false;
  bool get isDeviceConnected => _isDeviceConnected;

  int getBitData() {
    return _bitData;
  }

  int getChannelCount() {
    return _channelCount;
  }

  int getBaudRate() {
    return _baudRate;
  }

  setBitData(int bitData) {
    _bitData = bitData;
    notifyListeners();
  }

  setChannelCount(int channelCount) {
    _channelCount = channelCount;
    notifyListeners();
  }

  setBaudRate(int baudRate) {
    _baudRate = baudRate;
    notifyListeners();
  }

  //it check any port is devices in inserted

  setDeviceInsertInPort(bool isDeviceInserted) {
    _isDeviceConnected = isDeviceInserted;
    notifyListeners();
  }
}

----- END ./lib/provider/devices_provider.dart -----

----- BEGIN ./lib/provider/enveloping_config_provider.dart -----
import 'package:flutter/foundation.dart';

class EnvelopConfigProvider extends ChangeNotifier {
  int _sampleLength = 0;
  int _skipCount = 0;
  int _bufferSize = 0;

  int get bufferSize => _bufferSize;
  int get sampleLength => _sampleLength;
  int get skipCount => _skipCount;
  int _sampleRate = 44100;

  void firstTimeSet(int upComingSampleRate, int duration) {
    _sampleRate = upComingSampleRate;
    changeSampleLengthOnScroll(duration);
    changeSkipCountOnScroll(duration);
    changeBufferOnWidgetContext(duration);
  }

  void changeSampleLengthOnScroll(int duration) {
    int sampleLength = (_sampleRate ~/ 1000) * duration;
    _sampleLength = sampleLength;
    notifyListeners();
  }

  void changeSkipCountOnScroll(int duration) {
    int setSkipCount = _sampleLength ~/ 2000;
    _skipCount = setSkipCount;
    notifyListeners();
  }

  void changeBufferOnWidgetContext(int duration) {
    int newBufferSize = (_sampleRate ~/ 1000) * duration;
    _bufferSize = newBufferSize;
    notifyListeners();
  }

  void changeSampleLengthAndSkipCount(int duration) {
    changeSampleLengthOnScroll(duration);
    changeSkipCountOnScroll(duration);
  }
}

----- END ./lib/provider/enveloping_config_provider.dart -----

----- BEGIN ./lib/provider/graph_gain_provider.dart -----
import 'package:flutter/material.dart';

class GraphGainProvider extends ChangeNotifier {
  double gain = 1;

  setGain(double newGain) {
    gain = newGain;
    notifyListeners();
  }
}

----- END ./lib/provider/graph_gain_provider.dart -----

----- BEGIN ./lib/provider/graph_stream_data.dart -----
import 'dart:async';
import 'dart:math';
import 'dart:typed_data';
import 'package:flutter/foundation.dart';
import 'package:spikerbox_architecture/provider/provider_export.dart';

class GraphDataProvider extends ChangeNotifier {
  int delay = 0;
  static const int _graphBufferLength = 4000;
  // int bufferDuration = 30;

  double _scale = 1.0;
  int _startIndex = 0;
  int _endIndex = _graphBufferLength - 1;
  int _timer = 20;
  int get timer => _timer;
  int get graphBufferLength => _graphBufferLength;

  int samplesInCurrentView = _graphBufferLength;

  int get sampleOnGraph => samplesInCurrentView;

  int timeOnGraph = 120000;

  final Int16List _entireGraphBuffer =
      Int16List.fromList(List.generate(_graphBufferLength, (index) => 0));

  Stream<Uint8List>? _inputGraphStream;

  Stream<List<double>>? _outputGraphStream;
  final StreamController<Uint8List> _outputGraphStreamController =
      StreamController.broadcast();

  Stream<List<double>>? get outputGraphStream => _outputGraphStream;

  /// Initializes the incoming data stream [_inputGraphStream]
  /// Initializes the stream to output data to graph [_outputGraphStream]
  void setStreamOfData(Stream<Uint8List> graphStreamData) {
    _inputGraphStream = graphStreamData;

    _outputGraphStream = _outputGraphStreamController.stream
        .asBroadcastStream()
        .transform(myStreamTransformer());

    _inputGraphStream!.listen(inputListener);
  }

  setTimer(int setTime) {
    _timer = setTime;
    notifyListeners();
  }

  /// Transforms the data from Int16 list (as Uint8List) to List<double>
  StreamTransformer<Uint8List, List<double>> myStreamTransformer() {
    StreamTransformer<Uint8List, List<double>> convert =
        StreamTransformer<Uint8List, List<double>>.fromHandlers(
      handleData: (value, sink) {
        // print("the value receive is ${value.sublist(0, 10)}");
        Int16List iList = value.buffer.asInt16List();
        List<double> dt =
            List.generate(iList.length, (index) => index.toDouble());

        for (int i = 0; i < iList.length; i++) {
          dt[i] = iList[i].toDouble();
        }
        sink.add(dt);
      },
    );
    return convert;
  }

  void inputListener(Uint8List input) {
    // print("the input  ${input.length}");
    Int16List int16List = input.buffer.asInt16List();
    // int valueCount = int16List.length;
    delay++;
    // if (delay == 1000) {
    //   print("dsf");
    // }
    // int k = 0;

    // for (int i = 0; i < _entireGraphBuffer.length; i++) {
    //   if (i < _entireGraphBuffer.length - valueCount) {
    //     _entireGraphBuffer[i] = _entireGraphBuffer[i + valueCount];
    //   } else {
    //     _entireGraphBuffer[i] = int16List[k];
    //     k++;
    //   }
    // }
    // print(
    //     "the entireGraphBuffer ${_entireGraphBuffer.length} and int16List ${int16List.length}");
    for (int i = 0; i < _entireGraphBuffer.length; i++) {
      _entireGraphBuffer[i] = int16List[i];
    }

    updateGraph();
  }

  void resetGraphBuffer() {
    for (int i = 0; i < _entireGraphBuffer.length; i++) {
      _entireGraphBuffer[i] = 0;
    }

    updateGraph();
  }

  void updateGraph() {
    try {
      // Int16List newInt16List =
      //     _entireGraphBuffer.sublist(_startIndex, _endIndex);
      // Int16List n = Int16List(_endIndex - _startIndex);

      // for (int i = 0; i < n.length; i++) {
      //   n[i] = newInt16List[i];
      // }
      // Int16List afterEnvelopData = envelopData(n, 2000);
      // _outputGraphStreamController.add(afterEnvelopData.buffer.asUint8List());

      // print("the _entire graph first index value is ${_entireGraphBuffer.}")
      _outputGraphStreamController.add(_entireGraphBuffer
          .sublist(_startIndex, _endIndex)
          .buffer
          .asUint8List());
    } catch (e) {
      // print(
      //     "Exception: _entireGraphBufferLength : ${_entireGraphBuffer.length}, _startIndex: $_startIndex, _endIndex: $_endIndex");
    }
  }

  /// Sets the start and end index from where to read the data from [_entireGraphBuffer]
  // void setScrollIndex(double delta) {
  //   _scale += delta * -0.001;
  //   _scale = _scale.clamp(0, 1);

  //   int tempSamplesInCurrentView = (_graphBufferLength * _scale).floor();

  //   // Samples should be more than 100
  //   tempSamplesInCurrentView =
  //       tempSamplesInCurrentView > 100 ? tempSamplesInCurrentView : 100;

  //   // Samples should be more than 10%
  //   tempSamplesInCurrentView =
  //       tempSamplesInCurrentView > (_graphBufferLength * 0.1)
  //           ? tempSamplesInCurrentView
  //           : (_graphBufferLength * 0.1).floor();

  //   samplesInCurrentView = (_endIndex) - tempSamplesInCurrentView < 0
  //       ? (_endIndex)
  //       : tempSamplesInCurrentView;
  //   _startIndex = (_endIndex) - samplesInCurrentView;

  //   _scale = (samplesInCurrentView / _graphBufferLength).clamp(0, 1);

  //   // print(
  //   //     "on setScrollIndex: $_startIndex - $_endIndex, tempSamplesInCurrentView: $tempSamplesInCurrentView, samples: $samplesInCurrentView");

  //   timeCalculate(samplesInCurrentView);
  //   updateGraph();

  //   notifyListeners();
  // }
  void setScrollIndex(double delta, EnvelopConfigProvider envelopConfig) {
    _scale += delta * -0.0001;
    _scale = _scale.clamp(0.001, 1);
    // if (kIsWeb) {
    //   int tempSamplesInCurrentView = (_graphBufferLength * _scale).floor();

    //   // Samples should be more than 100
    //   tempSamplesInCurrentView =
    //       tempSamplesInCurrentView > 100 ? tempSamplesInCurrentView : 100;

    //   // Samples should be more than 10%
    //   tempSamplesInCurrentView =
    //       tempSamplesInCurrentView > (_graphBufferLength * 0.1)
    //           ? tempSamplesInCurrentView
    //           : (_graphBufferLength * 0.1).floor();

    //   samplesInCurrentView = (_endIndex) - tempSamplesInCurrentView < 0
    //       ? (_endIndex)
    //       : tempSamplesInCurrentView;
    //   _startIndex = (_endIndex) - samplesInCurrentView;

    //   _scale = (samplesInCurrentView / _graphBufferLength).clamp(0, 1);
    //   int durationToDisplay = (_scale * 1 * 1000).toInt();
    //   timeOnGraph = durationToDisplay;
    //   // timeCalculate(samplesInCurrentView);
    // } else {
    /// In milliseconds
    int durationToDisplay = (_scale * 120 * 1000).toInt();
    // print("Duration ${durationToDisplay}");
    // EnvelopConfig envelopConfigProvider =
    //     Provider.of<EnvelopConfig>(context, listen: false);
    envelopConfig.changeSampleLengthAndSkipCount(durationToDisplay);
    timeOnGraph = durationToDisplay;
    // }

    updateGraph();

    notifyListeners();
  }

  timeCalculate(int currentSample) {
    (double.tryParse((currentSample / _graphBufferLength)
                .toStringAsFixed(1)
                .replaceAll(".", "")) ??
            (currentSample / _graphBufferLength))
        .toInt();
    setTimer(currentSample + 1);
  }

  double getViewPortWidth() {
    int len = _endIndex - _startIndex;
    double ratio = len / _graphBufferLength;
    ratio = ratio.clamp(0, 1);
    return ratio;
  }

  void setPanLevel(double leftRatio, double rightRatio) {
    _startIndex = (_graphBufferLength * leftRatio).toInt();
    _startIndex = _startIndex < 0 ? 0 : _startIndex;

    _endIndex = _startIndex + samplesInCurrentView;
    _endIndex = _endIndex < _graphBufferLength ? _endIndex : _endIndex - 1;
    // print(
    //     "In SetPanLevel : _startIndex : $_startIndex, _endIndex: $_endIndex, samplesInCurrentView: $samplesInCurrentView");

    updateGraph();
  }

  // set the bufferlength

  // setBufferLength(int graphBufferLength) {
  //   print("the buffer length is ${_graphBufferLength}");
  //   // _graphBufferLength = graphBufferLength * 30;

  //   notifyListeners();
  // }

  //enveloping the data

  Int16List envelopData(Int16List samples, int totalPoints) {
    int stepSize = (samples.length / totalPoints).round();
    Int16List envelopePoints =
        Int16List(totalPoints * 2); // Double the size for min and max values

    for (int i = 0; i < totalPoints; i++) {
      int start = i * stepSize;
      int end = (i + 1) * stepSize;
      end = end > samples.length ? samples.length : end;

      int maxVal = samples.sublist(start, end).reduce(max);
      int minVal = samples.sublist(start, end).reduce(min);
      envelopePoints[i * 2] = maxVal;
      envelopePoints[i * 2 + 1] = minVal;
    }

    return envelopePoints;
  }
  // Int16List envelopData(Int16List sourceData, int envelopedLength) {
  //   // Initialize the list to store enveloped data
  //   Int16List envelopedData = Int16List(envelopedLength);

  //   // Initialize circular buffer for envelopes
  //   int head = 0;
  //   List<Int16List> envelopes = List.generate(
  //     21,
  //     (index) => Int16List((sourceData.length / (1 << index)).ceil()),
  //   );

  //   // Iterate through each sample in the source data
  //   for (int i = 0; i < sourceData.length; i++) {
  //     // Iterate through different levels of envelopes
  //     for (int j = 1; j <= 21; j++) {
  //       int skipCount = 1 << j;
  //       int envelopeIndex = j - 1;
  //       int envelopeSampleIndex = (head ~/ skipCount);

  //       // Check if the envelope index is within bounds
  //       if (envelopeSampleIndex >= envelopes[envelopeIndex].length) {
  //         continue;
  //       }

  //       // Retrieve the current value in the envelope
  //       int dst = envelopes[envelopeIndex][envelopeSampleIndex];

  //       // Update the envelope based on the current sample
  //       if (head % skipCount == 0) {
  //         envelopes[envelopeIndex][envelopeSampleIndex] = sourceData[i];
  //       } else {
  //         envelopes[envelopeIndex][envelopeSampleIndex] =
  //             dst < sourceData[i] ? sourceData[i] : dst;
  //       }
  //     }

  //     // Add the raw data to the enveloped data (circular buffer)
  //     envelopedData[head++] = sourceData[i];

  //     // Wrap around the circular buffer if it reaches the specified length
  //     if (head == envelopedLength) {
  //       head = 0;
  //     }
  //   }

  //   // Return the enveloped data
  //   return envelopedData;
  // }
}

----- END ./lib/provider/graph_stream_data.dart -----

----- BEGIN ./lib/provider/isgraphplay_provider.dart -----
import 'dart:async';

import 'package:flutter/material.dart';

class GraphResumePlayProvider extends ChangeNotifier {
  bool _graphStatus = true;
  bool get graphStatus => _graphStatus;

  final StreamController<bool> _graphStatusStreamController =
      StreamController.broadcast();
  Stream<bool>? _graphStatusStream;

  Stream<bool> getStream() {
    _graphStatusStream ??= _graphStatusStreamController.stream;
    return _graphStatusStream!;
  }

  setGraphResumePlay(bool isGraphStatus) {
    _graphStatus = isGraphStatus;
    _graphStatusStreamController.add(isGraphStatus);
    notifyListeners();
  }
}

----- END ./lib/provider/isgraphplay_provider.dart -----

----- BEGIN ./lib/provider/port_scan_provider.dart -----
import 'package:flutter/material.dart';

class PortScanProvider extends ChangeNotifier {
  List<String> _availablePorts = [];
  List<String> get availablePorts => _availablePorts;

  final List<String> _deviceList = [];
  List<String> get deviceList => _deviceList;

  setPortScanList(List<String> portScanList) {
    _availablePorts = portScanList;
    notifyListeners();
  }

  setDeviceList(String deviceList) {
    _deviceList.add(deviceList);
    notifyListeners();
  }

  removeDeviceList(String deviceList) {
    _deviceList.remove(deviceList);
    notifyListeners();
  }

  resetProvider() {
    _availablePorts = [];
    notifyListeners();
  }
}

----- END ./lib/provider/port_scan_provider.dart -----

----- BEGIN ./lib/provider/provider_export.dart -----
export 'custom_slider_provider.dart';
export 'devices_provider.dart';
export 'graph_gain_provider.dart';
export 'graph_stream_data.dart';
export 'isgraphplay_provider.dart';
export 'vertical_dragprovider.dart';
export 'data_type_status.dart';
export 'software_setting_provider.dart';
export 'serial_provider.dart';
export 'port_scan_provider.dart';
export 'sample_rate_provider.dart';
export 'debug_time_provider.dart';
export 'enveloping_config_provider.dart';

----- END ./lib/provider/provider_export.dart -----

----- BEGIN ./lib/provider/sample_rate_provider.dart -----
import 'package:flutter/material.dart';

class SampleRateProvider extends ChangeNotifier {
  int _sampleRate = 10000;
  int get sampleRate => _sampleRate;

  setSampleRate(int sampleRate) {
    _sampleRate = sampleRate;
    notifyListeners();
  }
}

----- END ./lib/provider/sample_rate_provider.dart -----

----- BEGIN ./lib/provider/serial_provider.dart -----
import 'package:flutter/material.dart';

import '../models/models.dart';

class SerialDataProvider extends ChangeNotifier {
  final List<SerialPortDataModel> _getAllPortDetail = [];
  List<SerialPortDataModel> get getAllPortDetail => _getAllPortDetail;
  List<ComDataWithBoard> _deviceWithComData = [];

  List<ComDataWithBoard> get deviceWithComData => _deviceWithComData;

  setPortOfDevices(SerialPortDataModel serialPortData) {
    bool containsDuplicate = _getAllPortDetail
        .any((element) => element.deviceDetect == serialPortData.deviceDetect);

    if (!containsDuplicate) {
      _getAllPortDetail.add(serialPortData);
      notifyListeners();
    }
  }

  setDeviceWithComData(List<ComDataWithBoard> newDeviceList) {
    _deviceWithComData.clear();
    _deviceWithComData = newDeviceList;
    notifyListeners();
  }

  removeDeviceWithComData(ComDataWithBoard serialPortData) {
    _deviceWithComData.remove(serialPortData);
    notifyListeners();
  }
}

----- END ./lib/provider/serial_provider.dart -----

----- BEGIN ./lib/provider/software_setting_provider.dart -----
import 'package:flutter/foundation.dart';

class SoftwareConfigProvider extends ChangeNotifier {
  bool _isSettingEnable = false;

  bool get isSettingEnable => _isSettingEnable;

  settingStatus(bool status) {
    _isSettingEnable = status;
    notifyListeners();
  }
}

----- END ./lib/provider/software_setting_provider.dart -----

----- BEGIN ./lib/provider/vertical_dragprovider.dart -----
import 'package:flutter/material.dart';

class VerticalDragProvider extends ChangeNotifier {
  double initialOffset = 0;
  double topPosition = 0;

  setDragPosition(double newTopPosition) {
    topPosition = newTopPosition;
    notifyListeners();
  }
}

----- END ./lib/provider/vertical_dragprovider.dart -----

----- BEGIN ./lib/screen/admin_dashboard_screen/admin_screen.dart -----
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:path_provider/path_provider.dart';
import 'package:spikerbox_architecture/widget/custom_button.dart';
import 'package:url_launcher/url_launcher.dart';

class DashBoardPannel extends StatefulWidget {
  const DashBoardPannel({super.key});

  @override
  State<DashBoardPannel> createState() => _DashBoardPannelState();
}

class _DashBoardPannelState extends State<DashBoardPannel> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      appBar: AppBar(title: const Text("Backyard Brains")),
      body: SingleChildScrollView(
        child: Column(
          children: [
            SizedBox(
              height: 250,
              width: 250,
              child: Image.asset("assets/spiker_logo.jpeg"),
            ),
            ListView.builder(
              shrinkWrap: true,
              itemCount: downLoadFileList.length,
              itemBuilder: (context, index) => Column(
                children: [
                  const SizedBox(
                    height: 20,
                  ),
                  CustomButton(
                    onTap: () {
                      openWebPageInNewTab(downLoadFileList[index].url);
                    },
                    childWidget: Text(downLoadFileList[index].fileName),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  void openWebPageInNewTab(String url) async {
    if (await canLaunchUrl(Uri.parse(url))) {
      await launchUrl(
        Uri.parse(url),
      );
    } else {
      throw 'Could not launch $url';
    }
  }
}

List<DownLoadTheFile> downLoadFileList = [
  DownLoadTheFile(
      fileName: "ProtoType 1.0.0",
      url:
          "https://drive.google.com/drive/folders/1KFfi-bKGfLub0-Zk4o6CzQbHs4m5fFSF?usp=sharing"),
  DownLoadTheFile(
      fileName: "ProtoType 1.0.1",
      url:
          "https://drive.google.com/drive/folders/1FuK10pXp7OihJ43xozloQ74GPyEoKjnX?usp=drive_link"),
  DownLoadTheFile(
      fileName: "ProtoType 1.0.2",
      url:
          "https://drive.google.com/drive/folders/1PXQ3vmGlxn9hg_FmtFfB7YnyPqBotF5b?usp=sharing"),
  DownLoadTheFile(
      fileName: "ProtoType 1.0.3",
      url:
          "https://drive.google.com/drive/folders/1ISIxMw_xNV9jM9x97wX8mDGyAo2ps2ps?usp=drive_link"),
  DownLoadTheFile(
      fileName: "ProtoType 1.0.4",
      url:
          "https://drive.google.com/drive/folders/1x71LOjk7PvVJSbm1onTHw7-QcTR7k9E1?usp=drive_link"),
  DownLoadTheFile(
      fileName: "ProtoType 1.0.5",
      url:
          "https://drive.google.com/drive/folders/158jBuVS_pUXBYdp00pC8OWNjdSl-krYc?usp=drive_link"),
];

class DownLoadTheFile {
  DownLoadTheFile({
    required this.url,
    required this.fileName,
  });

  String url;
  String fileName;
}

----- END ./lib/screen/admin_dashboard_screen/admin_screen.dart -----

----- BEGIN ./lib/screen/admin_dashboard_screen/adminscreen.dart -----
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:path_provider/path_provider.dart';
import 'package:spikerbox_architecture/widget/custom_button.dart';
import 'package:url_launcher/url_launcher.dart';

class DashBoardPannel extends StatefulWidget {
  const DashBoardPannel({super.key});

  @override
  State<DashBoardPannel> createState() => _DashBoardPannelState();
}

class _DashBoardPannelState extends State<DashBoardPannel> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      appBar: AppBar(title: const Text("Backyard Brains")),
      body: SingleChildScrollView(
        child: Column(
          children: [
            SizedBox(
              height: 250,
              width: 250,
              child: Image.asset("assets/spiker_logo.jpeg"),
            ),
            ListView.builder(
              shrinkWrap: true,
              itemCount: downLoadFileList.length,
              itemBuilder: (context, index) => Column(
                children: [
                  const SizedBox(
                    height: 20,
                  ),
                  CustomButton(
                    onTap: () {
                      openWebPageInNewTab(downLoadFileList[index].url);
                    },
                    childWidget: Text(downLoadFileList[index].fileName),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  void openWebPageInNewTab(String url) async {
    if (await canLaunchUrl(Uri.parse(url))) {
      await launchUrl(
        Uri.parse(url),
      );
    } else {
      throw 'Could not launch $url';
    }
  }
}

List<DownLoadTheFile> downLoadFileList = [
  DownLoadTheFile(
      fileName: "ProtoType 1.0.0",
      url:
          "https://drive.google.com/drive/folders/1KFfi-bKGfLub0-Zk4o6CzQbHs4m5fFSF?usp=sharing"),
  DownLoadTheFile(
      fileName: "ProtoType 1.0.1",
      url:
          "https://drive.google.com/drive/folders/1FuK10pXp7OihJ43xozloQ74GPyEoKjnX?usp=drive_link"),
  DownLoadTheFile(
      fileName: "ProtoType 1.0.2",
      url:
          "https://drive.google.com/drive/folders/1PXQ3vmGlxn9hg_FmtFfB7YnyPqBotF5b?usp=sharing"),
];

class DownLoadTheFile {
  DownLoadTheFile({
    required this.url,
    required this.fileName,
  });

  String url;
  String fileName;
}

----- END ./lib/screen/admin_dashboard_screen/adminscreen.dart -----

----- BEGIN ./lib/screen/dart_isolate_screen/native_isolates.dart -----
import 'dart:isolate';
import 'package:flutter/material.dart';
import 'package:spikerbox_architecture/widget/custom_button.dart';

class NativeIsolateScreen extends StatefulWidget {
  const NativeIsolateScreen({super.key});

  @override
  State<NativeIsolateScreen> createState() => _NativeIsolateScreenState();
}

class _NativeIsolateScreenState extends State<NativeIsolateScreen> {
  ReceivePort? _receivePort;
  SendPort? _sendPort;
  Isolate? isolate;

  @override
  void initState() {
    super.initState();
    _startCounterIsolate();
  }

  @override
  void dispose() {
    super.dispose();
    _receivePort!.close();
    isolate?.kill();
  }

  void _startCounterIsolate() async {
    _receivePort = ReceivePort();
    isolate = await Isolate.spawn(processingInIsolate, _receivePort!.sendPort);
    _receivePort!.listen((dynamic value) {
      if (value is SendPort) {
        _sendPort = value;
      }
    });
  }

  static void processingInIsolate(SendPort sendPort) {
    ReceivePort receivePortIsolate = ReceivePort();
    sendPort.send(receivePortIsolate.sendPort);
    receivePortIsolate.listen((message) {
      if (message is String) {
        int startTime = DateTime.now().microsecondsSinceEpoch;
        int a = 10;
        for (var i = 0; i < 100000; i++) {
          a *= a;
        }
        int timeTaken = DateTime.now().microsecondsSinceEpoch - startTime;
        print("Time taken within isolate: $timeTaken microseconds");
        sendPort.send(timeTaken);
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Isolate Example'),
      ),
      body: Center(
        child: CustomButton(
          colors: Colors.blue[500],
          childWidget: const Text("Calculate again"),
          onTap: () {
            _sendPort?.send("Calculate");
          },
        ),
      ),
    );
  }
}

----- END ./lib/screen/dart_isolate_screen/native_isolates.dart -----

----- BEGIN ./lib/screen/debug_data.dart -----
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:spikerbox_architecture/constant/const_export.dart';

import '../provider/provider_export.dart';

class DebugTheDataDetail extends StatefulWidget {
  const DebugTheDataDetail({super.key});

  @override
  State<DebugTheDataDetail> createState() => _DebugTheDataDetailState();
}

class _DebugTheDataDetailState extends State<DebugTheDataDetail> {
  @override
  Widget build(BuildContext context) {
    return Consumer2<DebugTimeProvider, DataStatusProvider>(
        builder: (context, debugTimeList, dataStatus, snapshot) {
      if (dataStatus.isDebugging) {
        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const _TextWidget(
              text: "Packet Detail of render data(audio serial) on Graph",
            ),
            _TextWidget(
              text:
                  "Average Time = ${debugTimeList.averageTime} microsecond /per packet",
            ),
            _TextWidget(
              text: "Min Time = ${debugTimeList.minTime} microsecond",
            ),
            _TextWidget(
              text: "Max Time = ${debugTimeList.maxTime} microsecond",
            ),
            !kIsWeb
                ? Column(
                    children: [
                      _TextWidget(
                          text:
                              "Audio Avg Time = ${debugTimeList.audioDetail.avgTime.toString()}"),
                      _TextWidget(
                          text:
                              "Audio Max Time = ${debugTimeList.audioDetail.maxTime.toString()}"),
                      _TextWidget(
                          text:
                              "Audio Min Time = ${debugTimeList.audioDetail.minTime.toString()}")
                    ],
                  )
                : SizedBox()
          ],
        );
      }
      return const SizedBox.shrink();
    });
  }
}

class _TextWidget extends StatelessWidget {
  const _TextWidget({super.key, required this.text});
  final String text;
  @override
  Widget build(BuildContext context) {
    return Text(
      text,
      style: SoftwareTextStyle().kWtMediumTextStyle,
    );
  }
}

----- END ./lib/screen/debug_data.dart -----

----- BEGIN ./lib/screen/graph_page_widget/sound_wave_view.dart -----
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:spikerbox_architecture/provider/provider_export.dart';
import 'package:spikerbox_architecture/screen/spiker_box_ui.dart';
import 'package:spikerbox_architecture/widget/spiker_box_button.dart';

class SoundWaveView extends StatefulWidget {
  const SoundWaveView({
    super.key,
  });

  @override
  State<SoundWaveView> createState() => _SoundWaveViewState();
}

class _SoundWaveViewState extends State<SoundWaveView> {
  @override
  Widget build(BuildContext context) {
    EnvelopConfigProvider envelopConfig = context.read<EnvelopConfigProvider>();

    return Listener(
      onPointerSignal: (PointerSignalEvent event) {
        if (event is PointerScrollEvent) {
          Provider.of<GraphDataProvider>(context, listen: false)
              .setScrollIndex(event.scrollDelta.dy, envelopConfig);
        }
      },
      child: GestureDetector(
        onScaleUpdate: (ScaleUpdateDetails details) {
          double scale = details.scale;
          if (scale > 1) {
            scale = 1 / scale;
            // print("the scale is $scale");
          } else if (scale < 1) {
            scale = -scale;
            // print("the scale is decreasing $scale");
          }
          // For panning left to right
          // else {
          //   if (details.focalPointDelta.dx > 0) {
          //     print("Panning right");
          //   } else if (details.focalPointDelta.dx < 0) {
          //     print("Panning left");
          //   }
          //   return;
          // }
          Provider.of<GraphDataProvider>(context, listen: false)
              .setScrollIndex(scale * 10, envelopConfig);
        },
        child: const SpikerBoxUi(),
      ),
    );
  }
}

class BottomButtons extends StatefulWidget {
  const BottomButtons({
    super.key,
    required this.pauseButton,
  });

  final Function(bool isPlay) pauseButton;

  @override
  State<BottomButtons> createState() => _BottomButtonsState();
}

class _BottomButtonsState extends State<BottomButtons> {
  @override
  Widget build(BuildContext context) {
    bool isGraphStatus = context.read<GraphResumePlayProvider>().graphStatus;

    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        SpikerBoxButton(
          padding: const EdgeInsets.all(5),
          iconSize: 20,
          iconData: Icons.refresh,
          onTapButton: () {
            context.read<GraphDataProvider>().resetGraphBuffer();
          },
        ),
        const SizedBox(
          width: 15,
        ),
        SpikerBoxButton(
          padding: const EdgeInsets.all(10),
          iconSize: 40,
          iconData: isGraphStatus ? Icons.pause : Icons.play_arrow,
          onTapButton: () {
            isGraphStatus = !isGraphStatus;

            widget.pauseButton(isGraphStatus);
            setState(() {});
          },
        ),
        const SizedBox(
          width: 15,
        ),
        SpikerBoxButton(
          padding: const EdgeInsets.all(5),
          iconSize: 20,
          iconData: Icons.keyboard_tab,
          onTapButton: () {},
        ),
      ],
    );
  }
}

----- END ./lib/screen/graph_page_widget/sound_wave_view.dart -----

----- BEGIN ./lib/screen/graph_template.dart -----
import 'dart:async';
import 'dart:io';
import 'dart:typed_data';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter/services.dart';
import 'package:native_add/model/enveloping_data/enveloping_config.dart';
import 'package:native_add/model/model.dart';
import 'package:provider/provider.dart';
import 'package:spikerbox_architecture/constant/const_export.dart';
import 'package:spikerbox_architecture/functionality/functionality_export.dart';
import 'package:spikerbox_architecture/message_identifier.dart';
import 'package:spikerbox_architecture/models/models.dart';
import 'package:spikerbox_architecture/screen/screen_export.dart';
import 'package:spikerbox_architecture/screen/setting_page.dart';
import '../provider/provider_export.dart';
import 'graph_page_widget/sound_wave_view.dart';
import 'package:spikerbox_architecture/models/microphone_stream/microphone_stream_check.dart';

class GraphTemplate extends StatefulWidget {
  const GraphTemplate({
    super.key,
    required this.constantProvider,
  });
  final ConstantProvider constantProvider;

  @override
  State<GraphTemplate> createState() => _GraphTemplateState();
}

class _GraphTemplateState extends State<GraphTemplate> {
  List<String> _availablePorts = [];
  MicrophoneUtil microphoneUtil = MicrophoneUtil();
  final StreamController<Uint8List> _graphStreamController = StreamController();
  late Stream<Uint8List> _graphStream;
  FilterSetup? filterBaseSettingsModel;
  DebugTimeProvider debugTimeCalculate = DebugTimeProvider();

  /// Converting bytes to uint as per custom protocol
  late BitwiseUtil _bitwiseUtil;
  DeviceStatusFunctionality deviceStatusFunctionality =
      DeviceStatusFunctionality();

  /// Only pauses the graph
  bool _toPauseGraph = true;

  /// Accesses the serial port on multiple platforms
  late final BufferHandler _preGraphBuffer;

  late final BufferHandler _preprocessingBuffer;

  final List<int> _residualBuffer = [];

  int _channelBytes = 0;
  late final MessageIdentifier _messageIdentifier;

  // For audio data
  static const int _sampleGeneratedCount = 1000;
  static const int timeMs = _sampleGeneratedCount ~/ dummySamplingRate * 1000;
  late final Uint8List _sampleData;

  @override
  void didUpdateWidget(covariant GraphTemplate oldWidget) {
    super.didUpdateWidget(oldWidget);
    SchedulerBinding.instance.addPostFrameCallback((_) {
      frameDetect = FrameDetect(
          channelCount: widget.constantProvider.getChannelCount(),
          minimumBytesToCheck: 50);
      _bitwiseUtil =
          BitwiseUtil(bitCount: widget.constantProvider.getBitData());
      _channelBytes = widget.constantProvider.getChannelCount() * 2;
    });
  }

  bool sampleRateSet = false;
  bool isAudioListen = false;
  Stopwatch timeTaken = Stopwatch();
  int dummyCount = 0;

  @override
  void initState() {
    super.initState();
    if (!kIsWeb) {
      SchedulerBinding.instance.addPostFrameCallback((_) async {
        setSampleRate();
      });
    }
    if (!kIsWeb) {
      _startPortCheck();
    }

    Provider.of<GraphResumePlayProvider>(context, listen: false)
        .getStream()
        .listen((event) {
      _toPauseGraph = event;
    });

    Future.delayed(const Duration(seconds: 2)).then((value) {
      microphoneUtil.init().then((value) {
        microphoneUtil.micStream!.listen((event) {
          if (!sampleRateSet) {
            setBufferSetting(webMicSampleRate);
            sampleRateSet = true;
          }

          // print("the length of ${event.length}");
          isAudioListen = context.read<DataStatusProvider>().isMicrophoneData;
          // print("the event is $event");
          // isAudioListen = value;

          if (isAudioListen) {
            _preprocessingBuffer.addBytes(event);
          }
        });
        // if (!kIsWeb) {
        //   microphoneUtil.packetAddDetail!.listen((event) {
        //     if (isAudioListen) {
        //       AudioDetail audioDetail = AudioDetail(
        //           avgTime: event.averageTime,
        //           maxTime: event.maxTime,
        //           minTime: event.minTime);
        //       context.read<DebugTimeProvider>().setAudioDetail(audioDetail);
        //     }
        //   });
        // }
      });
    });

    // TODO: remove dummy data
    _sampleData = GenerateSampleData.sineWaveUint14(
            samplingRate: dummySamplingRate,
            frequencies: [60],
            samplesGenerated: _sampleGeneratedCount)
        .buffer
        .asUint8List();

    Timer.periodic(const Duration(milliseconds: timeMs), (timer) {
      bool dummyDataStatus = context.read<DataStatusProvider>().isSampleDataOn;
      if (dummyDataStatus) {
        _preprocessingBuffer.addBytes(_sampleData);
      }
    });
    filterBaseSettingsModel = const FilterSetup(
        filterConfiguration:
            FilterConfiguration(cutOffFrequency: 1000, sampleRate: 10000),
        filterType: FilterType.highPassFilter,
        channelCount: channelCountBuffer,
        isFilterOn: false);
    EnvelopConfigProvider envelopConfig = context.read<EnvelopConfigProvider>();
    localPlugin.spawnHelperIsolate(envelopConfig).then(
      (value) {
        timeTaken.start();
        localPlugin.postFilterStream?.listen((event) {
          if (isDebugging) {
            context
                .read<DebugTimeProvider>()
                .addGraphTime(timeTaken.elapsedMicroseconds);
            timeTaken.reset();
          }

          passingDataToStream(
            event,
          );

          // _preGraphBuffer.addBytes(event);
        });
      },
    );

    localPlugin.initHighPassFilters(filterBaseSettingsModel!);

    _preprocessingBuffer = BufferHandler(
      chunkReadSize: 2000,
      onDataAvailable: (Uint8List listBytes) async {
        int bitData = context.read<ConstantProvider>().getBitData();
        DataStatusProvider dataStatusProvider =
            context.read<DataStatusProvider>();
        isDebugging = dataStatusProvider.isDebugging;

        Uint16List newDataPoints;
        Int16List int16list;
        List<int> newPoints;

        bool dummyDataStatus = dataStatusProvider.isSampleDataOn;
        bool isEnableAudio = dataStatusProvider.isMicrophoneData;
        if (dummyDataStatus) {
          newDataPoints = listBytes.buffer.asUint16List();
          newPoints = List.filled(newDataPoints.length, 0);
          for (int i = 0; i < newPoints.length; i++) {
            int a = 0;
            int e = newDataPoints[i];
            // a = e;
            switch (bitData) {
              case 14:
                a = e - 8192;
                // a = e;
                // print("value of a: $a, e: $e");
                break;

              case 10:
                a = (e * 30) - 15360; // (value - 512) * 30
                break;

              default:
                break;
            }
            newPoints[i] = a;
          }
        } else if (isEnableAudio) {
          int16list = dataToSamples(listBytes);

          newPoints = List.filled(int16list.length, 0);

          for (int i = 0; i < newPoints.length; i++) {
            newPoints[i] = int16list[i];
          }
        } else {
          int bitData = widget.constantProvider.getBitData();
          Uint8List transformedData = _bitwiseUtil.convertToValue(listBytes);
          newDataPoints = transformedData.buffer.asUint16List();
          newPoints = List.filled(newDataPoints.length, 0);

          for (int i = 0; i < newPoints.length; i++) {
            int a = 0;
            int e = newDataPoints[i];
            // a = e;

            switch (bitData) {
              case 14:
                a = e - 8192;
                // print("value of a: $a, e: $e");
                break;

              case 10:
                a = (e * 30) - 15360; // (value - 512) * 30
                break;

              default:
                break;
            }
            newPoints[i] = a;
          }
        }
        await localPlugin.filterArrayElements(
          array: newPoints,
          arrayLength: newPoints.length,
          channelIdx: 0,
        );
      },
    );

    frameDetect = FrameDetect(
        channelCount: widget.constantProvider.getChannelCount(),
        minimumBytesToCheck: 50);

    _bitwiseUtil = BitwiseUtil(bitCount: widget.constantProvider.getBitData());
    _channelBytes = widget.constantProvider.getChannelCount() * 2;

    _graphStream = _graphStreamController.stream.asBroadcastStream();
    final provider = Provider.of<GraphDataProvider>(context, listen: false);

    provider.setStreamOfData(_graphStream);
    _messageIdentifier = MessageIdentifier(onDeviceData: (Uint8List dt) {
      List<int> devData = dt;

      if (_residualBuffer.isNotEmpty) {
        devData = [..._residualBuffer, ...devData];
        _residualBuffer.clear();
      }
      List<int> frameCheckedData = [];
      int i = 0;

      while (i < devData.length) {
        if (i + _channelBytes >= devData.length) {
          _residualBuffer.addAll(devData.sublist(i, devData.length));
          break;
        }
        // To check that the data received follows the Custom Protocol
        bool frameComplete = true;

        if (frameComplete) {
          checkBytesLoop:
          for (int j = 1; j < _channelBytes; j++) {
            if (!(i + j < devData.length)) break checkBytesLoop;
            if (devData.elementAt(i + j) > 127) {
              // Remaining bytes in frame are missing
              // Debugging.printing(
              //     "Remaining frame bytes missing - ${devData.sublist(i)}");
              frameComplete = false;
              break checkBytesLoop;
            }
          }
        }
        if (frameComplete) {
          frameCheckedData.addAll(devData.sublist(i, i + _channelBytes));
          i += _channelBytes;
        } else {
          i++;
          // Debugging.printing("bytes drop detected");
        }
      }

      _preprocessingBuffer.addBytes(Uint8List.fromList(frameCheckedData));
    }, onDeviceMessage: (Uint8List msg) async {
      String responseMessage =
          MessageValueSet.fromUint8ListCommand(message: msg).value;
      String? devices = checkConnectedDevices(responseMessage);

      if (devices == null) {
        return;
      }

      SetUpFunctionality().setTheDeviceSetting(devices).then((value) {
        String foundDevices = "";
        if (value != null) {
          print("the found ${value.uniqueName} and  $devices");
          isDeviceConnect = true;
          foundDevices = value.uniqueName ?? "";
          context.read<PortScanProvider>().setDeviceList(foundDevices);
          widget.constantProvider
              .setBaudRate(foundDevices == "HHIBOX" ? 500000 : 222222);
          widget.constantProvider
              .setChannelCount(int.parse(value.maxNumberOfChannels.toString()));
          widget.constantProvider
              .setBitData(int.parse(value.sampleResolution.toString()));
          Provider.of<SampleRateProvider>(context, listen: false)
              .setSampleRate(int.parse(value.maxSampleRate.toString()));
          EnvelopConfigProvider envelopConfig =
              Provider.of<EnvelopConfigProvider>(context, listen: false);
          envelopConfig.firstTimeSet(
              int.parse(value.maxSampleRate.toString()), 120000);
          // Provider.of<GraphDataProvider>(context, listen: false)
          //     .setBufferLength(int.parse(value.maxSampleRate.toString()));

          SerialPortDataModel serialData = SerialPortDataModel(
              portCom: portName, deviceDetect: foundDevices);
          context.read<SerialDataProvider>().setPortOfDevices(serialData);

          deviceConnectedStream();
        }
      });
      Debugging.printing(
          "Message received from Spikerbox: \n\tbytes : $msg\n\tstring: ${String.fromCharCodes(msg)}");
    });

    preEscapeSequenceBuffer = BufferHandler(
      chunkReadSize: 16,
      onDataAvailable: (Uint8List dataFromBuffer) {
        _messageIdentifier.addPacket(dataFromBuffer);
      },
    );

    _preGraphBuffer = BufferHandler(
      chunkReadSize: kGraphUpdateCount * 2,
      onDataAvailable: (Uint8List dataFromBuffer) {
        if (kIsWeb) {
          switch (widget.constantProvider.getChannelCount()) {
            case 1:
              _graphStreamController.add(dataFromBuffer);
              break;
          }
        }
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    double pixelCount = MediaQuery.of(context).size.width;
    setPixel(pixelCount.toInt());
    return Scaffold(
      backgroundColor: SoftwareColors.kBackGroundColor,
      body: const _AdaptiveArea(
        child1: _GraphArea(),
        child3: SettingPage(),
        child2:

//            ElevatedButton(
//               onPressed: () async {
//                 final sampleRate =
//                     Provider.of<SampleRateProvider>(context, listen: false)
//                         .sampleRate;
//                 microphoneUtil.resetTheClass();
// // ignore: deprecated_member_use
//                 await localPlugin.resetPositioning();

//                 // EnvelopConfig envelopConfig =
//                 //     Provider.of<EnvelopConfig>(context, listen: false);
//                 // envelopConfig.firstTimeSet(sampleRate, 120000);
//               },
//               child: const Text("reset class"))
            SettingButtons(),
      ),
      floatingActionButton: kIsWeb
          ? FloatingActionButton.extended(
              elevation: 2,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(22),
                  side: const BorderSide(width: 2, color: Colors.grey)),
              backgroundColor: SoftwareColors.kButtonBackGroundColor,
              onPressed: () async {
                SerialUtil? _serialUtil = SerialUtil();
                try {
                  int baudRate = context.read<ConstantProvider>().getBaudRate();
                  await listenPort?.cancel();

                  await _serialUtil.getAvailablePorts(baudRate);
                  _availablePorts = _serialUtil.availablePorts;
                  print("the serial ports is $_availablePorts");
                  if (!mounted) return;
                  Provider.of<PortScanProvider>(context, listen: false)
                      .setPortScanList(_availablePorts);
                  context
                      .read<DataStatusProvider>()
                      .setMicrophoneDataStatus(false);

                  // await _serialUtil.openPortToListen(
                  //     _availablePorts.first, baudRate);

                  if (!mounted) return;
                  bool dummyDataStatus =
                      context.read<DataStatusProvider>().isSampleDataOn;
                  bool isAudioListen =
                      context.read<DataStatusProvider>().isMicrophoneData;
                  // _serialUtil.deviceConnectWithPort();
                  listenPort = _serialUtil.dataStream?.listen((event) {
                    if (!dummyDataStatus && !isAudioListen) {
                      preEscapeSequenceBuffer.addBytes(event);
                      if (!isDeviceConnect) {
                        serialUtil.writeToPort(
                            bytesMessage: UsbCommand.hwTypeInquiry.cmdAsBytes(),
                            address: _availablePorts.last);
                        isDeviceConnect = true;
                      }

                      if (isDataIdentified) {
                        // Debugging.printing('us: ${stopwatch.elapsedMicroseconds}, length : ${event.length}');
                        // stopwatch.reset();
                      } else {
                        Uint8List? firstFrameData = frameDetect.addData(event);

                        if (firstFrameData != null) {
                          preEscapeSequenceBuffer.addBytes(firstFrameData);
                          isDataIdentified = true;
                        }
                      }
                    }
                  });
                } catch (e) {
                  Debugging.printing("Opening port failed:\n$e");
                }

                // setState(() {});
              },
              label: Row(
                children: [
                  Text(
                    "Scan port",
                    style: SoftwareTextStyle().kBkMediumTextStyle,
                  ),
                  Icon(
                    Icons.refresh,
                    color: SoftwareColors.kButtonColor,
                  )
                ],
              ),
            )
          : Container(),
    );
  }

  static Int16List dataToSamples(Uint8List data) {
    final Int16List int16Samples = Int16List(data.length ~/ 2);
    final ByteBuffer byteBuffer = data.buffer;
    final ByteData byteData = data.buffer.asByteData();

    for (int i = 0; i < byteBuffer.lengthInBytes; i += 2) {
      int16Samples[i ~/ 2] = byteData.getInt16(i, Endian.little);
    }

    return int16Samples;
  }

  bool containsUint8List(Uint8List mainList, Uint8List subList) {
    if (mainList.length < subList.length) {
      return false; // The main list is shorter, so it can't contain the sublist.
    }

    for (int i = 0; i <= mainList.length - subList.length; i++) {
      bool found = true;

      for (int j = 0; j < subList.length; j++) {
        if (mainList[i + j] != subList[j]) {
          found = false;
          break;
        }
      }

      if (found) {
        return true; // Sublist found within the main list.
      }
    }

    return false; // Sublist not found within the main list.
  }

  // FilterSettings filterBase = FilterSettings();
  final TextEditingController sampleRateController = TextEditingController();
  final TextEditingController cutOffController = TextEditingController();

  String? checkConnectedDevices(String getResponse) {
    List<String> listOfDevices = [
      "PLANTSS;",
      "MUSCLESS;",
      "HEARTSS;",
      "HBLEOSB;",
      "HUMANSB;",
      "MSBPCDC;",
      "NSBPCDC;",
      "NRNSBPRO;",
      "HHIBOX;"
    ];

    int index = listOfDevices.indexWhere((element) => element == getResponse);
    if (index == -1) return null;
    return listOfDevices[index];
  }

  String portName = "";
  bool isDeviceConnect = false;
  bool isSettingEnable = false;
  bool isDebugging = false;

  void passingDataToStream(Uint8List uint8list) {
    if (_toPauseGraph) {
      switch (widget.constantProvider.getChannelCount()) {
        case 1:
          _graphStreamController.add(uint8list);
          break;

        case 2:
          // TODO: only first channel data is being passed, ie, the first two bytes
          _graphStreamController
              .add(ChannelUtil.dropEveryOtherTwoBytes(uint8list));
          break;
      }
    }
  }

  void setPixel(int pixelCount) {
    EnvelopConfigProvider envelopConfig =
        Provider.of<EnvelopConfigProvider>(context, listen: false);
    EnvelopingConfig envelopConfigFromLocalPackage = EnvelopingConfig();

    envelopConfigFromLocalPackage.setConfig(
        pixelCount: pixelCount, bufferSize: envelopConfig.bufferSize);
  }

  void deviceConnectedStream() {
    SerialDataProvider serialDataProvider = context.read<SerialDataProvider>();

    List<SerialPortDataModel> allDevices = serialDataProvider.getAllPortDetail;
    List<String> connectedDevices = [];
    connectedDevices = List.from(context.read<PortScanProvider>().deviceList);

    Set<String> uniqueDevices = Set.from(connectedDevices);
    //  Convert the Set back to a List
    List<String> uniqueConnectedDevices = List.from(uniqueDevices);

    deviceStatusFunctionality.connectDeviceList(
        uniqueConnectedDevices, allDevices, serialDataProvider);
  }

  Future<void> _startPortCheck() async {
    Timer.periodic(const Duration(seconds: 3), (timer) async {
      SampleRateProvider sampleRateProvider =
          context.read<SampleRateProvider>();

      await serialUtil.getAvailablePorts(widget.constantProvider.getBaudRate());
      if (serialUtil.availablePorts.isEmpty) {
        isDeviceConnect = false;
        return;
      }

      List<String> filteredPorts;
      if (Platform.isMacOS) {
        filteredPorts = serialUtil.availablePorts
            .where((port) =>
                port.contains('usbmodem') || port.contains('usbserial'))
            .toList();
      } else {
        filteredPorts = serialUtil.availablePorts;
      }
      bool isComMatch = areListsEqual(_availablePorts, filteredPorts);
      _availablePorts = filteredPorts;
// All time getting true
      if (!mounted) {
        return;
      }
      context
          .read<DataStatusProvider>()
          .setMicrophoneDataStatus(_availablePorts.isEmpty);

      if (isComMatch == false) {
        await serialUtil.deviceConnectWithPort(
            sampleRateProvider, widget.constantProvider);
        isDeviceConnect = false;
        Provider.of<PortScanProvider>(context, listen: false)
            .setPortScanList(_availablePorts);
        Provider.of<ConstantProvider>(context, listen: false)
            .setBaudRate(widget.constantProvider.getBaudRate());
        await portListOnConnect();
      }
    });
  }

  bool areListsEqual(List<String> list1, List<String> list2) {
    if (list1.length > list2.length) {
      List<SerialPortDataModel> allDevices =
          List.from(context.read<SerialDataProvider>().getAllPortDetail);

      allDevices.removeWhere((element) => !list2.contains(element.portCom));
      Debugging.printing(
          "the element is remove  left${allDevices.map((e) => e.portCom)}");
      List<String> connectDevice =
          List.from(context.read<PortScanProvider>().deviceList);
      connectDevice.removeWhere(
          (element) => allDevices.any((e) => e.deviceDetect != element));

      for (SerialPortDataModel element in allDevices) {
        context.read<SerialDataProvider>().setPortOfDevices(element);
      }
      List<ComDataWithBoard> deviceComWithData =
          List.from(context.read<SerialDataProvider>().deviceWithComData);
      deviceComWithData.removeWhere((element) =>
          !connectDevice.contains(element.connectDevices.uniqueName));

// Step 2: Create a new list without the removed elements
      List<ComDataWithBoard> updatedDeviceComWithData =
          List.from(deviceComWithData);

      Debugging.printing(
          "the updated List deviceComWithData  ${updatedDeviceComWithData.map((e) => e.connectDevices.uniqueName)}");

      // context
      //     .read<SerialDataProvider
// Step 3: Iterate over the updated list and perform necessary actions
      context
          .read<SerialDataProvider>()
          .setDeviceWithComData(updatedDeviceComWithData);
      return true;
    }
    if (list1.length != list2.length) {
      return false;
    }

    for (int i = 0; i < list1.length; i++) {
      if (list1[i] != list2[i]) {
        return false;
      }
    }

    return true;
  }

  void setSampleRate() {
    if (Platform.isWindows) {
      setBufferSetting(winMicSampleRate);
    } else if (Platform.isAndroid) {
      setBufferSetting(androidMicSampleRate);
    } else if (Platform.isMacOS) {
      setBufferSetting(macMicSampleRate);
    }
  }

  void setBufferSetting(int sampleRate) {
    final myDataProvider =
        Provider.of<SampleRateProvider>(context, listen: false);
    EnvelopConfigProvider envelopConfig =
        Provider.of<EnvelopConfigProvider>(context, listen: false);

    if (microphoneUtil.sampleRateFromWeb != 0) {
      print(("the sampleRate set is ${microphoneUtil.sampleRateFromWeb}"));
      myDataProvider.setSampleRate(microphoneUtil.sampleRateFromWeb);
    } else {
      myDataProvider.setSampleRate(sampleRate);
    }

    int duration = 120 * 1000;

    print("the sample rate before enveloping  ${sampleRate} and duration  ");
    envelopConfig.firstTimeSet(sampleRate, duration);

    // final dataStatusProvider =
    //     Provider.of<GraphDataProvider>(context, listen: false);
    // dataStatusProvider.setBufferLength(webMicSampleRate * 30);
  }

  Future<void> portListOnConnect() async {
    DataStatusProvider dataStatus = context.read<DataStatusProvider>();
    List<String> listOfPort =
        Provider.of<PortScanProvider>(context, listen: false).availablePorts;
    int baudRate = context.read<ConstantProvider>().getBaudRate();
    if (listOfPort.isEmpty) {
      return;
    }
    Stream<Uint8List>? getData =
        await serialUtil.openPortToListen(listOfPort.last, baudRate);

    bool dummyDataStatus = dataStatus.isSampleDataOn;
    bool isAudioListen = dataStatus.isMicrophoneData;
    dataStatus.setDeviceDataStatus(true);

    await listenPort?.cancel();
    Stopwatch stopwatch = Stopwatch();

    listenPort = getData?.listen((event) {
      stopwatch.start();
      if (!dummyDataStatus && !isAudioListen) {
        preEscapeSequenceBuffer.addBytes(event);
        // print(
        //     "the time taken is ${stopwatch.elapsedMilliseconds}and the length ${event.length}");

        if (!isDeviceConnect) {
          serialUtil.writeToPort(
              bytesMessage: UsbCommand.hwTypeInquiry.cmdAsBytes(),
              address: listOfPort.last);

          isDeviceConnect = true;
        }
        if (isDataIdentified) {
          // Debugging.printing('us: ${stopwatch.elapsedMicroseconds}, length : ${event.length}');
          // stopwatch.reset();
        } else {
          Uint8List? firstFrameData = frameDetect.addData(event);

          if (firstFrameData != null) {
            preEscapeSequenceBuffer.addBytes(firstFrameData);
            isDataIdentified = true;
          }
        }
      }
    });
    portName = listOfPort.last;
  }
}

class SetFrequencyWidget extends StatefulWidget {
  const SetFrequencyWidget({
    super.key,
    required this.frequencyType,
    required this.frequencyValue,
    required this.frequencyEditController,
    required this.onStringChanged,
  });
  final int frequencyValue;
  final TextEditingController frequencyEditController;
  final String frequencyType;
  final Function(String) onStringChanged;

  @override
  State<SetFrequencyWidget> createState() => _SetFrequencyWidgetState();
}

class _SetFrequencyWidgetState extends State<SetFrequencyWidget> {
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text(
          widget.frequencyType,
          style: SoftwareTextStyle().kWtMediumTextStyle,
        ),
        SizedBox(
          width: 50,
          height: 35,
          child: DecoratedBox(
              decoration: BoxDecoration(
                  border: Border.all(width: 1, color: Colors.white)),
              child: Center(
                child: TextFormField(
                  textAlign: TextAlign.center,
                  maxLines: 1,
                  inputFormatters: [
                    FilteringTextInputFormatter.allow(RegExp(r'[0-9]')),
                  ],
                  onChanged: widget.onStringChanged,
                  decoration: const InputDecoration(
                    contentPadding: EdgeInsets.all(2),
                    border: InputBorder.none,
                  ),
                  style: SoftwareTextStyle().kWtMediumTextStyle,
                  controller: widget.frequencyEditController,
                ),
              )),
        )
      ],
    );
  }
}

class _AdaptiveArea extends StatefulWidget {
  const _AdaptiveArea(
      {required this.child1, required this.child3, required this.child2});

  final Widget child1;
  final Widget child2;
  final Widget child3;

  @override
  State<_AdaptiveArea> createState() => _AdaptiveAreaState();
}

class _AdaptiveAreaState extends State<_AdaptiveArea> {
  @override
  Widget build(BuildContext context) {
    return SizedBox.expand(
      child: Stack(
        children: [
          widget.child1,
          StreamListenerWidget(child2: widget.child2),
          DeviceSettingConfiguration(
            child3: widget.child3,
          )
        ],
      ),
    );
  }
}

class StreamListenerWidget extends StatefulWidget {
  const StreamListenerWidget({super.key, required this.child2});

  final Widget child2;

  @override
  State<StreamListenerWidget> createState() => _StreamListenerWidgetState();
}

class _StreamListenerWidgetState extends State<StreamListenerWidget> {
  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 15),
      child: widget.child2,
    );
  }
}

class DeviceSettingConfiguration extends StatefulWidget {
  const DeviceSettingConfiguration({super.key, required this.child3});

  final Widget child3;

  @override
  State<DeviceSettingConfiguration> createState() =>
      _DeviceSettingConfigurationState();
}

class _DeviceSettingConfigurationState
    extends State<DeviceSettingConfiguration> {
  @override
  Widget build(BuildContext context) {
    return Consumer<SoftwareConfigProvider>(
        builder: (context, softwareSetting, snapshot) {
      if (softwareSetting.isSettingEnable) {
        return Container(
          color: Colors.black54.withOpacity(0.9),
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 15),
            child: widget.child3,
          ),
        );
      }
      return const SizedBox.shrink();
    });
  }
}

class _GraphArea extends StatefulWidget {
  const _GraphArea();

  // final Function(bool isPlay) onPause;

  @override
  State<_GraphArea> createState() => _GraphAreaState();
}

class _GraphAreaState extends State<_GraphArea> {
  List<String> listOfFrequency = ["40 Hz", "30 Hz", "20 Hz", "10 Hz"];
  @override
  Widget build(BuildContext context) {
    return const Column(
      children: [
        Expanded(
          flex: 6,
          child: SoundWaveView(),
        ),
      ],
    );
  }
}

----- END ./lib/screen/graph_template.dart -----

----- BEGIN ./lib/screen/page_route_screen.dart -----
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:spikerbox_architecture/screen/admin_dashboard_screen/admin_screen.dart';
import 'package:spikerbox_architecture/screen/graph_template.dart';

import '../provider/devices_provider.dart';
import '../widget/custom_button.dart';

class DashBoardPageRoute extends StatefulWidget {
  const DashBoardPageRoute({super.key});

  @override
  State<DashBoardPageRoute> createState() => _DashBoardPageRouteState();
}

class _DashBoardPageRouteState extends State<DashBoardPageRoute> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      appBar: AppBar(
        title: const Text("Backyard Brains"),
      ),
      body: Center(
        child: Column(
          children: [
            SizedBox(
              height: 250,
              width: 250,
              child: Image.asset("assets/spiker_logo.jpeg"),
            ),
            Padding(
              padding: const EdgeInsets.all(8.0),
              child: CustomButton(
                onTap: () {
                  Navigator.push(
                    context,
                    MaterialPageRoute(
                        builder: (context) => const DashBoardPannel()),
                  );
                },
                childWidget: const Text("Download Prototypes"),
              ),
            ),
            Consumer<ConstantProvider>(builder: (context, data, child) {
              return Padding(
                padding: const EdgeInsets.all(8.0),
                child: CustomButton(
                  onTap: () {
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) {
                          return GraphTemplate(
                            constantProvider: data,
                          );
                        },
                      ),
                    );
                  },
                  childWidget: const Text("Web application"),
                ),
              );
            })
          ],
        ),
      ),
    );
  }
}

----- END ./lib/screen/page_route_screen.dart -----

----- BEGIN ./lib/screen/screen_export.dart -----
export "page_route_screen.dart";
export 'graph_template.dart';
export 'debug_data.dart';
export 'spiker_box_ui.dart';
export 'admin_dashboard_screen/admin_screen.dart';
export 'setting_buttons.dart';

----- END ./lib/screen/screen_export.dart -----

----- BEGIN ./lib/screen/seria_package.dart -----
// ignore_for_file: avoid_web_libraries_in_flutter

import 'dart:async';
import 'dart:html';
import 'dart:typed_data';
import 'package:flutter/material.dart';

import 'package:serial/serial.dart';

class HomePage extends StatefulWidget {
  const HomePage({Key? key}) : super(key: key);

  @override
  State<HomePage> createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> {
  SerialPort? _port;
  final _received = <Uint8List>[];

  final _controller1 = TextEditingController();

  Future<void> _openPort() async {
    await _port?.close();

    final port = await window.navigator.serial.requestPort();
    await port.open(
        baudRate: 500000,
        dataBits: DataBits.eight,
        stopBits: StopBits.one,
        bufferSize: 8192);

    _port = port;

    _startReceiving(port);

    setState(() {});
  }

  Future<void> _writeToPort(Uint8List data) async {
    if (data.isEmpty) {
      return;
    }

    final port = _port;

    if (port == null) {
      return;
    }

    final writer = port.writable.writer;

    await writer.ready;
    await writer.write(data);

    await writer.ready;
    await writer.close();
  }

  Future<void> _startReceiving(SerialPort port) async {
    final reader = port.readable.reader;

    while (true) {
      final result = await reader.read();
      _received.add(result.value);

      setState(() {});
    }
  }

  @override
  Widget build(BuildContext context) {
    //final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Serial Port'),
        actions: [
          IconButton(
            onPressed: _openPort,
            icon: Icon(Icons.device_hub),
            tooltip: 'Open Serial Port',
          ),
          IconButton(
            onPressed: _port == null
                ? null
                : () async {
                    await _port?.close();
                    _port = null;

                    setState(() {});
                  },
            icon: Icon(Icons.close),
            tooltip: 'Close Serial Port',
          ),
        ],
      ),
      body: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Expanded(
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 8.0),
              child: Container(
                decoration: BoxDecoration(
                  border: Border.all(color: Colors.white54),
                  borderRadius: BorderRadius.circular(4),
                ),
                child: _received.isNotEmpty
                    ? ListView(
                        padding: const EdgeInsets.all(4),
                        children: _received.map((e) {
                          final text = String.fromCharCodes(e);
                          return Padding(
                            padding: const EdgeInsets.all(4.0),
                            child: Text(text),
                          );
                        }).toList(),
                      )
                    : Center(
                        child: Text(
                        'No data received yet.',
                        textAlign: TextAlign.center,
                      )),
              ),
            ),
          ),
          Padding(
            padding: const EdgeInsets.all(4.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Padding(
                  padding: const EdgeInsets.all(4.0),
                  child: TextFormField(
                    controller: _controller1,
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.all(4.0),
                  child: ElevatedButton(
                    child: const Text('Send'),
                    onPressed: () {
                      _writeToPort(
                          Uint8List.fromList(_controller1.text.codeUnits));
                    },
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

----- END ./lib/screen/seria_package.dart -----

----- BEGIN ./lib/screen/setting_buttons.dart -----
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:spikerbox_architecture/functionality/device_functionality/device_status_functionality.dart';
import 'package:spikerbox_architecture/screen/graph_page_widget/sound_wave_view.dart';

import '../models/models.dart';
import '../provider/provider_export.dart';
import '../widget/widget_export.dart';

class SettingButtons extends StatefulWidget {
  const SettingButtons({super.key});

  @override
  State<SettingButtons> createState() => _SettingButtonsState();
}

class _SettingButtonsState extends State<SettingButtons> {
  DeviceStatusFunctionality deviceStatusFunctionality =
      DeviceStatusFunctionality();

  bool isDeviceConnect = true;
  @override
  Widget build(BuildContext context) {
    ConstantProvider constantProvider = Provider.of<ConstantProvider>(context);
    return Column(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisAlignment: MainAxisAlignment.start,
              children: [
                SpikerBoxButton(
                    onTapButton: () async {
                      context
                          .read<SoftwareConfigProvider>()
                          .settingStatus(true);
                    },
                    iconData: Icons.settings),
                const SizedBox(
                  width: 10,
                ),
                // SpikerBoxButton(
                //     onTapButton: () async {}, iconData: Icons.graphic_eq),
                // const SizedBox(
                //   width: 10,
                // ),
                SpikerBoxButton(
                  iconColor: Colors.blue,
                  onTapButton: () {},
                  iconData: Icons.graphic_eq_outlined,
                ),
                const SizedBox(
                  width: 10,
                ),

                Consumer<SerialDataProvider>(
                  builder: (context, connectedDevices, snapshot) {
                    if (connectedDevices.deviceWithComData.isNotEmpty) {
                      List<ComDataWithBoard> listOfBoard =
                          connectedDevices.deviceWithComData;

                      return SizedBox(
                        height: 50,
                        child: ListView.builder(
                            padding: EdgeInsets.zero,
                            scrollDirection: Axis.horizontal,
                            shrinkWrap: true,
                            itemCount: listOfBoard.length,
                            itemBuilder: (context, index) {
                              // int enableDevice = listOfBoard.length - 1;
                              return Padding(
                                padding: const EdgeInsets.only(left: 8.0),
                                child: SpikerBoxButton(
                                    // deviceOn: index == enableDevice,
                                    onTapButton: () async {
                                      DataStatusProvider dataStatus =
                                          context.read<DataStatusProvider>();

                                      bool dummyDataStatus =
                                          dataStatus.isSampleDataOn;
                                      bool isAudioListen =
                                          dataStatus.isMicrophoneData;

                                      // print(
                                      //     "the enable index is $enableDevice and $index");
                                      // enableDevice = index;
                                      int baudRate = listOfBoard[index]
                                                  .connectDevices
                                                  .uniqueName ==
                                              "HHIBOX"
                                          ? 500000
                                          : 222222;
                                      constantProvider.setBaudRate(baudRate);
                                      constantProvider.setChannelCount(
                                          int.parse(listOfBoard[index]
                                              .connectDevices
                                              .maxNumberOfChannels
                                              .toString()));
                                      constantProvider.setBitData(int.parse(
                                          listOfBoard[index]
                                              .connectDevices
                                              .sampleResolution
                                              .toString()));

                                      await deviceStatusFunctionality
                                          .listenDevice(
                                        dummyDataStatus,
                                        isAudioListen,
                                        listOfBoard[index]
                                            .serialPortData
                                            .portCom,
                                        baudRate,
                                      );
                                    },
                                    iconData: Icons.usb),
                              );
                            }),
                      );
                    } else {
                      return Container();
                    }
                  },
                ),
              ],
            ),
            Row(
              children: [
                SpikerBoxButton(
                  onTapButton: () {},
                  iconData: Icons.fiber_manual_record,
                  iconColor: Colors.red,
                ),
                const SizedBox(
                  width: 10,
                ),
                SpikerBoxButton(onTapButton: () {}, iconData: Icons.menu)
              ],
            )
          ],
        ),
        BottomButtons(
          pauseButton: (bool isPlay) {
            Provider.of<GraphResumePlayProvider>(context, listen: false)
                .setGraphResumePlay(isPlay);
          },
        ),
      ],
    );
  }
}

----- END ./lib/screen/setting_buttons.dart -----

----- BEGIN ./lib/screen/setting_page.dart -----
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:native_add/model/model.dart';
import 'package:provider/provider.dart';
import 'package:spikerbox_architecture/constant/const_export.dart';
import 'package:spikerbox_architecture/models/global_buffer.dart';
import 'package:spikerbox_architecture/models/models.dart';
import 'package:spikerbox_architecture/provider/provider_export.dart';
import 'package:spikerbox_architecture/screen/screen_export.dart';

import '../widget/widget_export.dart';

class SettingPage extends StatefulWidget {
  const SettingPage({
    super.key,
  });

  @override
  State<SettingPage> createState() => _SettingPageState();
}

class _SettingPageState extends State<SettingPage> {
  final List<int> _dataBit = [14, 10];
  final List<int> _baudRate = [222222, 230400, 500000];
  final List<int> _channelCount = [1, 2];
  bool isDeviceConnect = true;

  @override
  Widget build(BuildContext context) {
    ConstantProvider constantProvider = Provider.of<ConstantProvider>(context);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        Row(
          children: [
            SpikerBoxButton(
              onTapButton: () {
                context.read<SoftwareConfigProvider>().settingStatus(false);
              },
              iconData: Icons.settings,
            ),
          ],
        ),
        Expanded(
          child: ConstrainedBox(
            constraints: const BoxConstraints(
              maxWidth: 500,
            ),
            child: Column(
              children: [
                CustomSliderBarButton(
                  isMicrophoneEnable: (bool isMicrophoneEnable) {
                    context
                        .read<DataStatusProvider>()
                        .setMicrophoneDataStatus(isMicrophoneEnable);
                  },
                  onHighPassFilterSetup: (FilterSetup filterSetup) {
                    localPlugin.initHighPassFilters(filterSetup);
                  },
                  onLowPassFilterSetup: (FilterSetup filterSetup) {
                    localPlugin.initLowPassFilters(filterSetup);
                  },
                  onSampleChange: (bool isSampleDataOn) {
                    context
                        .read<DataStatusProvider>()
                        .setSampleDataStatus(isSampleDataOn);
                    // _toGenerateDummyData =
                    //     isSampleDataOn;
                  },
                ),
                const SizedBox(
                  height: 10,
                ),
                NotchPassFilterWidget(
                  onTapNotchFrequency: (notchFilterSettings) {
                    context
                        .read<DataStatusProvider>()
                        .setNotchPassFilterSetting(notchFilterSettings);
                    localPlugin.initNotchFilters(notchFilterSettings);
                  },
                ),
                const SizedBox(
                  height: 10,
                ),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.center,
                    children: [
                      Expanded(
                        flex: 1,
                        child: SingleChildScrollView(
                          child: Column(
                            children: [
                              FilterProcessWidget(
                                  onTapDebugging: (bool debuggingStatus) {
                                // isDebugging = debuggingStatus;
                              }, isMicrophoneEnable: (bool isMicrophoneEnable) {
                                context
                                    .read<DataStatusProvider>()
                                    .setMicrophoneDataStatus(
                                        isMicrophoneEnable);
                              }, onSampleChange: (bool isSampleDataOn) {
                                context
                                    .read<DataStatusProvider>()
                                    .setSampleDataStatus(isSampleDataOn);
                                // _toGenerateDummyData =
                                //     isSampleDataOn;
                              }),
                              DropdownButtonFormField<int>(
                                dropdownColor:
                                    SoftwareColors.kDropDownBackGroundColor,
                                style: SoftwareTextStyle().kWtMediumTextStyle,
                                items: _dataBit
                                    .map(
                                      (e) => DropdownMenuItem(
                                        value: e,
                                        child: Text(
                                          e.toString(),
                                        ),
                                      ),
                                    )
                                    .toList(),
                                onChanged: (int? bitDataSelect) {
                                  constantProvider.setBitData(bitDataSelect!);
                                },
                                value: constantProvider.getBitData(),
                              ),
                              DropdownButtonFormField(
                                dropdownColor:
                                    SoftwareColors.kDropDownBackGroundColor,
                                style: SoftwareTextStyle().kWtMediumTextStyle,
                                items: _baudRate
                                    .map(
                                      (e) => DropdownMenuItem(
                                        value: e,
                                        child: Text(
                                          e.toString(),
                                        ),
                                      ),
                                    )
                                    .toList(),
                                onChanged: (baudRateSelect) {
                                  constantProvider.setBaudRate(baudRateSelect!);
                                },
                                value: constantProvider.getBaudRate(),
                              ),
                              DropdownButtonFormField(
                                dropdownColor:
                                    SoftwareColors.kDropDownBackGroundColor,
                                style: SoftwareTextStyle().kWtMediumTextStyle,
                                items: _channelCount
                                    .map(
                                      (e) => DropdownMenuItem(
                                        value: e,
                                        child: Text(
                                          e.toString(),
                                        ),
                                      ),
                                    )
                                    .toList(),
                                onChanged: (int? channelCountSelect) {
                                  constantProvider
                                      .setChannelCount(channelCountSelect!);
                                },
                                value: constantProvider.getChannelCount(),
                              ),
                              const DebugTheDataDetail()
                            ],
                          ),
                        ),
                      ),
                      Expanded(
                          flex: 1,
                          child: kIsWeb
                              ? Consumer<PortScanProvider>(
                                  builder: (context, portList, snapshot) {
                                  // print(
                                  //     "the length of port is ${portList.availablePorts.length}");
                                  if (portList.availablePorts.isEmpty) {
                                    return const SizedBox.shrink();
                                  } else {
                                    return _PortsArea(
                                      deviceName: portList.availablePorts.first,
                                      availablePorts: portList.availablePorts,
                                      onReceive: (String add) async {
                                        int baudRate = context
                                            .read<ConstantProvider>()
                                            .getBaudRate();

                                        serialUtil.openPortToListen(
                                            add, baudRate);
                                        context
                                            .read<DataStatusProvider>()
                                            .setMicrophoneDataStatus(false);

                                        if (!mounted) return;
                                        bool dummyDataStatus = context
                                            .read<DataStatusProvider>()
                                            .isSampleDataOn;
                                        bool isAudioListen = context
                                            .read<DataStatusProvider>()
                                            .isMicrophoneData;

                                        try {
                                          serialUtil.dataStream
                                              ?.listen((event) {
                                            if (!dummyDataStatus &&
                                                !isAudioListen) {
                                              preEscapeSequenceBuffer
                                                  .addBytes(event);
                                              if (isDeviceConnect) {
                                                serialUtil.writeToPort(
                                                    bytesMessage: UsbCommand
                                                        .hwTypeInquiry
                                                        .cmdAsBytes(),
                                                    address: add);

                                                isDeviceConnect = false;
                                              }
                                              if (isDataIdentified) {
                                                // Debugging.printing('us: ${stopwatch.elapsedMicroseconds}, length : ${event.length}');
                                                // stopwatch.reset();
                                              } else {
                                                Uint8List? firstFrameData =
                                                    frameDetect.addData(event);

                                                if (firstFrameData != null) {
                                                  preEscapeSequenceBuffer
                                                      .addBytes(firstFrameData);
                                                  isDataIdentified = true;
                                                }
                                              }
                                            }
                                          });
                                          // portName = add;
                                        } catch (e) {
                                          print(
                                              "the error is $e from serial port");
                                        }
                                      },
                                      onWrite: (String add) async {
                                        MessageValueSet? selectedCommand =
                                            await showCommandPopUp(add);
                                        if (selectedCommand != null) {
                                          serialUtil.writeToPort(
                                              bytesMessage:
                                                  selectedCommand.cmdAsBytes(),
                                              address: add);
                                        }
                                      },
                                    );
                                  }
                                })
                              : Consumer<PortScanProvider>(
                                  builder: (context, portList, snapshot) {
                                  if (portList.deviceList.isEmpty) {
                                    return SizedBox.shrink();
                                  } else {
                                    return _PortsArea(
                                      deviceName: portList.deviceList.last,
                                      availablePorts: portList.availablePorts,
                                      onReceive: (String add) async {
                                        int baudRate = context
                                            .read<ConstantProvider>()
                                            .getBaudRate();

                                        serialUtil.openPortToListen(
                                            add, baudRate);
                                        context
                                            .read<DataStatusProvider>()
                                            .setMicrophoneDataStatus(false);

                                        if (!mounted) return;
                                        bool dummyDataStatus = context
                                            .read<DataStatusProvider>()
                                            .isSampleDataOn;
                                        bool isAudioListen = context
                                            .read<DataStatusProvider>()
                                            .isMicrophoneData;
                                        try {
                                          serialUtil.dataStream
                                              ?.listen((event) {
                                            if (!dummyDataStatus &&
                                                !isAudioListen) {
                                              preEscapeSequenceBuffer
                                                  .addBytes(event);
                                              if (isDeviceConnect) {
                                                serialUtil.writeToPort(
                                                    bytesMessage: UsbCommand
                                                        .hwTypeInquiry
                                                        .cmdAsBytes(),
                                                    address: add);

                                                isDeviceConnect = false;
                                              }
                                              if (isDataIdentified) {
                                                // Debugging.printing('us: ${stopwatch.elapsedMicroseconds}, length : ${event.length}');
                                                // stopwatch.reset();
                                              } else {
                                                Uint8List? firstFrameData =
                                                    frameDetect.addData(event);

                                                if (firstFrameData != null) {
                                                  preEscapeSequenceBuffer
                                                      .addBytes(firstFrameData);
                                                  isDataIdentified = true;
                                                }
                                              }
                                            }
                                          });
                                          // portName = add;
                                        } catch (e) {
                                          print(
                                              "the error is $e from serial port");
                                        }
                                      },
                                      onWrite: (String add) async {
                                        MessageValueSet? selectedCommand =
                                            await showCommandPopUp(add);
                                        if (selectedCommand != null) {
                                          serialUtil.writeToPort(
                                              bytesMessage:
                                                  selectedCommand.cmdAsBytes(),
                                              address: add);
                                        }
                                      },
                                    );
                                  }
                                })),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  Future<MessageValueSet?> showCommandPopUp(String add) async {
    List<DropdownMenuItem<MessageValueSet>> items = UsbCommand.commandList
        .map(
          (e) => DropdownMenuItem(
            value: e,
            child: Text(e.toString()),
          ),
        )
        .toList();

    MessageValueSet? selection;

    var result = await showDialog(
      barrierDismissible: false,
      context: context,
      builder: (BuildContext build) {
        MessageValueSet selectedValue = items.first.value!; // Default value
        return AlertDialog(
            icon: DropdownButtonFormField(
              items: items,
              onChanged: (MessageValueSet? dropDownChanges) {
                setState(() {
                  selectedValue = dropDownChanges
                      as MessageValueSet; // Update selected value
                });
              },
              value: selectedValue, // Use the selected value
            ),
            actions: [
              CustomButton(
                colors: Colors.blue[400],
                childWidget: const Text("Back"),
                onTap: () {
                  Navigator.pop(context);
                },
              ),
              CustomButton(
                colors: Colors.blue[400],
                childWidget: const Text("Write"),
                onTap: () {
                  Navigator.pop(context, selectedValue);
                },
              )
            ]);
      },
    );

    if (result != null) {
      if (result is MessageValueSet) {
        return result;
      }
    }
    return selection;
  }
}

class FilterProcessWidget extends StatefulWidget {
  const FilterProcessWidget(
      {super.key,
      required this.onSampleChange,
      required this.isMicrophoneEnable,
      required this.onTapDebugging});

  final Function(bool) isMicrophoneEnable;
  final Function(bool) onSampleChange;
  final Function(bool) onTapDebugging;

  @override
  State<FilterProcessWidget> createState() => _FilterProcessWidgetState();
}

class _FilterProcessWidgetState extends State<FilterProcessWidget> {
  @override
  Widget build(BuildContext context) {
    return Consumer<DataStatusProvider>(
        builder: (context, dataStatus, snapshot) {
      return Column(
        children: [
          Row(
            children: [
              WhiteColorCheckBox(
                valueStatus: dataStatus.isSampleDataOn,
                onChanged: (value) {
                  if (dataStatus.isMicrophoneData) {
                    listenPort?.cancel();

                    dataStatus.setMicrophoneDataStatus(false);
                    dataStatus.setSampleDataStatus(true);
                    Provider.of<SampleRateProvider>(context, listen: false)
                        .setSampleRate(dummySamplingRate);
                  } else if (!dataStatus.isMicrophoneData) {}
                  dataStatus.setSampleDataStatus(value!);

                  // setState(() {
                  //   _isSampleDataOn = value ?? false;
                  //   if (_isSampleDataOn && _isMicrophoneEnable) {
                  //     _isMicrophoneEnable = false;
                  //     widget.isMicrophoneEnable(_isMicrophoneEnable);
                  //   }
                  // });
                  // Provider.of<SampleRateProvider>(context, listen: false)
                  //     .setSampleRate(dummySamplingRate);
                  // // Provider.of<GraphDataProvider>(context, listen: false)
                  // //     .setBufferLength(dummySamplingRate);
                },
              ),
              Text(
                "Sample Data ",
                style: SoftwareTextStyle().kWtMediumTextStyle,
              ),
              WhiteColorCheckBox(
                valueStatus: dataStatus.isDebugging,
                onChanged: (value) {
                  widget.onTapDebugging(value ?? false);
                  dataStatus.setDebuggingDataStatus(value ?? false);
                },
              ),
              Flexible(
                child: Text(
                  "Debugger Open",
                  style: SoftwareTextStyle().kWtMediumTextStyle,
                ),
              ),
            ],
          ),
          const SizedBox(height: 10),
          Row(
            children: [
              WhiteColorCheckBox(
                valueStatus: dataStatus.isMicrophoneData,
                onChanged: (value) {
                  if (dataStatus.isSampleDataOn) {
                    listenPort?.cancel();
                    dataStatus.setMicrophoneDataStatus(true);
                    dataStatus.setSampleDataStatus(false);
                    Provider.of<SampleRateProvider>(context, listen: false)
                        .setSampleRate(dummySamplingRate);
                  } else {
                    dataStatus.setMicrophoneDataStatus(value!);
                  }

                  // setState(() {
                  //   _isMicrophoneEnable = value ?? false;
                  //   if (_isMicrophoneEnable && _isSampleDataOn) {
                  //     _isSampleDataOn = false;
                  //     widget.onSampleChange(_isSampleDataOn);
                  //   }
                  // });
                  // widget.isMicrophoneEnable(_isMicrophoneEnable);
                },
              ),
              Text(
                "Microphone On",
                style: SoftwareTextStyle().kWtMediumTextStyle,
              )
            ],
          ),
        ],
      );
    });
  }
}

class NotchPassFilterWidget extends StatefulWidget {
  const NotchPassFilterWidget({
    super.key,
    required this.onTapNotchFrequency,
  });

  final Function(FilterSetup) onTapNotchFrequency;

  @override
  State<NotchPassFilterWidget> createState() => _NotchPassFilterWidgetState();
}

class _NotchPassFilterWidgetState extends State<NotchPassFilterWidget> {
  bool isNotch50 = false;
  bool isNotch60 = false;
  final double _sampleRate = 0;
  late FilterSetup _notchPassFilterSettings;
  @override
  void initState() {
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    return Consumer2<SampleRateProvider, DataStatusProvider>(
        builder: (context, sampleRate, dataStatus, snapshot) {
      isNotch60 = dataStatus.is60Hertz;
      isNotch50 = dataStatus.is50Hertz;
      return Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Text(
            "Alternate frequency (Notch filter) : ",
            style: SoftwareTextStyle().kWtMediumTextStyle,
          ),
          Row(
            children: [
              Text(
                "50 Hz",
                style: SoftwareTextStyle().kWtMediumTextStyle,
              ),
              WhiteColorCheckBox(
                valueStatus: dataStatus.is50Hertz,
                onChanged: (value) {
                  _notchPassFilterSettings = dataStatus.notchPassFilterSettings;
                  if (isNotch60) {
                    dataStatus.set60HertzStatus(false);
                  }
                  isNotch50 = value!;

                  dataStatus.set50HertzStatus(value);

                  _notchPassFilterSettings = _notchPassFilterSettings.copyWith(
                      filterType: FilterType.notchFilter,
                      isFilterOn: value,
                      filterConfiguration: FilterConfiguration(
                          cutOffFrequency: 50,
                          sampleRate: sampleRate.sampleRate));
                  widget.onTapNotchFrequency(_notchPassFilterSettings);
                },
              ),
            ],
          ),
          const SizedBox(
            width: 10,
          ),
          Row(
            children: [
              Text(
                "60 Hz",
                style: SoftwareTextStyle().kWtMediumTextStyle,
              ),
              WhiteColorCheckBox(
                valueStatus: dataStatus.is60Hertz,
                onChanged: (value) {
                  if (isNotch50) {
                    dataStatus.set50HertzStatus(false);
                    isNotch60 = value!;
                  } else {
                    isNotch60 = value!;
                  }
                  dataStatus.set60HertzStatus(value);
                  _notchPassFilterSettings = _notchPassFilterSettings.copyWith(
                      filterType: FilterType.notchFilter,
                      isFilterOn: value,
                      filterConfiguration: FilterConfiguration(
                          cutOffFrequency: 60,
                          sampleRate: sampleRate.sampleRate));
                  widget.onTapNotchFrequency(_notchPassFilterSettings);
                },
              ),
            ],
          )
        ],
      );
    });
  }
}

class _PortsArea extends StatelessWidget {
  const _PortsArea(
      {required this.deviceName,
      required this.availablePorts,
      required this.onReceive,
      required this.onWrite});

  final String? deviceName;
  final List<String> availablePorts;
  final Function(String) onReceive;
  final Function(String) onWrite;

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.start,
        children: [
          for (final address in availablePorts)
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Expanded(
                  child: Text(address,
                      style: SoftwareTextStyle().kWtMediumTextStyle),
                ),
                // Flexible(
                //   child: SizedBox(
                //     child: CustomButton(
                //       childWidget: Text(
                //         "Connect",
                //         style: SoftwareTextStyle().kBBkMediumTextStyle,
                //       ),
                //       colors: SoftwareColors.kButtonBackGroundColor,
                //       onTap: () => onReceive(address),
                //     ),
                //   ),
                // ),
                Flexible(
                  child: SizedBox(
                    child: CustomButton(
                      colors: SoftwareColors.kButtonBackGroundColor,
                      childWidget: Text(
                        "Write",
                        style: SoftwareTextStyle().kBBkMediumTextStyle,
                      ),
                      onTap: () => onWrite(address),
                    ),
                  ),
                ),
              ],
            ),
          // ValueListenableBuilder<String?>(
          //   valueListenable: deviceName,
          //   builder: (context, snapshot, _) {
          //     return snapshot != null
          //         ?
          // Card(
          //   child: Padding(
          //     padding: const EdgeInsets.all(8.0),
          //     child: Text(deviceName ?? ' '),
          //   ),
          // )
          // : const SizedBox.shrink();
          //   },
          // ),
        ],
      ),
    );
  }
}

----- END ./lib/screen/setting_page.dart -----

----- BEGIN ./lib/screen/spiker_box_ui.dart -----
import 'package:flutter_audio_waveforms/flutter_audio_waveforms.dart'
    as WavForm;
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:spikerbox_architecture/provider/provider_export.dart';

import '../constant/const_export.dart';
import '../widget/widget_export.dart';

class SpikerBoxUi extends StatefulWidget {
  const SpikerBoxUi({
    super.key,
  });

  @override
  State<SpikerBoxUi> createState() => _SpikerBoxUiState();
}

class _SpikerBoxUiState extends State<SpikerBoxUi> {
  List<double> eventMarkersPosition = [];
  List<int> eventMarkersNumber = [];
  double position = 0;

  @override
  Widget build(BuildContext context) {
    return const Stack(
      children: [
        DraggableSection(),

        TimeCalculateWidget(),

        DraggableRectangle(),

        //   } else {
        //     return Container();
        //   }
        // }),
        // Container()
      ],
    );
  }
}

class TimeCalculateWidget extends StatefulWidget {
  const TimeCalculateWidget({
    super.key,
  });

  @override
  State<TimeCalculateWidget> createState() => _TimeCalculateWidgetState();
}

class _TimeCalculateWidgetState extends State<TimeCalculateWidget> {
  @override
  Widget build(BuildContext context) {
    return Consumer<GraphDataProvider>(builder: (context, timerCalculate, _) {
      return Align(
        alignment: const Alignment(1, 0.7),
        child: SizedBox(
          height: 40,
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Container(
                height: 5,
                width: 300,
                color: Colors.white,
              ),
              Text(
                "${timerCalculate.timeOnGraph} ms",
                style: SoftwareTextStyle().kWtMediumTextStyle,
              ),
            ],
          ),
        ),
      );
    });
  }
}

class DraggableSection extends StatelessWidget {
  const DraggableSection({
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(builder: (context, constraints) {
      Provider.of<VerticalDragProvider>(context, listen: false).initialOffset =
          constraints.maxHeight / 2;
      return Consumer<VerticalDragProvider>(
        builder: (context, verticalDrag, snapshot) {
          return Stack(
            clipBehavior: Clip.hardEdge,
            children: [
              Positioned(
                top: verticalDrag.topPosition,
                left: 0,
                child: SizedBox(
                  width: constraints.maxWidth,
                  height: constraints.maxHeight,
                  child: const Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      SizedBox(child: DraggableButton()),
                      Expanded(
                        child: DraggableGraph(),
                      ),
                    ],
                  ),
                ),
              ),
            ],
          );
        },
      );
    });
  }
}

class DraggableGraph extends StatefulWidget {
  const DraggableGraph({super.key});

  @override
  State<DraggableGraph> createState() => _DraggableGraphState();
}

class _DraggableGraphState extends State<DraggableGraph> {
  @override
  Widget build(BuildContext context) {
    Stream<List<double>> dataStream =
        Provider.of<GraphDataProvider>(context, listen: false)
                .outputGraphStream ??
            const Stream.empty();
    return LayoutBuilder(builder: (context, constraints) {
      return Consumer<GraphGainProvider>(
          builder: (context, graphGainProvider, _) {
        return StreamBuilder<List<double>>(
          stream: dataStream,
          builder: (context, snapshot) {
            if (snapshot.hasData) {
              List<double>? streamDouble = snapshot.data;
              // eventMarkersNumber = snapshot.data;
              // eventMarkersPosition = snapshot.data!;
              return WavForm.PolygonWaveform(
                showActiveWaveform: true,
                inactiveColor: SoftwareColors.kGraphColor,
                activeColor: Colors.transparent,
                maxDuration: const Duration(days: 1),
                elapsedDuration: const Duration(hours: 0),
                samples: streamDouble!,
                height: constraints.maxHeight,
                width: constraints.maxWidth,
                channelIdx: 1,
                channelActive: -1,
                // channelTop: top,
                gain: graphGainProvider.gain,
                levelMedian: constraints.maxHeight / 2,
                strokeWidth: 1.25,
                eventMarkersNumber: 1,
                // eventMarkersPosition: eventMarkersPosition,
              );
            } else if (snapshot.hasError) {
              // Handle error state here
              return Text('Error: ${snapshot.error}');
            } else {
              // Handle loading state here
              return const Center(
                  child: SizedBox(
                      height: 50,
                      width: 50,
                      child: CircularProgressIndicator(color: Colors.green)));
            }
          },
        );
      });
    });
  }
}

class DraggableButton extends StatefulWidget {
  const DraggableButton({super.key});

  @override
  State<DraggableButton> createState() => _DraggableButtonState();
}

class _DraggableButtonState extends State<DraggableButton> {
  double offset = 0;
  static const double _padding = 50;

  @override
  Widget build(BuildContext context) {
    VerticalDragProvider verticalDragProvider =
        Provider.of<VerticalDragProvider>(context, listen: false);
    double initialOffset = verticalDragProvider.initialOffset;
    return GestureDetector(
      behavior: HitTestBehavior.translucent,
      onTap: () {},
      onVerticalDragUpdate: (DragUpdateDetails dragUpdateVerticalDetails) {
        offset += dragUpdateVerticalDetails.primaryDelta!;
        final finalOffset =
            offset.clamp(-initialOffset + _padding, initialOffset - _padding);
        final topPosition = finalOffset;
        verticalDragProvider.setDragPosition(topPosition);
      },
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 5.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.end,
          mainAxisAlignment: MainAxisAlignment.center,
          mainAxisSize: MainAxisSize.min,
          children: [
            GestureDetector(
              onTap: () {
                GraphGainProvider graphGainProvider =
                    Provider.of<GraphGainProvider>(context, listen: false);
                graphGainProvider.setGain(graphGainProvider.gain * 3);
              },
              child: Container(
                decoration: BoxDecoration(
                  color: SoftwareColors.kButtonBackGroundColor,
                  shape: BoxShape.circle,
                ),
                child: const Icon(Icons.add, color: Colors.black, size: 15),
              ),
            ),
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 8.0),
              child: Center(
                child: SizedBox(
                  height: 20,
                  width: 30,
                  child: CustomPaint(
                    foregroundPainter: DropletPainter(),
                  ),
                ),
              ),
            ),
            GestureDetector(
              onTap: () {
                GraphGainProvider graphGainProvider =
                    Provider.of<GraphGainProvider>(context, listen: false);
                graphGainProvider.setGain(graphGainProvider.gain * 0.25);
              },
              child: Container(
                decoration: BoxDecoration(
                  color: SoftwareColors.kButtonBackGroundColor,
                  shape: BoxShape.circle,
                ),
                child: const Icon(Icons.remove, color: Colors.black, size: 15),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class DraggableRectangle extends StatefulWidget {
  const DraggableRectangle({super.key});

  @override
  State<DraggableRectangle> createState() => _DraggableRectangleState();
}

class _DraggableRectangleState extends State<DraggableRectangle> {
  Offset position = const Offset(0, 0);
  double _buttonWidth = 50;

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(builder: (context, constraints) {
      return Consumer<GraphResumePlayProvider>(
          builder: (context, isGraphStatus, snapshot) {
        if (isGraphStatus.graphStatus) {
          return Container();
        }
        {
          return Align(
              alignment: const Alignment(0, 0.75),
              child: DecoratedBox(
                  decoration: const BoxDecoration(
                      color: Color.fromARGB(255, 83, 80, 80)),
                  child: SizedBox(
                    height: 20,
                    width: double.infinity,
                    child: Stack(
                      alignment: AlignmentDirectional.centerStart,
                      children: [
                        Consumer<GraphDataProvider>(
                            builder: (context, graphDataProvider, _) {
                          _buttonWidth = graphDataProvider.getViewPortWidth() *
                              constraints.maxWidth;
                          // graphDataProvider.setBarGraphButtonWidth(_buttonWidth);

                          return Positioned(
                            right: position.dy,
                            child: GestureDetector(
                              onPanUpdate: (DragUpdateDetails details) {
                                setState(() {
                                  double y = position.dy - details.delta.dx;
                                  // print("y: $y, position.dy : ${position.dy}, details.dy: ${details.delta.dx}");
                                  y = y.clamp(
                                      0, constraints.maxWidth - _buttonWidth);

                                  position = Offset(0, y);
                                  // print("Offset: ${position}");
                                });
                              },
                              onPanEnd: (DragEndDetails dragEndDetails) {
                                double rightRatio =
                                    position.dy / constraints.maxWidth;
                                double leftRatio = (constraints.maxWidth -
                                        position.dy -
                                        _buttonWidth) /
                                    constraints.maxWidth;
                                // print("the left ratio $leftRatio and right $rightRatio");

                                // print("leftRatio : $leftRatio, rightRatio: $rightRatio");
                                graphDataProvider.setPanLevel(
                                    leftRatio, rightRatio);
                              },
                              child: Container(
                                height: 20,
                                width:
                                    _buttonWidth, // Adj  ust the width as per your requirement
                                color: Colors.grey,
                              ),
                            ),
                          );
                        }),
                      ],
                    ),
                  )));
        }
      });
    });
  }
}

----- END ./lib/screen/spiker_box_ui.dart -----

----- BEGIN ./lib/screen/web_platform/isolates_screen/isolate_sc_template.dart -----
// import 'package:flutter/foundation.dart';
// import 'package:flutter/material.dart';
// import 'package:spikerbox_architecture/widget/custom_button.dart';

// import '../../../constant/softwaretextstyle.dart';
// import '../../graph_page_widget/sound_wave_view.dart';

// class IsolateScreenTemplate extends StatefulWidget {
//   const IsolateScreenTemplate(
//       {super.key,
//       this.writePort,
//       required this.stream,
//       required this.pauseButton,
//       required this.resumeButton,
//       required this.openPort,
//       required this.readPort});
//   final Stream<Uint8List> stream;
//   final Function? writePort;
//   final Function() pauseButton;
//   final Function() resumeButton;
//   final Function() openPort;
//   final Function() readPort;

//   @override
//   State<IsolateScreenTemplate> createState() => _IsolateScreenTemplateState();
// }

// class _IsolateScreenTemplateState extends State<IsolateScreenTemplate> {
//   @override
//   Widget build(BuildContext context) {
//     return SizedBox(
//       width: MediaQuery.of(context).size.width,
//       height: MediaQuery.of(context).size.height,
//       child: Row(
//         crossAxisAlignment: CrossAxisAlignment.start,
//         children: [
//           Expanded(
//             flex: 4,
//             child: Column(
//               children: [
//                 // Expanded(
//                 //   flex: 4,
//                 //   child: SoundWaveView(
//                 //     stream: widget.stream,
//                 //   ),
//                 // ),
//                 Expanded(
//                     flex: 1,
//                     child: BottomButtons(
//                       pauseButton: widget.pauseButton,
//                       resumeButton: widget.resumeButton,
//                     ))
//               ],
//             ),
//           ),
//           Expanded(
//             flex: 1,
//             child:  Row(
//                               crossAxisAlignment: CrossAxisAlignment.start,
//                               children: [
                             
              
//                 const SizedBox(width: 16),
//                SizedBox(
//                                      height: 50,
//                                   width: 80,
//                                   child: FittedBox(
//                                     child: CustomButton(
//                                        colors: Colors.blue[500],
//                                       onTap: widget.readPort,
//                                       childWidget: Text("Recieve",style:SoftwareTextStyle().kWtMediumTextStyle,),
//                                     ),
//                                   ),
//                                 ),
//                  const SizedBox(width: 16),
//                SizedBox(
//                                      height: 50,
//                                   width: 80,
//                                   child: FittedBox(
//                                     child: CustomButton(
//                                        colors: Colors.blue[500],
//                                       onTap: (){
//                     if(widget.writePort == null) return;
//                     widget.writePort;},
//                                       childWidget: Text("Write",style:SoftwareTextStyle().kWtMediumTextStyle,),
//                                     ),
//                                   ),
//                                 ),
//                               ],
//                             ),
//           ),
//         ],
//       ),
//     );
//   }
// }

----- END ./lib/screen/web_platform/isolates_screen/isolate_sc_template.dart -----

----- BEGIN ./lib/screen/web_platform/isolates_screen/isolated_worker.dart -----
// import 'dart:async';
// import 'dart:html';
// import 'package:flutter/foundation.dart';
// import 'package:flutter/material.dart';
// import 'package:serial/serial.dart';
// import 'package:spikerbox_architecture/models/timing_util.dart';
// import 'package:spikerbox_architecture/screen/web_platform/isolates_screen/isolate_sc_template.dart';

// import '../../../dart_isolate_function/isolate_manager/js_isolated_worker.dart';
// import '../../../models/contants.dart';
// import '../../../models/usb_protocol/commands.dart';
// import '../../graph_page_widget/sound_wave_view.dart';

// class IsolateWorkerPage extends StatefulWidget {
//   const IsolateWorkerPage({
//     Key? key,
//   }) : super(key: key);

//   @override
//   State<IsolateWorkerPage> createState() => _IsolateWorkerPageState();
// }

// class _IsolateWorkerPageState extends State<IsolateWorkerPage> {
//   IsolatedWebWorker isolatedWebWorker = IsolatedWebWorker();
//   SerialPort? _port;
//   bool toListenStream = true;
//   SerialPortInfo? portInfo;
//   final StreamController<Uint8List> _streamController = StreamController();
//   late Stream<Uint8List> _stream;

//   Future<void> _openPort() async {
//     SerialPort port = await window.navigator.serial.requestPort();
//     print(
//         "port info: productId ${port.getInfo()!.usbProductId}, vendorId: ${port.getInfo()!.usbVendorId}");
//     try {
//       await port.open(baudRate: kBaudRate, bufferSize: 1023);

//     } catch (e) {
//       print("Port opening failed.");
//     }

//     _port = port;
//     setState(() {});
//   }

//   Future<void> _writeToPort() async {
//     if (_port == null) {
//       return;
//     }

//     final writer = _port!.writable.writer;

//     try{
//       await writer.ready;
    
//     await writer.write(UsbCommand.hwVersionInquiry.cmdAsBytes());



//     await writer.ready;
//     await writer.close();
    

//     }catch (e){
//       print("the error is $e");
//     }
    
//   }

//   Future<void> _readFromPort() async {
//     if (_port == null) {
//       return;
//     }

//     try {
//       // final reader = _port!.readable.reader;
//       final reader = _port!.readable.reader;

//       // TimingUtil timingUtil = TimingUtil();

//       while (true) {
//         final ReadableStreamDefaultReadResult result = await reader.read();
//      // String message  = String.fromCharCodes(result.value);
            
//         //  if(message.contains(":")&& message.contains(";")){

//          // print("the upcoming print is event ${result.value}, as String: ${String.fromCharCodes(result.value)}");

       
//         // timingUtil.addPacket(result.value);

//         // if (timingUtil.stopwatch.elapsedMilliseconds >= (10)) {
//         //   if ((timingUtil.getTotalBytesReceived() % 2) == 0) {
//         //     var responseJS =
//         //         await isolatedWebWorker.checkProcessing(result.value);
//         //     if (responseJS is Uint8List) {
//         //       if (toListenStream) {
//         //         _streamController.add(responseJS);
//         //       }
//         //     }

//         //     timingUtil.reset();
//         //   }
//        }
//       // }
//     } catch (e) {
//       print("Reading port failed with exception: \n$e");
//     }
//   }

//   @override
//   void dispose() {
//     _port?.close();
//     super.dispose();
//   }

//   @override
//   void initState() {
//     _stream = _streamController.stream.asBroadcastStream();
//     super.initState();
//   }

//   @override
//   Widget build(BuildContext context) {
//     return MaterialApp(
//       home: Scaffold(
//           appBar: AppBar(
//             title: const Text('Flutter Serial'),
//           ),
//           body: IsolateScreenTemplate(
//               stream: _stream,
//               pauseButton: () {
//                 toListenStream = false;
//               },
//               resumeButton: () {
//                 toListenStream = true;
//               },
//               serialPortInfo: portInfo,
//               openPort: () {
//                 _openPort();
//               },
//               readPort: () async {
//                 await _readFromPort();
//               },
//               writePort: ()async{
//                await _writeToPort();
//               },
//               )),
//     );
//   }
// }

----- END ./lib/screen/web_platform/isolates_screen/isolated_worker.dart -----

----- BEGIN ./lib/screen/web_platform/isolates_screen/isolates_manager.dart -----
// import 'dart:async';
// import 'dart:convert';
// import 'dart:html';
// import 'package:flutter/foundation.dart';
// import 'package:flutter/material.dart';
// import 'package:serial/serial.dart';
// import 'package:spikerbox_architecture/models/bit_wise_util.dart';
// import 'package:spikerbox_architecture/models/contants.dart';
// import '../../../dart_isolate_function/isolate_manager/isolate_manager_in_web.dart';
// import '../../../models/escape_sequences/escape_class.dart';
// import '../../../models/timing_util.dart';
// import '../../../models/usb_protocol/commands.dart';
// import 'isolate_sc_template.dart';

// class SerialPortWeb extends StatefulWidget {
//   const SerialPortWeb({Key? key}) : super(key: key);

//   @override
//   State<SerialPortWeb> createState() => _SerialPortWebState();
// }

// class _SerialPortWebState extends State<SerialPortWeb> {
//   bool toListenStream = true;
//   bool isListen = false;
//   IsolateManagerInWeb isolateManagerInWeb = IsolateManagerInWeb();
//   final StreamController<Uint8List> _streamControllerGraph = StreamController();
//   late Stream<Uint8List> _streamGraph;
//   SerialPort? _port;
//   SerialPortInfo? portInfo;

//   Future<void> _openPort() async {
//     final port = await window.navigator.serial.requestPort();
//     try {
//       await port.open(baudRate: kBaudRate, bufferSize: 8192);
//     } catch (e) {
//       print("Port opening failed: $e");
//     }
//     portInfo = port.getInfo();

//     _port = port;
//     setState(() {});
//   }

//   Future<void> _writeToPort() async {
//     if (_port == null) {
//       return;
//     }

//     final writer = _port!.writable.writer;

//     await writer.ready;
//     await writer.write(UsbCommand.hwVersionInquiry.cmdAsBytes());

//     await writer.ready;
//   }

//   Future<void> _readFromPort() async {
//     EscapeSequence escapdeinstance = EscapeSequence();
//     if (_port == null) {
//       return;
//     }
//     try {
//       final reader = _port!.readable.reader;
//       TimingUtil timingUtil = TimingUtil();

//       while (true) {
// //  if(isListen){

//         final ReadableStreamDefaultReadResult result = await reader.read();
//         // String message  = String.fromCharCodes(result.value);

//         //  if(message.contains(":")&& message.contains(";")){

//         // print("the upcoming print is event ${result.value}, as String: $message");

//          escapdeinstance.addPacket(result.value);

//         //  }
//         // timingUtil.addPacket(result.value);
//         // int dReceived = timingUtil.getTotalBytesReceived();

//         // if (timingUtil.stopwatch.elapsedMilliseconds >= (100)) {
//         // if (dReceived >= 128 && dReceived % 2 == 0) {
//         //   //   if ((timingUtil.getTotalBytesReceived() % 2) == 0) {
//         //   // TODO: implement sending of data to web worker
//         //   //     Uint8List responseOnSend = await isolateManagerInWeb.isolateManager
//         //   //         .sendMessage(timingUtil.getAllData());

//         //   // print('Response on sending to isolate: $responseOnSend');
//         //   // if (toListenStream) {
//         //   //   // _streamControllerGraph.add(timingUtil.getAllData());
//         //   // }
//         //   timingUtil.printStatistics();
//         //   // try {
//         //   //   for (int i = 0; i < timingUtil.packets.length; i++) {
//         //   //     if (i < 10 || i > (timingUtil.packets.length - 10)) {
//         //   //       print("$i : ${timingUtil.packets[i].buffer.asUint16List().first} - ${timingUtil.packets[i].buffer.asUint16List().last}");
//         //   //     }
//         //   //   }
//         //   // } catch (e) {
//         //   //   print("Reading buffer values failed.");
//         //   // }
//         //   timingUtil.reset();
//         //   }
//       }

//       //  else {
//       //  await Future.delayed(const Duration(milliseconds:500));
//       //  }
//       // }
//     } catch (e) {
//       print("Reading port failed with exception: \n$e");
//     }
//   }

//   @override
//   void dispose() {
//     isolateManagerInWeb.isolateManager.stop();
//     _port?.close();
//     super.dispose();
//   }

//   @override
//   void initState() {
//     super.initState();
//     _streamGraph = _streamControllerGraph.stream.asBroadcastStream();
//     isolateManagerInWeb.isolateManager.start();
//     // .then((value) {
//     //   _streamWebWorker = isolateManagerInWeb.isolateManager.stream;
//     //   _streamWebWorker.listen((event) {
//     //     print("received from isolate: $event");
//     //     _streamControllerGraph.add(event);
//     //   });
//     // });
//   }

//   @override
//   Widget build(BuildContext context) {
//     return MaterialApp(
//       home: Scaffold(
//           appBar: AppBar(
//             title: const Text('Flutter Serial'),
//           ),
//           body: IsolateScreenTemplate(
//             stream: _streamGraph,
//             pauseButton: () {
//               toListenStream = false;
//             },
//             resumeButton: () {
//               toListenStream = true;
//             },
//             serialPortInfo: portInfo,
//             openPort: () async {
//               await _openPort();
//             },
//             readPort: ()async {
//                await _readFromPort();
            
//             },
//             writePort: () {
//               _writeToPort();

//               //  setState(() {
//               //    isListen  = true;
//               //  });
//             },
//           )),
//     );
//   }
// }

----- END ./lib/screen/web_platform/isolates_screen/isolates_manager.dart -----

----- BEGIN ./lib/screen/web_platform/isolates_screen/squadron/identify_service.dart -----
import 'dart:async';

import 'package:squadron/squadron.dart';

// The service interface
abstract class IdentityService implements WorkerService {
  FutureOr<String> whoAreYou();

  static const whoAreYouCommand = 1;

  @override
  late final Map<int, CommandHandler> operations = {
    IdentityService.whoAreYouCommand: (req) => whoAreYou(),
  };
}

// The service implementation
class IdentityServiceImpl extends IdentityService {
  @override
  String whoAreYou() => Squadron.id ?? '<undefined>';
}

// The service client: this class will be used in workers that need to call the service implementation
class IdentityClient extends LocalWorkerClient implements IdentityService {
  IdentityClient(Channel channel) : super(channel);

  @override
  Future<String> whoAreYou() => send(IdentityService.whoAreYouCommand);
}

----- END ./lib/screen/web_platform/isolates_screen/squadron/identify_service.dart -----

----- BEGIN ./lib/screen/web_platform/isolates_screen/squadron/sample_service.dart -----
import 'dart:async';

import 'package:squadron/squadron_service.dart';

import 'identify_service.dart';

abstract class SampleService {
  FutureOr io({required int milliseconds});
  FutureOr cpu({required int milliseconds});
  FutureOr<String> whoAreYouTalkingTo();

  // command IDs
  static const ioCommand = 1;
  static const cpuCommand = 2;
  static const whoAreYouTalkingToCommand = 3;
}

class SampleServiceImpl implements SampleService, WorkerService {
  SampleServiceImpl(this._identityClient);

  final IdentityClient _identityClient;

  @override
  Future io({required int milliseconds}) =>
      Future.delayed(Duration(milliseconds: milliseconds));

  @override
  void cpu({required int milliseconds}) {
    final sw = Stopwatch()..start();
    while (sw.elapsedMilliseconds < milliseconds) {/* cpu */}
  }

  @override
  Future<String> whoAreYouTalkingTo() async {
    // this is where the local worker is called
    final localWorkerIdentity = await _identityClient.whoAreYou();
    Squadron.fine('talking to $localWorkerIdentity');
    return 'I am ${Squadron.id}, and I am talking to $localWorkerIdentity.';
  }

  // command IDs --> command handlers
  @override
  late final Map<int, CommandHandler> operations = {
    SampleService.ioCommand: (WorkerRequest r) => io(milliseconds: r.args[0]),
    SampleService.cpuCommand: (WorkerRequest r) => cpu(milliseconds: r.args[0]),
    SampleService.whoAreYouTalkingToCommand: (WorkerRequest r) =>
        whoAreYouTalkingTo(),
  };
}

----- END ./lib/screen/web_platform/isolates_screen/squadron/sample_service.dart -----

----- BEGIN ./lib/screen/web_platform/isolates_screen/squadron/sample_worker_vm.dart -----
import 'package:squadron/squadron.dart';

import 'identify_service.dart';
import 'sample_service.dart';

void start(List command) => run((startRequest) {
      final channel = Channel.deserialize(startRequest.args[0])!;
      final identityClient = IdentityClient(channel);
      return SampleServiceImpl(identityClient);
    }, command);
----- END ./lib/screen/web_platform/isolates_screen/squadron/sample_worker_vm.dart -----

----- BEGIN ./lib/screen/web_platform/isolates_screen/squadron/sampleworker_pool.dart -----
import 'dart:async';

import 'package:squadron/squadron.dart';

import 'identify_service.dart';
import 'sample_service.dart';

class SampleWorkerPool extends WorkerPool<SampleWorker>
    implements SampleService {
  SampleWorkerPool(
      dynamic entryPoint,
      LocalWorker<IdentityService> identityServer,
      ConcurrencySettings concurrencySettings)
      : super(
            () => SampleWorker(entryPoint,
                args: [identityServer.channel?.share().serialize()]),
            concurrencySettings: concurrencySettings);

  @override
  Future io({required int milliseconds}) =>
      execute((w) => w.io(milliseconds: milliseconds));

  @override
  Future cpu({required int milliseconds}) =>
      execute((w) => w.cpu(milliseconds: milliseconds));

  @override
  Future<String> whoAreYouTalkingTo() => execute((w) => w.whoAreYouTalkingTo());
}

class SampleWorker extends Worker implements SampleService {
  SampleWorker(dynamic entryPoint, {List args = const []})
      : super(entryPoint, args: args);

  @override
  Future io({required int milliseconds}) =>
      send(SampleService.ioCommand, args: [milliseconds]);

  @override
  Future cpu({required int milliseconds}) =>
      send(SampleService.cpuCommand, args: [milliseconds]);

  @override
  Future<String> whoAreYouTalkingTo() =>
      send(SampleService.whoAreYouTalkingToCommand);
}

----- END ./lib/screen/web_platform/isolates_screen/squadron/sampleworker_pool.dart -----

----- BEGIN ./lib/screen/web_platform/isolates_screen/squadron_package.dart -----
import 'dart:async';
import 'dart:html';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart';
import 'package:serial/serial.dart';
import 'package:spikerbox_architecture/models/constant.dart';
import 'package:spikerbox_architecture/screen/web_platform/isolates_screen/squadron/identify_service.dart';
import 'package:spikerbox_architecture/screen/web_platform/isolates_screen/squadron/sample_service.dart';
import 'package:spikerbox_architecture/screen/web_platform/isolates_screen/squadron/sample_worker_vm.dart'
    as sample_isolate;
import 'package:squadron/squadron.dart';
import 'package:spikerbox_architecture/screen/web_platform/isolates_screen/squadron/sampleworker_pool.dart';



class SquadronPages extends StatefulWidget {
  const SquadronPages({Key? key}) : super(key: key);

  @override
  State<SquadronPages> createState() => _SquadronPagesState();
}

class _SquadronPagesState extends State<SquadronPages> {
  Squadron? squadron;
  SerialPort? _port;
  final _received = <String>[];
  SerialPortInfo? portInfo;
  Future<void> _openPort() async {
    final port = await window.navigator.serial.requestPort();
    await port.open(baudRate: 222222);
    portInfo = port.getInfo();

    _port = port;
    setState(() {});
  }

  Future<void> _writeToPort() async {
    if (_port == null) {
      return;
    }

    final writer = _port!.writable.writer;

    await writer.ready;
    await writer.write(Uint8List.fromList('Hello World.'.codeUnits));

    await writer.ready;
    await writer.close();
  }

  Future<void> _readFromPort() async {
    if (_port == null) {
      return;
    }

    final reader = _port!.readable.reader;
    while (true) {
      final ReadableStreamDefaultReadResult result = await reader.read();

      // 3. squadron package in web
      // final worker = Squadron(
      //   entryPoint: 'my_worker',
      //   args: const ['Hello', 'World'],
      // );

      // // Start the worker.
      // worker.start();

      // // Wait for the worker to finish.
      // await worker.join();

      // // Get the worker's output.
      // final output = worker.output;

      // // Print the output to the console.
      // print(output);
    }
  }

  @override
  void dispose() {
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    SchedulerBinding.instance.addPostFrameCallback((timeStamp) async {
      // Squadron.setId('spiker');
      // Squadron.setLogger(ConsoleSquadronLogger());
      // Squadron.logLevel = SquadronLogLevel.all;
      await squadronIsolateCheck();
    });
  }

  Offset renderCenter = const Offset(-0.75, 0);
  double renderWidth = 3.5;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Flutter Serial'),
      ),
      body: Column(
        children: [
          portInfo != null
              ? ListTile(
                  title: Text(
                    portInfo!.usbProductId.toString(),
                  ),
                  subtitle: Text(portInfo!.usbVendorId.toString()),
                )
              : const Text("No device is detected"),
          Expanded(
            child: ListView(
              padding: const EdgeInsets.all(8),
              children: _received.map((e) => Text(e)).toList(),
            ),
          ),
          ElevatedButton(
            child: const Text('Open Port'),
            onPressed: () {
              _openPort();
            },
          ),
          const SizedBox(height: 16),
          ElevatedButton(
            child: const Text('Send'),
            onPressed: () {
              _writeToPort();
            },
          ),
          const SizedBox(height: 16),
          ElevatedButton(
            child: const Text('Receive'),
            onPressed: () async {
              await _readFromPort();
            },
          ),
        ],
      ),
    );
  }

  Future squadronIsolateCheck() async {
    final sw = Stopwatch()..start();

    Squadron.setId('MAIN');
    Squadron.debugMode = false;
    Squadron.logLevel = SquadronLogLevel.info;
    Squadron.setLogger(ConsoleSquadronLogger());

    void log([String? message]) {
      message ??= '';
      Squadron.info(message.isEmpty ? ' ' : '[${sw.elapsed}] $message');
    }

    final loops = 5;
    final max = 50;

    log();
    log('loops = $loops');
    log('max = $max');
    log();

    final identityService = IdentityServiceImpl();
    final identityServer = LocalWorker<IdentityService>.create(identityService);
    final identityClient = IdentityClient(identityServer.channel!.share());
    final sampleService = SampleServiceImpl(identityClient);

    SampleWorkerPool? pool;

    try {
      ///////////// SYNC /////////////
      log('///////////// SYNC /////////////');

      final syncSw = Stopwatch()..start();
      for (var loop = 0; loop < loops; loop++) {
        final syncFutures = <Future>[];
        for (var n = 0; n < max; n++) {
          syncFutures
            ..add(Future(() => sampleService.cpu(milliseconds: n)))
            ..add(sampleService.io(milliseconds: n));
        }
        await Future.wait(syncFutures);
      }
      syncSw.stop();
      final syncElapsed = syncSw.elapsedMicroseconds;

      log('sync version completed in ${Duration(microseconds: syncElapsed)}');
      log();

      ///////////// POOL /////////////
      log('///////////// POOL /////////////');

      // create the pool
      final concurrencySettings =
          ConcurrencySettings(minWorkers: 2, maxWorkers: 4, maxParallel: 2);

      pool = SampleWorkerPool(
          sample_isolate.start, identityServer, concurrencySettings);
      await pool.start();
      log('pool started');

      // create the pool monitor
      final maxIdle = Duration(milliseconds: 1000);
      final monitor = Timer.periodic(Duration(milliseconds: 250), (timer) {
        pool?.stop((w) => w.idleTime > maxIdle);
      });

      log('pool monitor started');

      final tasks = <Future>[];

      // force maximum load on pool
      for (var i = 0; i < pool.maxConcurrency; i++) {
        tasks.add(pool.cpu(milliseconds: 5));
      }

      await Future.wait(tasks);

      // 4 workers should have been started
      assert(pool.size == 2);
      // sit idle to that the pool monitor stops 2 of them
      await Future.delayed(maxIdle * 2);
      assert(pool.size == 2);
      log('pool monitor OK');

      final asyncSw = Stopwatch()..start();
      for (var loop = 0; loop < loops; loop++) {
        final asyncFutures = <Future>[];
        for (var n = 0; n < max; n++) {
          asyncFutures
            ..add(pool.cpu(milliseconds: n))
            ..add(pool.io(milliseconds: n));
        }
        await Future.wait(asyncFutures);
      }
      asyncSw.stop();
      final asyncElapsed = asyncSw.elapsedMicroseconds;

      log('async version completed in ${Duration(microseconds: asyncElapsed)}');
      log();

      ///////////// LOCAL WORKER /////////////
      log('///////////// LOCAL WORKER /////////////');

      log('IdentityClient is ${await identityClient.whoAreYou()}.');
      log(await sampleService.whoAreYouTalkingTo());

      tasks.clear();
      for (var i = 0; i < pool.maxConcurrency + 1; i++) {
        tasks.add(pool.whoAreYouTalkingTo().then(log));
      }
      await Future.wait(tasks);

      // stop the identity local worker
      identityServer.stop();

      // shutdown pool
      log('waiting for monitor to stop workers...');
      final sw = Stopwatch()..start();
      while (true) {
        final size = pool.size;
        log('  * pool.size = $size');
        if (size <= pool.concurrencySettings.minWorkers) break;
        await Future.delayed(maxIdle ~/ 2);
        if (sw.elapsedMicroseconds > maxIdle.inMicroseconds * 2) {
          log('Houston, we have a problem...');
        }
      }

      log('worker stats:');
      for (var stat in pool.fullStats) {
        log('  * ${stat.id}: status=${stat.status}, workload=${stat.workload}, maxWorkload=${stat.maxWorkload}, totalWorkload=${stat.totalWorkload}, totalErrors=${stat.totalErrors}');
      }

      monitor.cancel();

      log('pool stats:');
      log('  * size=${pool.size}, workload=${pool.workload}, maxLoad=${pool.maxWorkload}, totalWorkload=${pool.totalWorkload}, totalErrors=${pool.totalErrors}');

      log();
    } on WorkerException catch (e) {
      log(e.message);
      log(e.stackTrace?.toString());
    } finally {
      pool?.stop();
    }

    log('Done.');
    log();
  }
}

class SampleService implements WorkerService {
  Future io({required int milliseconds}) =>
      Future.delayed(Duration(milliseconds: milliseconds));

  void cpu({required int milliseconds}) {
    final sw = Stopwatch()..start();
    while (sw.elapsedMilliseconds < milliseconds) {/* cpu */}
  }

  static const ioCommand = 1;
  static const cpuCommand = 2;

  @override
  Map<int, CommandHandler> get operations => {
        ioCommand: (WorkerRequest r) => io(milliseconds: r.args[0]),
        cpuCommand: (WorkerRequest r) => cpu(milliseconds: r.args[0]),
      };
}

----- END ./lib/screen/web_platform/isolates_screen/squadron_package.dart -----

----- BEGIN ./lib/screen/web_platform/js_library.dart -----
export 'package:spikerbox_architecture/screen/web_platform/js_listener_native.dart'
    if (dart.library.html) 'package:spikerbox_architecture/screen/web_platform/js_listener_web.dart'
    if (Platform.isWindows) 'package:spikerbox_architecture/screen/web_platform/js_listener_web.dart';

----- END ./lib/screen/web_platform/js_library.dart -----

----- BEGIN ./lib/screen/web_platform/js_listener_native.dart -----
import "package:flutter/material.dart";

class SerialPortWeb extends StatefulWidget {
  const SerialPortWeb({Key? key}) : super(key: key);

  @override
  State<SerialPortWeb> createState() => _SerialPortWebState();
}

class _SerialPortWebState extends State<SerialPortWeb> {
  @override
  Widget build(BuildContext context) {
    return const Placeholder();
  }
}

----- END ./lib/screen/web_platform/js_listener_native.dart -----

----- BEGIN ./lib/screen/web_platform/js_listener_web.dart -----
// import 'dart:async';
// import 'package:flutter/foundation.dart';
// import 'package:flutter/material.dart';
// import 'package:serial/serial.dart';
// import 'package:spikerbox_architecture/models/models.dart';
// import '../../../dart_isolate_function/isolate_manager/isolate_manager_in_web.dart';
// import '../../models/serial_util/serial_util_check.dart';
// import 'isolates_screen/isolate_sc_template.dart';

// class SerialPortWeb extends StatefulWidget {
//   const SerialPortWeb({Key? key}) : super(key: key);

//   @override
//   State<SerialPortWeb> createState() => _SerialPortWebState();
// }

// class _SerialPortWebState extends State<SerialPortWeb> {
//   bool toListenStream = true;
//   bool isListen = false;
//   // final IsolateManagerInWeb isolateManagerInWeb = IsolateManagerInWeb();
//   final StreamController<Uint8List> _streamControllerGraph = StreamController();
//   late Stream<Uint8List> _streamGraph;
//   SerialPort? _port;
//   SerialPortInfo? portInfo;
//   // final OpenSerialPort openSerialPort = OpenSerialPort();
//   final SerialUtil serialUtil = SerialUtil();
  

//   @override
//   void dispose() {
//     // isolateManagerInWeb.isolateManager.stop();
//     _port?.close();
//     super.dispose();
//   }

//   @override
//   void initState() {
//     super.initState();
//     _streamGraph = _streamControllerGraph.stream.asBroadcastStream();
//     // isolateManagerInWeb.isolateManager.start();
//     // .then((value) {
//     //   _streamWebWorker = isolateManagerInWeb.isolateManager.stream;
//     //   _streamWebWorker.listen((event) {
//     //     print("received from isolate: $event");
//     //     _streamControllerGraph.add(event);
//     //   });
//     // });
//   }

//   @override
//   Widget build(BuildContext context) {
//     return MaterialApp(
//       home: Scaffold(
//         appBar: AppBar(
//           title: const Text('Flutter Serial'),
//         ),
//         body: IsolateScreenTemplate(
//           stream: _streamGraph,
//           pauseButton: () {
//             toListenStream = false;
//           },
//           resumeButton: () {
//             toListenStream = true;
//           },
//           openPort: () async {
//             //await SerialUtilWindow().openPort();
//           },
//           readPort: () async {
//           Stream<Uint8List>? getData =await serialUtil.openPortToListen("");
//          getData?.listen((event) {
//         String message = String.fromCharCodes(event);

//         print("serial received value: $event, as String: $message");
//         //         escapdeinstance.addPacket(Uint8List.fromList(message.codeUnits));
//         //         escapdeinstance.addPacket(Uint8List.fromList(message.codeUnits));
//         //         if(message.contains(":")&&message.contains(";")){
//         // print("the upcoming print is event ${event}, as String: $message");
//         //         }
//         // escapdeinstance.addPacket(Uint8List.fromList(message.codeUnits));
//         // BitwiseUtil().readBytes(Uint8List.fromList([44,255,55,69]), 10);

//         if (message.contains(":") && message.contains(";")) {}
//       });
         
//           },
//           writePort: () {
//             //  OpenSerialPort.ontapWrite("");
//             setState(() {
//               serialUtil.writeToPort(bytesMesage: UsbCommand.deviceConnection.cmdAsBytes(), address:"");
//               // SerialUtilWeb().writeToPort(bytesMesage: UsbCommand.deviceConnection.cmdAsBytes(), address:"");
//             });
//             // SerialUtil().;

//             //  setState(() {
//             //    isListen  = true;
//             //  });
//           },
//         ),
//         floatingActionButton: FloatingActionButton.extended(
//           onPressed: () async {
          
//           },
//           label: const Row(
//             children: [Text("Scan Port"), Icon(Icons.refresh)],
//           ),
//         ),
//       ),
//     );
//   }
// }

----- END ./lib/screen/web_platform/js_listener_web.dart -----

----- BEGIN ./lib/screen/web_platform/web_isolates/web_worker_page.dart -----
import 'dart:collection';

import 'package:flutter/material.dart';

import '../../../core/webworker_test.dart';

class WebWorkerPage extends StatefulWidget {
  const WebWorkerPage({Key? key}) : super(key: key);

  @override
  State<WebWorkerPage> createState() => _WebWorkerPageState();
}

class _WebWorkerPageState extends State<WebWorkerPage> {
  final JsWebWorker _jsWebWorker = JsWebWorker();

  @override
  void initState() {
    super.initState();
    _checkProcessing();

    // await isolateManager.start();
  }

  Future<void> _checkProcessing() async {
    int startTime = DateTime.now().microsecondsSinceEpoch;

    LinkedHashMap<dynamic, dynamic> arguments =
        LinkedHashMap.from({"initialData": 55});
    final LinkedHashMap<dynamic, dynamic> responseMap =
        await _jsWebWorker.processingLoad(arguments);
    final Object? error = responseMap['err'];
    if (error != null) {
      throw error;
    }
    final dynamic totalTime = responseMap['totalTime'];
    int timeTaken = DateTime.now().microsecondsSinceEpoch - startTime;
    print("TimeTaken for dart to dart: $timeTaken microseconds");
    print("TimeTaken within JS: $totalTime microseconds");
    return;
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('IsolatedWorker fetch example'),
      ),
      body: Column(
        children: [
          ElevatedButton(
            child: const Text("processing"),
            onPressed: () {
              _checkProcessing();
            },
          ),
        ],
      ),
    );
  }
}

----- END ./lib/screen/web_platform/web_isolates/web_worker_page.dart -----

----- BEGIN ./lib/widget/callback_button.dart -----
// import 'dart:async';
// import 'package:spikerbox_architecture/models/serial_util/serial_util_check.dart';
// import '../models/usb_protocol/commands.dart';
//
// class OpenSerialPort {
//   SerialUtil serialUtil = SerialUtil();
//
//   void ontapConnect(String address) {
//     serialUtil.connectToPort();
//   }
//
//   //  To listen The Port from the  web and desktop
//   Future<void> ontapListen(String? address) async {
//     serialUtil.openPortToListen(null);
//   }
//
//   //  Write the data in serial port to any device
//   Future<void> ontapWrite(String address) async {
//     serialUtil.writeToPort(
//         address: address,
//         bytesMesage: UsbCommand.deviceConnection.cmdAsBytes());
//   }
// }

----- END ./lib/widget/callback_button.dart -----

----- BEGIN ./lib/widget/chart.dart -----
import 'dart:math';
import 'dart:typed_data';

import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import 'dart:async';

import '../models/models.dart';

class ChartView extends StatefulWidget {
  const ChartView({
    super.key,
    required this.stream,
  });
  final Stream<Uint8List> stream;

  @override
  State<ChartView> createState() => _ChartViewState();
}

class _ChartViewState extends State<ChartView> {
  List<DataPoint> _dataPoints = [];
  static const _graphPointsLength = kGraphPointsCount;

  final Random _random = Random();
  int _xCount = _graphPointsLength;

  ChartSeriesController? _controller;

  @override
  void initState() {
    super.initState();
    _dataPoints =
        List.generate(_graphPointsLength, (index) => DataPoint(index, 0));

    widget.stream.listen((event) {
      // ByteData byteData = event.buffer.asByteData();
      // List<int> newDataPoints = [];
      // for (int i = 0; i < byteData.lengthInBytes; i += 2) {
      //   newDataPoints.add(byteData.getUint16(i, Endian.big));
      // }

      Int16List newDataPoints = event.buffer.asInt16List();

      int l = min(newDataPoints.length, kGraphPointsCount);

      // Remove old points from start of buffer
      _dataPoints.removeRange(0, l);

      Iterable<DataPoint> newPoints = newDataPoints.sublist(0, l).map((e) {
        return DataPoint(_xCount++, e);
      });

      // Add new points to end of buffer
      _dataPoints.addAll(newPoints);

      if (_controller != null) {
        _controller?.updateDataSource(
          removedDataIndexes: List.generate(l, (index) => index),
          addedDataIndexes:
              List.generate(l, (index) => (_dataPoints.length - l) + index),
        );
      } else {
        Debugging.printing("Chart controller is null");
      }
    });
  }

  @override
  void dispose() {
    super.dispose();
  }

  int _generateRandomValue() {
    return _random.nextInt(120) + 20;
  }

  @override
  Widget build(BuildContext context) {
    return SfCartesianChart(
      borderWidth: 0,
      borderColor: Colors.white,
      enableSideBySideSeriesPlacement: true,
      primaryXAxis: null,
      primaryYAxis: null,

      // primaryXAxis: CategoryAxis(isVisible: true),
      // primaryYAxis: CategoryAxis(isVisible: true),
      series: <FastLineSeries<DataPoint, int>>[
        FastLineSeries<DataPoint, int>(
          dataSource: _dataPoints,
          onRendererCreated: (ChartSeriesController controller) {
            _controller = controller;
          },
          xValueMapper: (DataPoint data, _) => data.x,
          yValueMapper: (DataPoint data, _) => data.y,
          animationDuration: 0,
        ),
      ],
    );
  }
}

class DataPoint {
  final int x;
  final int y;

  DataPoint(this.x, this.y);

  @override
  String toString() {
    return 'DataPoint x: $x, y: $y\n';
  }
}

----- END ./lib/widget/chart.dart -----

----- BEGIN ./lib/widget/custom_button.dart -----
import 'package:flutter/material.dart';

class CustomButton extends StatelessWidget {
  final GestureTapCallback? onTap;
  final Color? colors;
  final Widget childWidget;
  final double? radius;
  final double? elevation;

  const CustomButton({
    super.key,
    required this.childWidget,
    this.onTap,
    this.colors,
    this.radius,
    this.elevation,
  });

  @override
  Widget build(BuildContext context) {
    return FittedBox(
      child: RawMaterialButton(
        fillColor: colors,
        onPressed: onTap,
        splashColor: Colors.black12,
        elevation: elevation ?? 2.0,
        shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(radius ?? 32),
            side: const BorderSide(width: 2, color: Colors.grey)),
        child: Padding(
            padding:
                const EdgeInsets.symmetric(horizontal: 25.0, vertical: 10.0),
            child: childWidget),
      ),
    );
  }
}

----- END ./lib/widget/custom_button.dart -----

----- BEGIN ./lib/widget/custom_slider_widget.dart -----
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:native_add/model/model.dart';
import 'package:provider/provider.dart';
import 'package:spikerbox_architecture/provider/custom_slider_provider.dart';
import 'package:spikerbox_architecture/provider/provider_export.dart';

import '../constant/const_export.dart';
import '../models/constant.dart';
import '../models/microphone_stream/microphone_stream_check.dart';
import '../screen/graph_template.dart';

class CustomSliderBarButton extends StatefulWidget {
  const CustomSliderBarButton({
    super.key,
    required this.onHighPassFilterSetup,
    required this.onLowPassFilterSetup,
    required this.onSampleChange,
    required this.isMicrophoneEnable,
  });

  final Function(bool) isMicrophoneEnable;
  final Function(bool) onSampleChange;
  final Function(FilterSetup) onHighPassFilterSetup;
  final Function(FilterSetup) onLowPassFilterSetup;

  @override
  State<CustomSliderBarButton> createState() => _CustomSliderState();
}

class _CustomSliderState extends State<CustomSliderBarButton> {
  MicrophoneUtil microphoneUtil = MicrophoneUtil();

  bool _isSampleDataOn = false;
  bool _isMicrophoneEnable = false;
  late FilterSetup _highPassFilterSettings;
  late FilterSetup _lowPassFilterSettings;

  final TextEditingController _lowSampleRateController =
      TextEditingController();
  final TextEditingController _lowCutOffController = TextEditingController();
  final TextEditingController _highSampleRateController =
      TextEditingController();
  final TextEditingController _highCutOffController = TextEditingController();

  double sliderValue = 0;
  double sampleRate = 0;
  double start = 0;
  double end = 0;

  double maxFreq = 0;

  double logMin = 0;
  double logMax = 0;

  @override
  void initState() {
    super.initState();

    DataStatusProvider dataStatusProvider = context.read<DataStatusProvider>();
//     sliderValue = widget.sliderValue;

    sampleRate = context.read<SampleRateProvider>().sampleRate.toDouble();
    maxFreq = sampleRate / 2;
    logMax = logToLinear(maxFreq);
    CustomRangeSliderProvider customRangeSliderProvider =
        context.read<CustomRangeSliderProvider>();
    start = customRangeSliderProvider.startValue;
    if (start != 0) {
      logMin = logToLinear(start);
    }
    _highCutOffController.text = start.toString();
    double endValue = customRangeSliderProvider.endValue;
    if (endValue == 0) {
      end = maxFreq;
      _lowCutOffController.text = end.toString();
      //  logMax = (log(end).toInt()).toDouble();
    } else {
      end = customRangeSliderProvider.endValue;
      _lowCutOffController.text = end.toString();
      logMax = logToLinear(end);
    }

    _highPassFilterSettings = dataStatusProvider.highPassFilterSettings;
    _lowPassFilterSettings = dataStatusProvider.lowPassFilterSettings;

//  set the starting low pass Filter
    _lowCutOffController.text =
        _lowPassFilterSettings.filterConfiguration.cutOffFrequency.toString();
    _lowSampleRateController.text =
        _lowPassFilterSettings.filterConfiguration.sampleRate.toString();

    _highCutOffController.text =
        _highPassFilterSettings.filterConfiguration.cutOffFrequency.toString();
    _highSampleRateController.text =
        _highPassFilterSettings.filterConfiguration.sampleRate.toString();

    _lowCutOffController.text = start.toInt().toString();
    _highCutOffController.text = end.toInt().toString();
    _isMicrophoneEnable = context.read<DataStatusProvider>().isMicrophoneData;
    _isSampleDataOn = context.read<DataStatusProvider>().isSampleDataOn;
  }

  double logToLinear(double x) {
    return (log(x) / log(10));
  }

  double linearToLog(double x) {
    return pow(10, x).toDouble();
  }

  @override
  Widget build(BuildContext context) {
    return Consumer<SampleRateProvider>(
        builder: (context, sampleRateProvider, snapshot) {
      sampleRate = sampleRateProvider.sampleRate.toDouble();
      return Column(
        children: [
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 20),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                SetFrequencyWidget(
                  onStringChanged: (String lowFrequency) {
                    if (lowFrequency.isNotEmpty) {
                      int filterPass = int.parse(lowFrequency);

                      if (filterPass < end && filterPass < maxFreq) {
                        if (filterPass == 0) {
                          setupFilter(
                            cutoffFrequency: filterPass.toDouble(),
                            sampleRate: sampleRate,
                            channelCountBuffer: channelCountBuffer,
                            isFilterOn: false,
                            filterType: FilterType.highPassFilter,
                            onFilterSetup: widget.onHighPassFilterSetup,
                            dataStatusProvider:
                                context.read<DataStatusProvider>(),
                          );
                        } else {
                          setupFilter(
                            cutoffFrequency: filterPass.toDouble(),
                            sampleRate: sampleRate,
                            channelCountBuffer: channelCountBuffer,
                            isFilterOn: true,
                            filterType: FilterType.highPassFilter,
                            onFilterSetup: widget.onHighPassFilterSetup,
                            dataStatusProvider:
                                context.read<DataStatusProvider>(),
                          );
                          logMin = logToLinear(filterPass.toDouble());
                        }
                        _lowCutOffController.text =
                            filterPass.toInt().toString();
                        start = filterPass.toDouble();
                        setState(() {});
                      }
                    }
                  },
                  frequencyEditController: _lowCutOffController,
                  frequencyType: "Low",
                  frequencyValue: start.toInt(),
                ),
                SetFrequencyWidget(
                  onStringChanged: (String highFrequency) {
                    sampleRate = context
                        .read<SampleRateProvider>()
                        .sampleRate
                        .toDouble();

                    if (highFrequency.isNotEmpty) {
                      int filterPass = int.parse(highFrequency);
                      if (filterPass > start && filterPass < maxFreq) {
                        if (end == sampleRate) {
                          setupFilter(
                            cutoffFrequency: filterPass.toDouble(),
                            sampleRate: sampleRate,
                            channelCountBuffer: channelCountBuffer,
                            isFilterOn: false,
                            filterType: FilterType.lowPassFilter,
                            onFilterSetup: widget.onLowPassFilterSetup,
                            dataStatusProvider:
                                context.read<DataStatusProvider>(),
                          );
                        } else {
                          setupFilter(
                            cutoffFrequency: filterPass.toDouble(),
                            sampleRate: sampleRate,
                            channelCountBuffer: channelCountBuffer,
                            isFilterOn: true,
                            filterType: FilterType.lowPassFilter,
                            onFilterSetup: widget.onLowPassFilterSetup,
                            dataStatusProvider:
                                context.read<DataStatusProvider>(),
                          );

                          logMax = logToLinear(filterPass.toDouble());
                        }
                        _highCutOffController.text =
                            filterPass.toInt().toString();
                        end = filterPass.toDouble();
                        setState(() {});
                      }
                    }
                  },
                  frequencyEditController: _highCutOffController,
                  frequencyType: "High",
                  frequencyValue: end.toInt(),
                ),
              ],
            ),
          ),
          Row(
            children: [
              Expanded(
                child: RangeSlider(
                  overlayColor: MaterialStateProperty.resolveWith<Color?>(
                    (Set<MaterialState> states) {
                      if (states.contains(MaterialState.pressed)) {
                        // Color when the thumbs are pressed
                        return Colors.blue.withOpacity(0.5);
                      } else {
                        // Default color
                        return Colors.blue.withOpacity(0.2);
                      }
                    },
                  ),
                  divisions: 50,
                  inactiveColor: Colors.grey,
                  activeColor: SoftwareColors.kGraphColor,
                  values: RangeValues(logMin, logMax),

                  labels: RangeLabels(linearToLog(logMin).toInt().toString(),
                      linearToLog(logMax).toInt().toString()),
                  onChanged: (RangeValues value) {
                    sampleRate = context
                        .read<SampleRateProvider>()
                        .sampleRate
                        .toDouble();
                    setState(() {
                      logMin = value.start;
                      logMax = value.end;
                      start = (linearToLog(logMin).toInt()).toDouble();
                      end = (linearToLog(logMax).toInt()).toDouble();
                    });

                    Provider.of<CustomRangeSliderProvider>(context,
                            listen: false)
                        .setStartValue(start);

                    Provider.of<CustomRangeSliderProvider>(context,
                            listen: false)
                        .setEndValue(end);
                    if (start == 0) {
                      setupFilter(
                        cutoffFrequency: start,
                        sampleRate: sampleRate,
                        channelCountBuffer: channelCountBuffer,
                        isFilterOn: false,
                        filterType: FilterType.highPassFilter,
                        onFilterSetup: widget.onHighPassFilterSetup,
                        dataStatusProvider: context.read<DataStatusProvider>(),
                      );
                    } else {
                      setupFilter(
                        cutoffFrequency: start,
                        sampleRate: sampleRate,
                        channelCountBuffer: channelCountBuffer,
                        isFilterOn: true,
                        filterType: FilterType.highPassFilter,
                        onFilterSetup: widget.onHighPassFilterSetup,
                        dataStatusProvider: context.read<DataStatusProvider>(),
                      );
                    }

                    if (end == sampleRate) {
                      setupFilter(
                        cutoffFrequency: end,
                        sampleRate: sampleRate,
                        channelCountBuffer: channelCountBuffer,
                        isFilterOn: false,
                        filterType: FilterType.lowPassFilter,
                        onFilterSetup: widget.onLowPassFilterSetup,
                        dataStatusProvider: context.read<DataStatusProvider>(),
                      );
                    } else {
                      setupFilter(
                        cutoffFrequency: end,
                        sampleRate: sampleRate,
                        channelCountBuffer: channelCountBuffer,
                        isFilterOn: true,
                        filterType: FilterType.lowPassFilter,
                        onFilterSetup: widget.onLowPassFilterSetup,
                        dataStatusProvider: context.read<DataStatusProvider>(),
                      );
                    }

                    _lowCutOffController.text = start.toInt().toString();
                    _highCutOffController.text = end.toInt().toString();
                    // setState(() {});
                  },
                  min: 0,
                  max: logToLinear(maxFreq),
                  // min: 0,
                  // max: maxFreq,
                ),
              ),
            ],
          ),
        ],
      );
    });
  }

  void setupFilter({
    required double cutoffFrequency,
    required double sampleRate,
    required int channelCountBuffer,
    required bool isFilterOn,
    required FilterType filterType,
    required Function(FilterSetup) onFilterSetup,
    required DataStatusProvider dataStatusProvider,
  }) {
    Provider.of<CustomRangeSliderProvider>(context, listen: false)
        .setEndValue(cutoffFrequency);

    final filterSettings = FilterSetup(
      filterConfiguration: FilterConfiguration(
        cutOffFrequency: cutoffFrequency.toInt(),
        sampleRate: sampleRate.toInt(),
      ),
      filterType: filterType,
      channelCount: channelCountBuffer,
      isFilterOn: isFilterOn,
    );

    if (filterType == FilterType.highPassFilter) {
      dataStatusProvider.setHighPassFilterSetting(filterSettings);
      onFilterSetup(filterSettings);
    } else if (filterType == FilterType.lowPassFilter) {
      dataStatusProvider.setLowPassFilterSetting(filterSettings);
      onFilterSetup(filterSettings);
    } else if (filterType == FilterType.notchFilter) {
      dataStatusProvider.setNotchPassFilterSetting(filterSettings);
    }
  }
}

----- END ./lib/widget/custom_slider_widget.dart -----

----- BEGIN ./lib/widget/draggable_widget.dart -----
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';

class DragGraphHorizontally extends StatefulWidget {
  const DragGraphHorizontally({super.key, required this.sliderWidget});

  final Widget sliderWidget;
  @override
  State<DragGraphHorizontally> createState() => _DragGraphHorizontallyState();
}

class _DragGraphHorizontallyState extends State<DragGraphHorizontally> {
  late DragDownDetails dragDownDetails;
  late DragUpdateDetails dragDetails;
  late DragUpdateDetails dragHorizontalDetails;
  num curTimeScaleBar = 1000;
  int horizontalDiff = 0;
  double prevY = 0.0;
  double scaleBarWidth = 2.0;
  num timeScale = 10000;
  ScaleUpdateDetails scaleDetails = ScaleUpdateDetails();
  int timeScaleBar = 80;
  List<double> arrTimeScale = [0.1, 1, 10, 50, 100, 500, 1000, 5000, 10000];

  bool isZooming = false;

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
        behavior: HitTestBehavior.translucent,
        onHorizontalDragUpdate: (DragUpdateDetails details) {
          dragHorizontalDetails = details;
        },
        onHorizontalDragDown: (DragDownDetails details) {
          dragDownDetails = details;
        },
        onHorizontalDragEnd: (DragEndDetails dragEndDetails) {},
        child: Listener(
          onPointerSignal: (PointerSignalEvent dragDetails) {
            if (dragDetails is PointerScrollEvent) {
              int direction = 0;

              if (dragDetails.kind != PointerDeviceKind.mouse) {
                return;
              }

              if (dragDetails.scrollDelta.dx == 0.0 &&
                  dragDetails.scrollDelta.dy == 0.0) {
                return;
              } else if (dragDetails.scrollDelta.dy < 0 &&
                  dragDetails.scrollDelta.dy > -500) {
                prevY = dragDetails.scrollDelta.dy;
                //down
                direction = -1;

                if (timeScaleBar - 1 < 10) {
                } else {
                  timeScaleBar--;
                }
              } else if (dragDetails.scrollDelta.dy > 0 &&
                  dragDetails.scrollDelta.dy < 500) {
                direction = 1;
                prevY = dragDetails.scrollDelta.dy;

                if (timeScaleBar + 1 > 80) {
                } else {
                  timeScaleBar++;
                }
              }
              int transformScale = (timeScaleBar / 10).floor();

              curTimeScaleBar = (arrTimeScale[transformScale] / 10);

              var data = {
                "timeScaleBar": arrTimeScale[transformScale], // label in UI
                "levelScale": timeScaleBar, //scrollIdx
                "posX": dragDetails.localPosition.dx,
                "direction": direction
              };

              if (timeScaleBar == -1) {
                timeScale = 1;
              } else {
                timeScale = arrTimeScale[transformScale];
              }

              if (timeScale == 10000) {
                horizontalDiff = 0;
                isZooming = false;
              } else {
                if (horizontalDiff > 0) {
                  isZooming = true;
                } else {
                  isZooming = false;
                }
              }
            }
          },
          child: widget.sliderWidget,
        ));
  }
}

----- END ./lib/widget/draggable_widget.dart -----

----- BEGIN ./lib/widget/show_dialog.dart -----
import 'package:flutter/material.dart';
import 'package:native_add/model/model.dart';
import 'package:spikerbox_architecture/widget/custom_button.dart';

class CustomDialogWidget extends StatefulWidget {
  CustomDialogWidget({
    super.key,
    required this.sampleRateController,
    required this.cutOffController,
    required this.title,
  });

  final TextEditingController sampleRateController;
  final TextEditingController cutOffController;
  final String title;

  @override
  State<CustomDialogWidget> createState() => _CustomDialogWidgetState();
}

class _CustomDialogWidgetState extends State<CustomDialogWidget> {
  final GlobalKey<FormState> _formKey = GlobalKey<FormState>();

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      actionsPadding: const EdgeInsets.all(12),
      title: Text(widget.title),
      actions: [
        Form(
          key: _formKey,
          child: Column(
            children: [
              TextFormField(
                controller: widget.sampleRateController,
                keyboardType: TextInputType.number,
                decoration: const InputDecoration(labelText: 'Sample Rate'),
                validator: (value) {
                  if (value!.isEmpty) {
                    return 'Please enter a sample Rate';
                  }
                  final channelCount = int.tryParse(value);
                  if (channelCount == null || channelCount <= 0) {
                    return 'Sample rate must be a positive';
                  }
                  return null; // Validation passed
                },
              ),
              TextFormField(
                controller: widget.cutOffController,
                keyboardType: TextInputType.number,
                decoration:
                    const InputDecoration(labelText: 'CutOff  frequency'),
                validator: (value) {
                  if (value!.isEmpty) {
                    return 'Please enter a CutOff frequency';
                  }
                  final channelCount = int.tryParse(value);
                  if (channelCount == null || channelCount <= 0) {
                    return 'CutOff frequency must be a positive integer';
                  }
                  return null; // Validation passed
                },
              ),
              CustomButton(
                onTap: () {
                  if (_formKey.currentState!.validate()) {
                    FilterSettings filterBase = FilterSettings(
                        cutOff: int.parse(widget.cutOffController.text),
                        sampleRate:
                            int.parse(widget.sampleRateController.text));

                    Navigator.of(context).pop(filterBase);
                  } // Close the dialog
                },
                childWidget: const Text('Done'),
              ),
            ],
          ),
        ),
      ],
    );
  }
}

----- END ./lib/widget/show_dialog.dart -----

----- BEGIN ./lib/widget/spiker_box_button.dart -----
import 'package:flutter/material.dart';
import 'package:spikerbox_architecture/constant/colors_constant.dart';

class SpikerBoxButton extends StatelessWidget {
  const SpikerBoxButton(
      {super.key,
      required this.onTapButton,
      this.iconSize,
      this.padding,
      this.iconColor,
      required this.iconData});
  final Function() onTapButton;
  final IconData iconData;
  final EdgeInsetsGeometry? padding;
  final Color? iconColor;
  final double? iconSize;

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: onTapButton,
      child: DecoratedBox(
        decoration: BoxDecoration(
          color: SoftwareColors.kButtonBackGroundColor,
          shape: BoxShape.circle,
        ),
        child: Padding(
          padding: padding ?? const EdgeInsets.all(12.0),
          child: Icon(
            iconData,
            size: iconSize ?? 25,
            color: iconColor ?? SoftwareColors.kButtonColor,
          ),
        ),
      ),
    );
  }
}


// InkWell(
//       onTap: ontap,
//       child: DecoratedBox(
//         decoration: BoxDecoration(
//           color: SoftwareColors.kButtonBackGroundColor,
//           shape: BoxShape.circle,
//         ),
//         child: Padding(
//           padding: padding ?? const EdgeInsets.all(12.0),
//           child: Icon(
//             iconData,
//             size: padding != null ? 28 : 35,
//             color: SoftwareColors.kButtonColor,
//           ),
//         ),
//       ),
//     );

----- END ./lib/widget/spiker_box_button.dart -----

----- BEGIN ./lib/widget/theme_colors.dart -----
import 'package:flutter/material.dart';

class ThemeColors {
  static const Map<int, Color> myColor = {
    50: Color.fromARGB(255, 182, 228, 233),
    100: Color.fromARGB(255, 155, 217, 224),
    200: Color.fromARGB(255, 128, 199, 207),
    300: Color.fromARGB(255, 111, 194, 203),
    400: Color.fromARGB(255, 95, 184, 194),
    500: Color.fromARGB(255, 64, 160, 171),
    600: Color.fromARGB(255, 44, 145, 156),
    700: Color.fromARGB(255, 30, 143, 155),
    800: Color(0xff108E9B),
    900: Color.fromARGB(255, 7, 107, 118),
  };

  final MaterialColor themeColorCustom =
      const MaterialColor(0xff108E9B, myColor);
  static const Color negativeActionColor = Color.fromRGBO(175, 0, 0, 1);
  static const Color customZincColor = Color.fromARGB(255, 137, 137, 137);
  static const Color customSteelColor = Color.fromARGB(255, 91, 91, 91);
  static const Color customNavyBlueColor = Color.fromARGB(255, 67, 67, 91);
  static const Color customYellowColor = Color.fromARGB(255, 247, 167, 7);
  static const Color customLightGreyColor = Color.fromARGB(255, 235, 236, 236);
  static const Color customGreyColor = Color.fromARGB(255, 197, 198, 198);
  static const Color customDarkGreyColor = Color.fromARGB(255, 157, 158, 158);
}

----- END ./lib/widget/theme_colors.dart -----

----- BEGIN ./lib/widget/water_droplet.dart -----
import 'package:flutter/material.dart';

class DropletPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    var paint = Paint()
      ..color = Colors.green
      ..style = PaintingStyle.fill;

    var path = Path();
    path.moveTo(0, size.height * 0.5); // Start from the middle left
    path.quadraticBezierTo(
        size.width * 0.2,
        size.height * 1.4, // Curve outward to the bottom
        size.width,
        size.height * 0.5); // Pointed edge to the right
    path.quadraticBezierTo(
        size.width * 0.2,
        size.height * -0.4, // Curve inward to the top
        0,
        size.height * 0.5); // Back to start

    path.close();

    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) {
    return false;
  }
}

----- END ./lib/widget/water_droplet.dart -----

----- BEGIN ./lib/widget/white_checkbox_widget.dart -----
import 'package:flutter/material.dart';
import 'package:spikerbox_architecture/constant/const_export.dart';

class WhiteColorCheckBox extends StatefulWidget {
  WhiteColorCheckBox({
    super.key,
    required this.onChanged,
    required this.valueStatus,
  });

  bool? valueStatus;
  final Function(bool?) onChanged;

  @override
  State<WhiteColorCheckBox> createState() => _WhiteColorCheckBoxState();
}

class _WhiteColorCheckBoxState extends State<WhiteColorCheckBox> {
  @override
  Widget build(BuildContext context) {
    return Theme(
      data: ThemeData(unselectedWidgetColor: Colors.white),
      child: Checkbox(
        activeColor: SoftwareColors.kGraphColor,
        checkColor: Colors.white,
        onChanged: widget.onChanged,
        value: widget.valueStatus,
      ),
    );
  }
}

----- END ./lib/widget/white_checkbox_widget.dart -----

----- BEGIN ./lib/widget/widget_export.dart -----
export 'callback_button.dart';
export 'chart.dart';
export 'custom_button.dart';
export 'draggable_widget.dart';
export 'custom_slider_widget.dart';
export 'show_dialog.dart';
export 'spiker_box_button.dart';
export 'theme_colors.dart';
export 'water_droplet.dart';
export 'white_checkbox_widget.dart';

----- END ./lib/widget/widget_export.dart -----

----- BEGIN ./linux/main.cc -----
#include "my_application.h"

int main(int argc, char** argv) {
  g_autoptr(MyApplication) app = my_application_new();
  return g_application_run(G_APPLICATION(app), argc, argv);
}

----- END ./linux/main.cc -----

----- BEGIN ./linux/my_application.cc -----
#include "my_application.h"

#include <flutter_linux/flutter_linux.h>
#ifdef GDK_WINDOWING_X11
#include <gdk/gdkx.h>
#endif

#include "flutter/generated_plugin_registrant.h"

struct _MyApplication {
  GtkApplication parent_instance;
  char** dart_entrypoint_arguments;
};

G_DEFINE_TYPE(MyApplication, my_application, GTK_TYPE_APPLICATION)

// Implements GApplication::activate.
static void my_application_activate(GApplication* application) {
  MyApplication* self = MY_APPLICATION(application);
  GtkWindow* window =
      GTK_WINDOW(gtk_application_window_new(GTK_APPLICATION(application)));

  // Use a header bar when running in GNOME as this is the common style used
  // by applications and is the setup most users will be using (e.g. Ubuntu
  // desktop).
  // If running on X and not using GNOME then just use a traditional title bar
  // in case the window manager does more exotic layout, e.g. tiling.
  // If running on Wayland assume the header bar will work (may need changing
  // if future cases occur).
  gboolean use_header_bar = TRUE;
#ifdef GDK_WINDOWING_X11
  GdkScreen* screen = gtk_window_get_screen(window);
  if (GDK_IS_X11_SCREEN(screen)) {
    const gchar* wm_name = gdk_x11_screen_get_window_manager_name(screen);
    if (g_strcmp0(wm_name, "GNOME Shell") != 0) {
      use_header_bar = FALSE;
    }
  }
#endif
  if (use_header_bar) {
    GtkHeaderBar* header_bar = GTK_HEADER_BAR(gtk_header_bar_new());
    gtk_widget_show(GTK_WIDGET(header_bar));
    gtk_header_bar_set_title(header_bar, "spikerbox_architecture");
    gtk_header_bar_set_show_close_button(header_bar, TRUE);
    gtk_window_set_titlebar(window, GTK_WIDGET(header_bar));
  } else {
    gtk_window_set_title(window, "spikerbox_architecture");
  }

  gtk_window_set_default_size(window, 1280, 720);
  gtk_widget_show(GTK_WIDGET(window));

  g_autoptr(FlDartProject) project = fl_dart_project_new();
  fl_dart_project_set_dart_entrypoint_arguments(project, self->dart_entrypoint_arguments);

  FlView* view = fl_view_new(project);
  gtk_widget_show(GTK_WIDGET(view));
  gtk_container_add(GTK_CONTAINER(window), GTK_WIDGET(view));

  fl_register_plugins(FL_PLUGIN_REGISTRY(view));

  gtk_widget_grab_focus(GTK_WIDGET(view));
}

// Implements GApplication::local_command_line.
static gboolean my_application_local_command_line(GApplication* application, gchar*** arguments, int* exit_status) {
  MyApplication* self = MY_APPLICATION(application);
  // Strip out the first argument as it is the binary name.
  self->dart_entrypoint_arguments = g_strdupv(*arguments + 1);

  g_autoptr(GError) error = nullptr;
  if (!g_application_register(application, nullptr, &error)) {
     g_warning("Failed to register: %s", error->message);
     *exit_status = 1;
     return TRUE;
  }

  g_application_activate(application);
  *exit_status = 0;

  return TRUE;
}

// Implements GObject::dispose.
static void my_application_dispose(GObject* object) {
  MyApplication* self = MY_APPLICATION(object);
  g_clear_pointer(&self->dart_entrypoint_arguments, g_strfreev);
  G_OBJECT_CLASS(my_application_parent_class)->dispose(object);
}

static void my_application_class_init(MyApplicationClass* klass) {
  G_APPLICATION_CLASS(klass)->activate = my_application_activate;
  G_APPLICATION_CLASS(klass)->local_command_line = my_application_local_command_line;
  G_OBJECT_CLASS(klass)->dispose = my_application_dispose;
}

static void my_application_init(MyApplication* self) {}

MyApplication* my_application_new() {
  return MY_APPLICATION(g_object_new(my_application_get_type(),
                                     "application-id", APPLICATION_ID,
                                     "flags", G_APPLICATION_NON_UNIQUE,
                                     nullptr));
}

----- END ./linux/my_application.cc -----

----- BEGIN ./linux/my_application.h -----
#ifndef FLUTTER_MY_APPLICATION_H_
#define FLUTTER_MY_APPLICATION_H_

#include <gtk/gtk.h>

G_DECLARE_FINAL_TYPE(MyApplication, my_application, MY, APPLICATION,
                     GtkApplication)

/**
 * my_application_new:
 *
 * Creates a new Flutter-based application.
 *
 * Returns: a new #MyApplication.
 */
MyApplication* my_application_new();

#endif  // FLUTTER_MY_APPLICATION_H_

----- END ./linux/my_application.h -----

----- BEGIN ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/flutter_audio_waveforms.dart -----
export 'package:flutter_audio_waveforms/src/core/audio_waveform.dart';
export 'package:flutter_audio_waveforms/src/core/waveform_painters_ab.dart';
export 'package:flutter_audio_waveforms/src/util/waveform_alignment.dart';
export 'package:flutter_audio_waveforms/src/waveforms/curved_polygon_waveform/curved_polygon_waveform.dart';
export 'package:flutter_audio_waveforms/src/waveforms/polygon_waveform/polygon_waveform.dart';
export 'package:flutter_audio_waveforms/src/waveforms/rectangle_waveform/rectangle_waveform.dart';
export 'package:flutter_audio_waveforms/src/waveforms/squiggly_waveform/squiggly_waveform.dart';

----- END ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/flutter_audio_waveforms.dart -----

----- BEGIN ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/const/colors.dart -----
// ignore_for_file: public_member_api_docs

import 'package:flutter/material.dart';

const Color opaqueBlack = Color(0x00000000);

----- END ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/const/colors.dart -----

----- BEGIN ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/core/audio_waveform.dart -----
import 'dart:math' as math;

import 'package:flutter/material.dart';
import 'package:flutter_audio_waveforms/src/core/waveform_painters_ab.dart';
import 'package:flutter_audio_waveforms/src/util/check_samples_equality.dart';
import 'package:flutter_audio_waveforms/src/util/waveform_alignment.dart';

/// [AudioWaveform] is a custom StatefulWidget that other Waveform classes
/// extend to.
///
/// This class handles the common functionality, properties and provides the
/// most common waveform details to the subclasses. This details then can be
/// used by the [WaveformPainter] to paint the waveform.
///
/// Anything that can be shared and used across all waveforms should
/// be handled by this class.
///
abstract class AudioWaveform extends StatefulWidget {
  /// Constructor for [AudioWaveform]
  AudioWaveform({
    Key? key,
    required this.samples,
    required this.height,
    required this.width,
    required this.maxDuration,
    required this.elapsedDuration,
    required this.showActiveWaveform,
    this.absolute = false,
    this.invert = false,
  })  : assert(
          elapsedDuration.inMilliseconds <= maxDuration.inMilliseconds,
          'elapsedDuration must be less than or equal to maxDuration',
        ),
        assert(
          maxDuration.inMilliseconds > 0,
          'maxDuration must be greater than 0',
        ),
        waveformAlignment = absolute
            ? invert
                ? WaveformAlignment.top
                : WaveformAlignment.bottom
            : WaveformAlignment.center,
        super(key: key);

  /// Audio samples raw input.
  /// This raw samples are processed before being used to paint the waveform.
  final List<double> samples;

  /// Height of the canvas on which the waveform will be drawn.
  final double height;

  /// Width of the canvas on which the waveform will be drawn.
  final double width;

  /// Maximum duration of the audio.
  final Duration maxDuration;

  /// Elapsed duration of the audio.
  final Duration elapsedDuration;

  /// Makes the waveform absolute.
  /// Draws the waveform along the positive y-axis.
  /// Samples are processed such that we end up with positive sample values.
  final bool absolute;

  /// Inverts/Flips the waveform along x-axis.
  /// Samples are processed such that we end up with samples having opposite
  /// sign.
  final bool invert;

  /// Whether to show the active waveform or not.
  final bool showActiveWaveform;

  /// Alignment of the waveform in the canvas.
  @protected
  final WaveformAlignment waveformAlignment;

  @override
  AudioWaveformState<AudioWaveform> createState();
}

/// State of the [AudioWaveform]
abstract class AudioWaveformState<T extends AudioWaveform> extends State<T> {
  /// Samples after processing.
  /// This are used to paint the waveform.
  late List<double> _processedSamples;

  ///Getter for processed samples.
  List<double> get processedSamples => _processedSamples;

  late double _sampleWidth;

  ///Getter for sample width.
  double get sampleWidth => _sampleWidth;

  ///Method for subsclass to update the processed samples
  @protected
  // ignore: use_setters_to_change_properties
  void updateProcessedSamples(List<double> updatedSamples) {
    _processedSamples = updatedSamples;
  }

  /// Active index of the sample in the raw samples.
  ///
  /// Used to obtain the [activeSamples] for the audio as the
  /// audio progresses.
  /// This is calculated based on the [elapsedDuration], [maxDuration] and the
  /// raw samples.
  ///
  /// final elapsedTimeRatio = elapsedDuration.inMilliseconds / maxDuration.inMilliseconds;
  /// _activeIndex = (widget.samples.length * elapsedTimeRatio).round();
  late int _activeIndex;

  /// Active samples that are used to draw the ActiveWaveform.
  /// This are calculated using [_activeIndex] and are subList of the
  /// [_processedSamples] at any given time.
  late List<double> _activeSamples;

  ///Getter for active samples.
  List<double> get activeSamples => _activeSamples;

  ///Getter for maxDuration
  Duration get maxDuration => widget.maxDuration;

  ///getter for elapsedDuration
  Duration get elapsedDuration => widget.elapsedDuration;

  ///Whether to show active waveform or not
  bool get showActiveWaveform => widget.showActiveWaveform;

  ///Whether to invert/flip waveform or not
  bool get invert => widget.absolute ? !widget.invert : widget.invert;

  ///Whether to show absolute waveform or not
  bool get absolute => widget.absolute;

  ///Getter for waveformAlignment.
  WaveformAlignment get waveformAlignment => widget.waveformAlignment;

  /// Raw samples are processed before used following some
  /// techniques. This is to have consistent samples that can be used to draw
  /// the waveform properly.
  @protected
  void processSamples() {
    _processedSamples = widget.samples;
    // final rawSamples = widget.samples;

    // _processedSamples = rawSamples
    //     .map((e) => absolute ? e.abs() * widget.height : e * widget.height)
    //     .toList();

    // // final maxNum =
    // //     _processedSamples.reduce((a, b) => math.max(a.abs(), b.abs()));

    // //STEVANUS CHANGES
    // final maxNum = 300;

    // if (maxNum > 0) {
    //   final multiplier = math.pow(maxNum, -1).toDouble();
    //   final finalHeight = absolute ? widget.height : widget.height / 2;
    //   final finalMultiplier = multiplier * finalHeight;

    //   _processedSamples = _processedSamples
    //       .map(
    //         (e) => invert ? -e * finalMultiplier : e * finalMultiplier,
    //       )
    //       .toList();
    // }
  }

  /// Calculates the width that each sample would take.
  /// This is later used in the Painters to calculate the Offset along x-axis
  /// from the start for any sample while painting.
  void _calculateSampleWidth() {
    _sampleWidth = widget.width / (_processedSamples.length);
  }

  /// Updates the [_activeIndex] whenever the duration changes.
  @protected
  void _updateActiveIndex() {
    // if (activeIndex != null) {
    //   _activeIndex = activeIndex;

    //   return;
    // }
    final elapsedTimeRatio =
        elapsedDuration.inMilliseconds / maxDuration.inMilliseconds;

    _activeIndex = (widget.samples.length * elapsedTimeRatio).round();
  }

  /// Updates [_activeSamples] based on the [_activeIndex].
  @protected
  void _updateActiveSamples() {
    _activeSamples = _processedSamples.sublist(0, _activeIndex);
  }

  @override
  void initState() {
    super.initState();

    _processedSamples = widget.samples;
    _activeIndex = 0;
    _activeSamples = [];
    _sampleWidth = 0;

    if (_processedSamples.isNotEmpty) {
      processSamples();
      _calculateSampleWidth();
    }
  }

  @override
  void didUpdateWidget(covariant T oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (!checkforSamplesEquality(widget.samples, oldWidget.samples) &&
        widget.samples.isNotEmpty) {
      processSamples();
      _calculateSampleWidth();
      _updateActiveIndex();
      _updateActiveSamples();
    }
    if (widget.showActiveWaveform) {
      if (widget.elapsedDuration != oldWidget.elapsedDuration) {
        _updateActiveIndex();
        _updateActiveSamples();
      }
    }
    if (widget.height != oldWidget.height || widget.width != oldWidget.width) {
      processSamples();
      _calculateSampleWidth();
      _updateActiveSamples();
    }
    if (widget.absolute != oldWidget.absolute) {
      processSamples();
      _updateActiveSamples();
    }
    if (widget.invert != oldWidget.invert) {
      processSamples();
      _updateActiveSamples();
    }
  }
}

----- END ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/core/audio_waveform.dart -----

----- BEGIN ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/core/waveform_painters_ab.dart -----
import 'package:flutter/material.dart';
import 'package:flutter_audio_waveforms/src/const/colors.dart';
import 'package:flutter_audio_waveforms/src/util/check_samples_equality.dart';
import 'package:flutter_audio_waveforms/src/util/waveform_alignment.dart';

/// A Painter class that all the types of Waveform Painters extend to.
/// The memebers of this class are essential to paint any type of waveform.
abstract class WaveformPainter extends CustomPainter {
  /// Constructor for the WaveformPainter.
  WaveformPainter({
    required this.samples,
    required this.color,
    required this.gradient,
    required this.waveformAlignment,
    required this.sampleWidth,
    required this.style,
  });

  /// Samples that are used to paint the waveform.
  final List<double> samples;

  /// Color of the waveform.
  final Color color;

  /// Gradient of the waveform.
  final Gradient? gradient;

  /// Alignment of the waveform.
  final WaveformAlignment waveformAlignment;

  /// Width of each sample.
  final double sampleWidth;

  /// The style of the waveform.
  final PaintingStyle style;
}

/// A Painter class that all other ActiveWaveform Painters extend to.
/// The members declared in this class are essential to draw ActiveWaveforms.
/// This types of waveform painters draws the active part of the waveform of
/// the audio being played.

abstract class ActiveWaveformPainter extends WaveformPainter {
  // ignore: public_member_api_docs
  ActiveWaveformPainter({
    required Color color,
    required Gradient? gradient,
    // Do we really need to pass the samples here?. I believe
    // [ActiveWaveformPainter] should only care about the [activeSamples] value.
    // If [samples] changes, then [activeSamples] should change as well so it's
    // redundant to check for [samples] equality and to pass them here.
    // Only if ActiveWaveformPainter depends on samples in future for any
    // reasons, then we should pass them here.
    // required List<double> samples,
    required double sampleWidth,
    required this.activeSamples,
    required WaveformAlignment waveformAlignment,
    PaintingStyle style = PaintingStyle.stroke,
    this.borderWidth = 0.0,
    this.borderColor = opaqueBlack,
  }) : super(
          samples: [], //samples,
          color: color,
          gradient: gradient,
          waveformAlignment: waveformAlignment,
          sampleWidth: sampleWidth,
          style: style,
        );

  ///The active samples used to paint the waveform.
  final List<double> activeSamples;

  /// Stroke/Border Width
  final double borderWidth;

  /// Stroke/Border Width
  final Color borderColor;

  /// Whether the waveform should be rePainted or not.
  @override
  bool shouldRepaint(covariant ActiveWaveformPainter oldDelegate) {
    return !checkforSamplesEquality(activeSamples, oldDelegate.activeSamples) ||
        color != oldDelegate.color ||
        gradient != oldDelegate.gradient ||
        waveformAlignment != oldDelegate.waveformAlignment ||
        sampleWidth != oldDelegate.sampleWidth ||
        style != oldDelegate.style ||
        borderWidth != oldDelegate.borderWidth ||
        borderColor != oldDelegate.borderColor;
  }
}

/// A Painter class that all other InActiveWaveform Painters extend to.
/// This types of waveform painters draws the whole waveform of the audio
/// being played.
abstract class InActiveWaveformPainter extends WaveformPainter {
  // ignore: public_member_api_docs
  InActiveWaveformPainter({
    required Color color,
    required Gradient? gradient,
    required List<double> samples,
    required WaveformAlignment waveformAlignment,
    required double sampleWidth,
    PaintingStyle style = PaintingStyle.stroke,
    this.borderWidth = 0.0,
    this.borderColor = opaqueBlack,
  }) : super(
          samples: samples,
          color: color,
          gradient: gradient,
          waveformAlignment: waveformAlignment,
          sampleWidth: sampleWidth,
          style: style,
        );

  /// Stroke/Border Width
  final double borderWidth;

  /// Stroke/Border Width
  final Color borderColor;

  /// Whether the waveform should be rePainted or not.
  @override
  bool shouldRepaint(covariant InActiveWaveformPainter oldDelegate) {
    return !checkforSamplesEquality(samples, oldDelegate.samples) ||
        color != oldDelegate.color ||
        gradient != oldDelegate.gradient ||
        waveformAlignment != oldDelegate.waveformAlignment ||
        sampleWidth != oldDelegate.sampleWidth ||
        style != oldDelegate.style ||
        borderWidth != oldDelegate.borderWidth ||
        borderColor != oldDelegate.borderColor;
  }
}

/// A Painter class that all other ActiveInActiveWaveform Painters extend to.
/// The members of this class are essential to draw any waveform that manages
/// the painting of both active and inActive waveform within itself.
abstract class ActiveInActiveWaveformPainter extends WaveformPainter {
  // ignore: public_member_api_docs
  ActiveInActiveWaveformPainter({
    required this.activeColor,
    required List<double> samples,
    required double sampleWidth,
    required this.inactiveColor,
    required this.activeRatio,
    required WaveformAlignment waveformAlignment,
    PaintingStyle style = PaintingStyle.stroke,
    required this.strokeWidth,
  }) : super(
          samples: samples,
          color: inactiveColor,
          gradient: null,
          waveformAlignment: waveformAlignment,
          sampleWidth: sampleWidth,
          style: style,
        );

  ///The color of the active waveform.
  final Color inactiveColor;

  ///The color of the inactive waveform.
  final Color activeColor;

  ///The ratio of the elapsedDuration to the maxDuration.
  final double activeRatio;

  /// Stroke Width
  final double strokeWidth;

  /// Whether the waveform should be rePainted or not.
  @override
  bool shouldRepaint(covariant ActiveInActiveWaveformPainter oldDelegate) {
    return activeRatio != oldDelegate.activeRatio ||
        activeColor != oldDelegate.activeColor ||
        inactiveColor != oldDelegate.inactiveColor ||
        !checkforSamplesEquality(samples, oldDelegate.samples) ||
        color != oldDelegate.color ||
        gradient != oldDelegate.gradient ||
        waveformAlignment != oldDelegate.waveformAlignment ||
        sampleWidth != oldDelegate.sampleWidth ||
        strokeWidth != oldDelegate.strokeWidth ||
        style != oldDelegate.style;
  }
}

----- END ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/core/waveform_painters_ab.dart -----

----- BEGIN ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/util/check_samples_equality.dart -----
import 'package:collection/collection.dart';

/// Checks for new and old samples equality to decide whether to process samples
/// again or not when samples are updated.
bool Function(List<double> list1, List<double> list2) checkforSamplesEquality =
    const ListEquality<double>().equals;

----- END ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/util/check_samples_equality.dart -----

----- BEGIN ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/util/waveform_alignment.dart -----
///Waveform align enum
enum WaveformAlignment {
  ///Aligns waveform to the top of the canvas.
  top,

  ///Aligns waveform to the center of the canvas.

  center,

  ///Aligns waveform to the bottom of the canvas.

  bottom,
}

///Extension to get Offset height based on waveform align
extension WaveformAlignmentExtension on WaveformAlignment {
  ///Gets offset height based on waveform align
  double getAlignPosition(double height) {
    switch (this) {
      case WaveformAlignment.top:
        return 0;
      case WaveformAlignment.center:
        return height / 2;
      case WaveformAlignment.bottom:
        return height;
    }
  }
}

----- END ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/util/waveform_alignment.dart -----

----- BEGIN ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/waveforms/curved_polygon_waveform/active_inactive_waveform_painter.dart -----
import 'dart:developer';
import 'package:flutter/material.dart';
import 'package:flutter_audio_waveforms/src/core/waveform_painters_ab.dart';
import 'package:flutter_audio_waveforms/src/util/waveform_alignment.dart';
import 'package:flutter_audio_waveforms/src/waveforms/polygon_waveform/polygon_waveform.dart';

///InActiveWaveformPainter for the [PolygonWaveform]
class CurvedPolygonActiveInActiveWaveformPainter
    extends ActiveInActiveWaveformPainter {
  // ignore: public_member_api_docs
  CurvedPolygonActiveInActiveWaveformPainter({
    required List<double> samples,
    required WaveformAlignment waveformAlignment,
    required double sampleWidth,
    required double activeRatio,
    required Color inactiveColor,
    required Color activeColor,
    required double strokeWidth,
    required PaintingStyle style,
  }) : super(
          samples: samples,
          waveformAlignment: waveformAlignment,
          sampleWidth: sampleWidth,
          activeColor: activeColor,
          activeRatio: activeRatio,
          inactiveColor: inactiveColor,
          strokeWidth: strokeWidth,
          style: style,
        );

  @override
  // ignore: long-method
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..style = style
      ..color = color
      ..strokeJoin = StrokeJoin.round
      ..strokeCap = StrokeCap.round
      ..strokeWidth = strokeWidth
      ..shader = LinearGradient(
        begin: const Alignment(-1.001, 0),
        end: const Alignment(1.001, 0),
        colors: [
          activeColor,
          inactiveColor,
        ],
        stops: [activeRatio, 0],
      ).createShader(
        Rect.fromLTWH(0, 0, size.width, size.height),
      );

    final path = Path();

    final bezierSamplesList = <double>[];
    for (var i = 0; i < samples.length; i++) {
      final currentPoint = samples[i];
      final nextPoint = i + 1 > samples.length - 1 ? 0.0 : samples[i + 1];
      bezierSamplesList.add(currentPoint);
      // Addition of this two average points helps to get that curved effect.
      final averagePoint = (nextPoint + currentPoint) / 2;
      bezierSamplesList.add(averagePoint);
      final averagePoint2 = (nextPoint + averagePoint) / 2;
      bezierSamplesList.add(averagePoint2);
    }

    bezierSamplesList.add(0);
    final updatedWidth = size.width / bezierSamplesList.length;

    for (var i = 0; i < bezierSamplesList.length; i += 3) {
      final x = updatedWidth * i;
      final y = bezierSamplesList[i];
      final doNotDrawPath = i + 1 > bezierSamplesList.length - 1 ||
          i + 2 > bezierSamplesList.length - 1 ||
          i + 3 > bezierSamplesList.length - 1;

      if (!doNotDrawPath) {
        final x1 = updatedWidth * (i + 1);
        final y1 = bezierSamplesList[i + 1];
        final x2 = updatedWidth * (i + 2);
        final y2 = bezierSamplesList[i + 2];

        path.cubicTo(x, y, x1, y1, x2, y2);
      }
    }

    //Gets the [alignPosition] depending on [waveformAlignment]
    final alignPosition = waveformAlignment.getAlignPosition(size.height);

    //Shifts the path along y-axis by amount of [alignPosition]
    final shiftedPath = path.shift(Offset(0, alignPosition));

    canvas.drawPath(shiftedPath, paint);
  }
}

----- END ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/waveforms/curved_polygon_waveform/active_inactive_waveform_painter.dart -----

----- BEGIN ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/waveforms/curved_polygon_waveform/curved_polygon_waveform.dart -----
import 'package:flutter/material.dart';
import 'package:flutter_audio_waveforms/src/core/audio_waveform.dart';
import 'package:flutter_audio_waveforms/src/core/waveform_painters_ab.dart';
import 'package:flutter_audio_waveforms/src/waveforms/curved_polygon_waveform/active_inactive_waveform_painter.dart';

/// [CurvedPolygonWaveform] paints a squiggly waveform.
/// The painter for this waveform is of the type [ActiveInActiveWaveformPainter]
///
/// {@tool snippet}
/// Example :
/// ```dart
/// CurvedPolygonWaveform(
///   maxDuration: maxDuration,
///   elapsedDuration: elapsedDuration,
///   samples: samples,
///   height: 300,
///   width: MediaQuery.of(context).size.width,
/// )
///```
/// {@end-tool}
class CurvedPolygonWaveform extends AudioWaveform {
  // ignore: public_member_api_docs
  CurvedPolygonWaveform({
    Key? key,
    required List<double> samples,
    required double height,
    required double width,
    required Duration maxDuration,
    required Duration elapsedDuration,
    this.activeColor = Colors.red,
    this.inactiveColor = Colors.blue,
    this.strokeWidth = 1.0,
    this.style = PaintingStyle.stroke,
    bool showActiveWaveform = true,
    bool absolute = false,
    bool invert = false,
  })  : assert(strokeWidth >= 0, "strokeWidth can't be negative."),
        super(
          key: key,
          samples: samples,
          height: height,
          width: width,
          maxDuration: maxDuration,
          elapsedDuration: elapsedDuration,
          absolute: absolute,
          invert: invert,
          showActiveWaveform: showActiveWaveform,
        );

  /// The color of the active portion of the waveform.
  final Color activeColor;

  /// The color of the inactive portion of the waveform.
  final Color inactiveColor;

  /// The stroke width of the waveform.
  final double strokeWidth;

  /// waveform style
  final PaintingStyle style;

  @override
  AudioWaveformState<CurvedPolygonWaveform> createState() =>
      _SquigglyWaveformState();
}

class _SquigglyWaveformState extends AudioWaveformState<CurvedPolygonWaveform> {
  @override
  Widget build(BuildContext context) {
    if (widget.samples.isEmpty) {
      return const SizedBox.shrink();
    }
    final processedSamples = this.processedSamples;
    final activeRatio = showActiveWaveform
        ? elapsedDuration.inMilliseconds / maxDuration.inMilliseconds
        : 0.0;
    final waveformAlignment = this.waveformAlignment;

    return RepaintBoundary(
      child: CustomPaint(
        size: Size(widget.width, widget.height),
        isComplex: true,
        painter: CurvedPolygonActiveInActiveWaveformPainter(
          samples: processedSamples,
          activeColor: widget.activeColor,
          inactiveColor: widget.inactiveColor,
          activeRatio: activeRatio,
          waveformAlignment: waveformAlignment,
          strokeWidth: widget.strokeWidth,
          sampleWidth: sampleWidth,
          style: widget.style,
        ),
      ),
    );
  }
}

----- END ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/waveforms/curved_polygon_waveform/curved_polygon_waveform.dart -----

----- BEGIN ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/waveforms/polygon_waveform/active_waveform_painter.dart -----
import 'dart:developer';

import 'package:flutter/material.dart';
import 'package:flutter_audio_waveforms/src/util/waveform_alignment.dart';
import 'package:flutter_audio_waveforms/src/core/waveform_painters_ab.dart';
import 'package:flutter_audio_waveforms/src/waveforms/polygon_waveform/polygon_waveform.dart';

///ActiveWaveformPainter for the [PolygonWaveform]
class PolygonActiveWaveformPainter extends ActiveWaveformPainter {
  // ignore: public_member_api_docs
  PolygonActiveWaveformPainter({
    required Color color,
    Gradient? gradient,
    required List<double> activeSamples,
    required WaveformAlignment waveformAlignment,
    required PaintingStyle style,
    required double sampleWidth,
  }) : super(
          color: color,
          gradient: gradient,
          activeSamples: activeSamples,
          waveformAlignment: waveformAlignment,
          sampleWidth: sampleWidth,
          style: style,
        );

  @override
  void paint(Canvas canvas, Size size) {
    final continousActivePaint = Paint()
      ..style = style
      ..color = color
      ..shader = gradient?.createShader(
        Rect.fromLTWH(0, 0, size.width, size.height),
      );

    final path = Path();
    final isStroked = style == PaintingStyle.stroke;

    for (var i = 0; i < activeSamples.length; i++) {
      final x = sampleWidth * i;
      final y = activeSamples[i];
      if (isStroked) {
        path.lineTo(x, y);
      } else {
        if (i == activeSamples.length - 1) {
          path.lineTo(x, 0);
        } else {
          path.lineTo(x, y);
        }
      }
    }

    //Gets the [alignPosition] depending on [waveformAlignment]
    final alignPosition = waveformAlignment.getAlignPosition(size.height);

    //Shifts the path along y-axis by amount of [alignPosition]
    final shiftedPath = path.shift(Offset(0, alignPosition));

    canvas.drawPath(shiftedPath, continousActivePaint);
  }
}

----- END ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/waveforms/polygon_waveform/active_waveform_painter.dart -----

----- BEGIN ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/waveforms/polygon_waveform/inactive_waveform_painter.dart -----
// ignore_for_file: omit_local_variable_types

import 'package:flutter/material.dart';
import 'package:flutter_audio_waveforms/src/core/waveform_painters_ab.dart';
import 'package:flutter_audio_waveforms/src/util/waveform_alignment.dart';
import 'package:flutter_audio_waveforms/src/waveforms/polygon_waveform/polygon_waveform.dart';

///InActiveWaveformPainter for the [PolygonWaveform]
class PolygonInActiveWaveformPainter extends InActiveWaveformPainter {
  // ignore: public_member_api_docs
  PolygonInActiveWaveformPainter({
    Color color = Colors.red,
    Gradient? gradient,
    required List<double> samples,
    required WaveformAlignment waveformAlignment,
    required PaintingStyle style,
    required double sampleWidth,
    this.channelIdx = 0,
    this.channelActive = 1,
    this.gain = 100,
    this.levelMedian = -1,
    this.strokeWidth = 0.5,
    this.eventMarkersNumber = 1,
    this.eventMarkersPosition = const [],
  }) : super(
          samples: samples,
          color: color,
          gradient: gradient,
          waveformAlignment: waveformAlignment,
          sampleWidth: sampleWidth,
          style: style,
        ) {
    mypaint = Paint()
      ..style = style
      ..isAntiAlias = false
      ..shader = null
      ..color = color
      ..strokeWidth = strokeWidth;

    // ignore: omit_local_variable_types
    for (int i = 0; i < 10; i++) {
      final strMarkerNumber = ' $i ';
      final TextSpan span = TextSpan(
        style:
            TextStyle(color: Colors.black, backgroundColor: MARKER_COLORS[i]),
        text: strMarkerNumber,
      );
      final TextPainter tp = TextPainter(
        text: span,
        textAlign: TextAlign.center,
        textDirection: TextDirection.ltr,
      );
      tp.layout();
      textPainters.add(tp);
    }
  }

  // ignore: public_member_api_docs
  final int channelIdx;
  final int channelActive;
  final double gain;
  final double levelMedian;
  final double strokeWidth;
  final int eventMarkersNumber;
  final List<double> eventMarkersPosition;

  double prevMax = 0;
  double curMax = 0;

  List<TextPainter> textPainters = [];
  late Paint mypaint;

  @override
  bool shouldRepaint(PolygonInActiveWaveformPainter oldDelegate) {
    if (oldDelegate.gain != gain ||
        oldDelegate.samples != samples ||
        oldDelegate.levelMedian != levelMedian ||
        oldDelegate.eventMarkersPosition != eventMarkersPosition) {
      return true;
    }
    return false;
  }

  /// Style of the waveform
  int sign = 1;

  // https://groups.google.com/g/flutter-dev/c/Za4M3U_MaAo?pli=1
  // Performance textPainter vs Paragraph https://stackoverflow.com/questions/51640388/flutter-textpainter-vs-paragraph-for-drawing-book-page
  @override
  void paint(Canvas canvas, Size size) {
    try {
      // final Rect clipRect = Rect.fromPoints(
      //   Offset.zero,
      //   Offset(size.width, size.height),
      // );

      // canvas.clipRect(clipRect);

      final path = Path();
      int i = 0;
      for (; i < samples.length - 1; i++) {
        final x = sampleWidth * i;
        final y = samples[i] * gain;
        if (i == 0) {
          path.moveTo(x, y);
        } else {
          path.lineTo(x, y);
        }
        // if (i < 10) {
        //   print("values at index $i : ${samples[i]}");
        // }
        // if (i == 0) {
        //   path.moveTo(x, y);
        // } else {
        //   path.lineTo(x, y);
        // }
      }

      final shiftedPath = path.shift(Offset(0, levelMedian));
      canvas.drawPath(shiftedPath, mypaint);
      if (eventMarkersPosition.isNotEmpty && channelIdx == channelActive) {
        var n = eventMarkersPosition.length;
        double prevX = -1;
        double counterStacked = 10;
        double evY = 0;
        if (channelIdx == 2) {
          evY = -50;
        }

        // try{
        for (i = 0; i < n; i++) {
          if (eventMarkersPosition[i] == 0) {
            continue;
          }
          final evX = eventMarkersPosition[i];
          final offset1 = Offset(evX, evY);
          final offset2 = Offset(evX, 2900);

          canvas.drawLine(
            offset1,
            offset2,
            MARKER_PAINT[eventMarkersNumber],
          );
          final TextPainter tp = textPainters[eventMarkersNumber];
          counterStacked = i > 0 && evX - 20 <= prevX ? 30 : 100;
          prevX = evX;
          tp.paint(canvas, Offset(evX - 3, counterStacked));
        }
      }
    } catch (err) {
      print("errx");
      print(err);
    }
  }
}

List<Color> MARKER_COLORS = const [
  Color.fromARGB(255, 216, 180, 231),
  Color.fromARGB(255, 176, 229, 124),
  Color.fromARGB(255, 255, 80, 0), //orange
  Color.fromARGB(255, 255, 236, 148),
  Color.fromARGB(255, 255, 174, 174),
  Color.fromARGB(255, 180, 216, 231),
  Color.fromARGB(255, 193, 218, 214),
  Color.fromARGB(255, 172, 209, 233),
  Color.fromARGB(255, 174, 255, 174),
  Color.fromARGB(255, 255, 236, 255),
];
List<Paint> MARKER_PAINT = [
  Paint()
    ..style = PaintingStyle.stroke
    ..color = MARKER_COLORS[0]
    ..strokeWidth = 1,
  Paint()
    ..style = PaintingStyle.stroke
    ..color = MARKER_COLORS[1]
    ..strokeWidth = 1,
  Paint()
    ..style = PaintingStyle.stroke
    ..color = MARKER_COLORS[2]
    ..strokeWidth = 1,
  Paint()
    ..style = PaintingStyle.stroke
    ..color = MARKER_COLORS[3]
    ..strokeWidth = 1,
  Paint()
    ..style = PaintingStyle.stroke
    ..color = MARKER_COLORS[4]
    ..strokeWidth = 1,
  Paint()
    ..style = PaintingStyle.stroke
    ..color = MARKER_COLORS[5]
    ..strokeWidth = 1,
  Paint()
    ..style = PaintingStyle.stroke
    ..color = MARKER_COLORS[6]
    ..strokeWidth = 1,
  Paint()
    ..style = PaintingStyle.stroke
    ..color = MARKER_COLORS[7]
    ..strokeWidth = 1,
  Paint()
    ..style = PaintingStyle.stroke
    ..color = MARKER_COLORS[8]
    ..strokeWidth = 1,
  Paint()
    ..style = PaintingStyle.stroke
    ..color = MARKER_COLORS[9]
    ..strokeWidth = 1,
];

----- END ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/waveforms/polygon_waveform/inactive_waveform_painter.dart -----

----- BEGIN ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/waveforms/polygon_waveform/polygon_waveform.dart -----
import 'package:flutter/material.dart';
import 'package:flutter_audio_waveforms/flutter_audio_waveforms.dart';
import 'package:flutter_audio_waveforms/src/waveforms/polygon_waveform/inactive_waveform_painter.dart';

/// [PolygonWaveform] paints the standard waveform that is used for audio
/// waveforms, a sharp continuous line joining the points of a waveform.
///
/// {@tool snippet}
/// Example :
/// ```dart
/// PolygonWaveform(
///   maxDuration: maxDuration,
///   elapsedDuration: elapsedDuration,
///   samples: samples,
///   height: 300,
///   width: MediaQuery.of(context).size.width,
/// )
///```
/// {@end-tool}
class PolygonWaveform extends AudioWaveform {
  // ignore: public_member_api_docs
  PolygonWaveform({
    Key? key,
    required List<double> samples,
    required double height,
    required double width,
    required Duration maxDuration,
    required Duration elapsedDuration,
    this.activeColor = Colors.red,
    this.inactiveColor = Colors.blue,
    this.activeGradient,
    this.inactiveGradient,
    this.style = PaintingStyle.stroke,
    bool showActiveWaveform = true,
    bool absolute = false,
    bool invert = false,
    this.channelIdx = 0,
    this.channelActive = 0,
    this.gain = 1000,
    this.levelMedian = -1,
    this.strokeWidth = 1,
    this.eventMarkersNumber = 1,
    this.eventMarkersPosition = const [],
  }) : super(
          key: key,
          samples: samples,
          height: height,
          width: width,
          maxDuration: maxDuration,
          elapsedDuration: elapsedDuration,
          showActiveWaveform: showActiveWaveform,
          absolute: absolute,
          invert: invert,
        );

  /// active waveform color
  final Color activeColor;

  /// inactive waveform color
  final Color inactiveColor;

  /// active waveform gradient
  final Gradient? activeGradient;

  /// inactive waveform gradient
  final Gradient? inactiveGradient;

  /// waveform style
  final PaintingStyle style;

  final int channelIdx;
  final int channelActive;
  final double gain;
  final double levelMedian;
  final double strokeWidth;

  final int eventMarkersNumber;
  final List<double> eventMarkersPosition;

  @override
  AudioWaveformState<PolygonWaveform> createState() => _PolygonWaveformState();
}

class _PolygonWaveformState extends AudioWaveformState<PolygonWaveform> {
  @override
  final bool showActiveWaveform = true;

  @override
  WaveformAlignment waveformAlignment = WaveformAlignment.center;

  @override
  Widget build(BuildContext context) {
    return RepaintBoundary(
      child: CustomPaint(
        size: Size(double.infinity, widget.height),
        isComplex: false,
        willChange: true,
        painter: PolygonInActiveWaveformPainter(
          samples: processedSamples,
          style: widget.style,
          channelIdx: widget.channelIdx,
          channelActive: widget.channelActive,
          color: widget.inactiveColor,
          gradient: widget.inactiveGradient,
          waveformAlignment: waveformAlignment,
          sampleWidth: sampleWidth,
          gain: widget.gain,
          levelMedian: widget.levelMedian,
          strokeWidth: widget.strokeWidth,
          eventMarkersNumber: widget.eventMarkersNumber,
          eventMarkersPosition: widget.eventMarkersPosition,
        ),
      ),
    );
  }
}

----- END ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/waveforms/polygon_waveform/polygon_waveform.dart -----

----- BEGIN ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/waveforms/rectangle_waveform/active_waveform_painter.dart -----
import 'package:flutter/material.dart';
import 'package:flutter_audio_waveforms/src/core/waveform_painters_ab.dart';
import 'package:flutter_audio_waveforms/src/util/waveform_alignment.dart';
import 'package:flutter_audio_waveforms/src/waveforms/rectangle_waveform/rectangle_waveform.dart';

///ActiveWaveformPainter for the [RectangleWaveform]
class RectangleActiveWaveformPainter extends ActiveWaveformPainter {
  // ignore: public_member_api_docs
  RectangleActiveWaveformPainter({
    required Color color,
    required List<double> activeSamples,
    required WaveformAlignment waveformAlignment,
    required double sampleWidth,
    required Color borderColor,
    required double borderWidth,
    Gradient? gradient,
  }) : super(
          color: color,
          gradient: gradient,
          activeSamples: activeSamples,
          waveformAlignment: waveformAlignment,
          sampleWidth: sampleWidth,
          borderColor: borderColor,
          borderWidth: borderWidth,
          style: PaintingStyle.fill,
        );

  @override
  void paint(Canvas canvas, Size size) {
    final activeTrackPaint = Paint()
      ..style = style
      ..color = color
      ..shader = gradient?.createShader(
        Rect.fromLTWH(0, 0, size.width, size.height),
      );

    final borderPaint = Paint()
      ..style = PaintingStyle.stroke
      ..color = borderColor
      ..strokeWidth = borderWidth;

    //Gets the [alignPosition] depending on [waveformAlignment]
    final alignPosition = waveformAlignment.getAlignPosition(size.height);

    for (var i = 0; i < activeSamples.length; i++) {
      final x = sampleWidth * i;
      final y = activeSamples[i];

      //Draws the filled rectangles of the waveform.
      canvas
        ..drawRect(
          Rect.fromLTWH(x, alignPosition, sampleWidth, y),
          activeTrackPaint,
        )
        //Draws the border for the rectangles of the waveform.
        ..drawRect(
          Rect.fromLTWH(x, alignPosition, sampleWidth, y),
          borderPaint,
        );
    }
  }
}

----- END ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/waveforms/rectangle_waveform/active_waveform_painter.dart -----

----- BEGIN ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/waveforms/rectangle_waveform/inactive_waveform_painter.dart -----
import 'package:flutter/material.dart';
import 'package:flutter_audio_waveforms/src/core/waveform_painters_ab.dart';
import 'package:flutter_audio_waveforms/src/util/waveform_alignment.dart';
import 'package:flutter_audio_waveforms/src/waveforms/rectangle_waveform/rectangle_waveform.dart';

///InActiveWaveformPainter for the [RectangleWaveform].
class RectangleInActiveWaveformPainter extends InActiveWaveformPainter {
  // ignore: public_member_api_docs
  RectangleInActiveWaveformPainter({
    Color color = Colors.white,
    Gradient? gradient,
    required List<double> samples,
    required WaveformAlignment waveformAlignment,
    required double sampleWidth,
    required Color borderColor,
    required double borderWidth,
  }) : super(
          samples: samples,
          color: color,
          gradient: gradient,
          waveformAlignment: waveformAlignment,
          sampleWidth: sampleWidth,
          borderColor: borderColor,
          borderWidth: borderWidth,
          style: PaintingStyle.fill,
        );

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..style = style
      ..color = color
      ..shader = gradient?.createShader(
        Rect.fromLTWH(0, 0, size.width, size.height),
      );
    final borderPaint = Paint()
      ..style = PaintingStyle.stroke
      ..color = borderColor
      ..strokeWidth = borderWidth;
    //Gets the [alignPosition] depending on [waveformAlignment]
    final alignPosition = waveformAlignment.getAlignPosition(size.height);

    for (var i = 0; i < samples.length; i++) {
      final x = sampleWidth * i;
      final y = samples[i];
      //Draws the filled rectangles of the waveform.
      canvas
        ..drawRect(
          Rect.fromLTWH(x, alignPosition, sampleWidth, y),
          paint,
        )
        //Draws the border for the rectangles of the waveform.
        ..drawRect(
          Rect.fromLTWH(x, alignPosition, sampleWidth, y),
          borderPaint,
        );
    }
  }
}

----- END ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/waveforms/rectangle_waveform/inactive_waveform_painter.dart -----

----- BEGIN ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/waveforms/rectangle_waveform/rectangle_waveform.dart -----
import 'package:flutter/material.dart';
import 'package:flutter_audio_waveforms/flutter_audio_waveforms.dart';
import 'package:flutter_audio_waveforms/src/core/audio_waveform.dart';
import 'package:flutter_audio_waveforms/src/waveforms/rectangle_waveform/active_waveform_painter.dart';
import 'package:flutter_audio_waveforms/src/waveforms/rectangle_waveform/inactive_waveform_painter.dart';

/// [RectangleWaveform] paints a waveform where each sample is represented as
/// rectangle block. It's inspired by the @soundcloud audio track on web.
///
/// {@tool snippet}
/// Example :
/// ```dart
/// RectangleWaveform(
///   maxDuration: maxDuration,
///   elapsedDuration: elapsedDuration,
///   samples: samples,
///   height: 300,
///   width: MediaQuery.of(context).size.width,
/// )
///```
/// {@end-tool}
class RectangleWaveform extends AudioWaveform {
  // ignore: public_member_api_docs
  RectangleWaveform({
    Key? key,
    required List<double> samples,
    required double height,
    required double width,
    required Duration maxDuration,
    required Duration elapsedDuration,
    this.activeColor = Colors.red,
    this.inactiveColor = Colors.blue,
    this.activeGradient,
    this.inactiveGradient,
    this.borderWidth = 1.0,
    this.activeBorderColor = Colors.white,
    this.inactiveBorderColor = Colors.white,
    bool showActiveWaveform = true,
    bool absolute = false,
    bool invert = false,
  })  : assert(
          borderWidth >= 0 && borderWidth <= 1.0,
          "BorderWidth must be between 0 and 1",
        ),
        super(
          key: key,
          samples: samples,
          height: height,
          width: width,
          maxDuration: maxDuration,
          elapsedDuration: elapsedDuration,
          showActiveWaveform: showActiveWaveform,
          absolute: absolute,
          invert: invert,
        );

  /// The color of the active waveform.
  final Color activeColor;

  /// The color of the inactive waveform.
  final Color inactiveColor;

  /// The gradient of the active waveform.
  final Gradient? activeGradient;

  /// The gradient of the inactive waveform.
  final Gradient? inactiveGradient;

  /// The width of the border of the waveform.
  final double borderWidth;

  /// The color of the active waveform border.
  final Color activeBorderColor;

  /// The color of the inactive waveform border.
  final Color inactiveBorderColor;

  @override
  AudioWaveformState<RectangleWaveform> createState() =>
      _RectangleWaveformState();
}

class _RectangleWaveformState extends AudioWaveformState<RectangleWaveform> {
  @override
  Widget build(BuildContext context) {
    if (widget.samples.isEmpty) {
      return const SizedBox.shrink();
    }
    final processedSamples = this.processedSamples;
    final activeSamples = this.activeSamples;
    final showActiveWaveform = this.showActiveWaveform;
    final waveformAlignment = this.waveformAlignment;
    final sampleWidth = this.sampleWidth;

    return Stack(
      children: [
        RepaintBoundary(
          child: CustomPaint(
            size: Size(widget.width, widget.height),
            isComplex: true,
            painter: RectangleInActiveWaveformPainter(
              samples: processedSamples,
              color: widget.inactiveColor,
              gradient: widget.inactiveGradient,
              waveformAlignment: waveformAlignment,
              borderColor: widget.inactiveBorderColor,
              borderWidth: widget.borderWidth,
              sampleWidth: sampleWidth,
            ),
          ),
        ),
        if (showActiveWaveform)
          RepaintBoundary(
            child: CustomPaint(
              size: Size(widget.width, widget.height),
              isComplex: true,
              painter: RectangleActiveWaveformPainter(
                color: widget.activeColor,
                activeSamples: activeSamples,
                gradient: widget.activeGradient,
                waveformAlignment: waveformAlignment,
                borderColor: widget.activeBorderColor,
                borderWidth: widget.borderWidth,
                sampleWidth: sampleWidth,
              ),
            ),
          ),
      ],
    );
  }
}

----- END ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/waveforms/rectangle_waveform/rectangle_waveform.dart -----

----- BEGIN ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/waveforms/squiggly_waveform/active_inactive_waveform_painter.dart -----
import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:flutter_audio_waveforms/src/util/waveform_alignment.dart';
import 'package:flutter_audio_waveforms/src/core/waveform_painters_ab.dart';
import 'package:flutter_audio_waveforms/src/waveforms/squiggly_waveform/squiggly_waveform.dart';

///Painter for the [SquigglyWaveform]
/// Handles Painting both InActive and Active Waveforms.
class SquigglyWaveformPainter extends ActiveInActiveWaveformPainter {
  // ignore: public_member_api_docs
  SquigglyWaveformPainter({
    required Color activeColor,
    required List<double> samples,
    required Color inactiveColor,
    required double activeRatio,
    required WaveformAlignment waveformAlignment,
    required double sampleWidth,
    required double strokeWidth,
    required this.absolute,
    required this.invert,
  }) : super(
          samples: samples,
          activeColor: activeColor,
          inactiveColor: inactiveColor,
          activeRatio: activeRatio,
          waveformAlignment: waveformAlignment,
          sampleWidth: sampleWidth,
          strokeWidth: strokeWidth,
        );

  ///Whether to draw the absolute waveform or not
  final bool absolute;

  ///Whether to invert the waveform or not
  final bool invert;

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..style = PaintingStyle.stroke
      ..strokeWidth = strokeWidth
      ..strokeCap = StrokeCap.round
      ..strokeJoin = StrokeJoin.round
      ..shader = LinearGradient(
        begin: const Alignment(-1.001, 0),
        end: const Alignment(1.001, 0),
        colors: [activeColor, inactiveColor],
        stops: [activeRatio, 0],
      ).createShader(
        Rect.fromLTWH(0, 0, size.width, size.height),
      );

    final waveformPath = Path();
    if (!absolute) {
      paintDefaultWaveform(waveformPath, sampleWidth, invert);
    } else if (absolute && !invert) {
      downwardFacingAbsoluteWaveform(waveformPath, sampleWidth);
    } else {
      upwardFacingAbsoluteWaveform(waveformPath, sampleWidth);
    }

    final alignPosition = waveformAlignment.getAlignPosition(size.height);

    final shiftedPath = waveformPath.shift(Offset(0, alignPosition));

    canvas.drawPath(shiftedPath, paint);
  }

  /// Draws the default waveform
  // ignore: avoid_positional_boolean_parameters
  void paintDefaultWaveform(Path waveformPath, double pointWidth, bool invert) {
    for (var i = 0; i < samples.length; i++) {
      final value = samples[i];
      final upOrDown = invert ? i.isOdd : i.isEven;
      final x = pointWidth * i;
      final x2 = pointWidth * (i + 1);
      final y2 = i != samples.length - 1
          ? upOrDown
              ? -value
              : value
          : 0.0;
      final diameter = x2 - x;
      final radius = diameter / 2;
      waveformPath
        ..lineTo(x, y2)
        ..lineTo(x, upOrDown ? y2 - diameter : y2 + diameter)
        ..addArc(
          Rect.fromCircle(
            center:
                Offset(x2 - radius, upOrDown ? y2 - diameter : y2 + diameter),
            radius: radius,
          ),
          -math.pi,
          upOrDown ? math.pi : -math.pi,
        )
        ..lineTo(x2, y2);
    }
  }

  /// Draws the downward facing absolute waveform
  void upwardFacingAbsoluteWaveform(Path waveformPath, double pointWidth) {
    for (var i = 0; i < samples.length; i++) {
      final value = samples[i];
      final x = pointWidth * i;
      final x2 = pointWidth * (i + 1);
      final y2 = value;
      final diameter = x2 - x;
      final radius = diameter / 2;
      waveformPath
        ..lineTo(x, y2)
        ..lineTo(x, y2 + diameter)
        ..addArc(
          Rect.fromCircle(
            center: Offset(x2 - radius, y2 + diameter),
            radius: radius,
          ),
          -math.pi,
          -math.pi,
        )
        ..lineTo(x2, 0);
    }
    waveformPath.lineTo(0, 0);
  }

  /// Draws the upward facing absolute waveform
  void downwardFacingAbsoluteWaveform(Path waveformPath, double pointWidth) {
    for (var i = 0; i < samples.length; i++) {
      final value = samples[i];
      final x = pointWidth * i;
      final x2 = pointWidth * (i + 1);
      final y2 = -value;
      final diameter = x2 - x;
      final radius = diameter / 2;
      waveformPath
        ..lineTo(x, y2)
        ..lineTo(x, y2 - diameter)
        ..addArc(
          Rect.fromCircle(
            center: Offset(x2 - radius, y2 - diameter),
            radius: radius,
          ),
          math.pi,
          math.pi,
        )
        ..lineTo(x2, 0);
    }

    waveformPath.lineTo(0, 0);
  }
}

----- END ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/waveforms/squiggly_waveform/active_inactive_waveform_painter.dart -----

----- BEGIN ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/waveforms/squiggly_waveform/squiggly_waveform.dart -----
import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:flutter_audio_waveforms/src/core/audio_waveform.dart';
import 'package:flutter_audio_waveforms/src/core/waveform_painters_ab.dart';
import 'package:flutter_audio_waveforms/src/util/waveform_alignment.dart';
import 'package:flutter_audio_waveforms/src/waveforms/squiggly_waveform/active_inactive_waveform_painter.dart';

/// [SquigglyWaveform] paints a squiggly waveform.
/// The painter for this waveform is of the type [ActiveInActiveWaveformPainter]
///
/// {@tool snippet}
/// Example :
/// ```dart
/// SquigglyWaveform(
///   maxDuration: maxDuration,
///   elapsedDuration: elapsedDuration,
///   samples: samples,
///   height: 300,
///   width: MediaQuery.of(context).size.width,
/// )
///```
/// {@end-tool}
class SquigglyWaveform extends AudioWaveform {
  // ignore: public_member_api_docs
  SquigglyWaveform({
    Key? key,
    required List<double> samples,
    required double height,
    required double width,
    required Duration maxDuration,
    required Duration elapsedDuration,
    this.activeColor = Colors.red,
    this.inactiveColor = Colors.blue,
    this.strokeWidth = 1.0,
    bool showActiveWaveform = true,
    bool absolute = false,
    bool invert = false,
  })  : assert(strokeWidth >= 0, "strokeWidth can't be negative."),
        super(
          key: key,
          samples: samples,
          height: height,
          width: width,
          maxDuration: maxDuration,
          elapsedDuration: elapsedDuration,
          absolute: absolute,
          invert: invert,
          showActiveWaveform: showActiveWaveform,
        );

  /// The color of the active portion of the waveform.
  final Color activeColor;

  /// The color of the inactive portion of the waveform.
  final Color inactiveColor;

  /// The stroke width of the waveform.
  final double strokeWidth;

  @override
  AudioWaveformState<SquigglyWaveform> createState() =>
      _SquigglyWaveformState();
}

class _SquigglyWaveformState extends AudioWaveformState<SquigglyWaveform> {
  @override
  void processSamples() {
    final rawSamples = widget.samples;
    // ignore: omit_local_variable_types
    List<double> processedSamples =
        rawSamples.map((e) => e.abs() * widget.height).toList();

    final maxNum =
        processedSamples.reduce((a, b) => math.max(a.abs(), b.abs()));

    if (maxNum > 0) {
      final multiplier = math.pow(maxNum, -1).toDouble();
      final finalHeight = absolute ? widget.height : widget.height / 2;
      final finalMultiplier = multiplier * finalHeight;

      processedSamples = processedSamples
          .map(
            (e) => e * finalMultiplier,
          )
          .toList();
    }
    updateProcessedSamples(processedSamples);
  }

  @override
  Widget build(BuildContext context) {
    if (widget.samples.isEmpty) {
      return const SizedBox.shrink();
    }
    final processedSamples = this.processedSamples;
    final activeRatio = showActiveWaveform
        ? elapsedDuration.inMilliseconds / maxDuration.inMilliseconds
        : 0.0;
    final waveformAlignment = this.waveformAlignment;

    return RepaintBoundary(
      child: CustomPaint(
        size: Size(widget.width, widget.height),
        isComplex: true,
        painter: SquigglyWaveformPainter(
          samples: processedSamples,
          activeColor: widget.activeColor,
          inactiveColor: widget.inactiveColor,
          activeRatio: activeRatio,
          waveformAlignment: waveformAlignment,
          absolute: widget.absolute,
          invert: widget.invert,
          strokeWidth: widget.strokeWidth,
          sampleWidth: sampleWidth,
        ),
      ),
    );
  }
}

----- END ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/lib/src/waveforms/squiggly_waveform/squiggly_waveform.dart -----

----- BEGIN ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/pubspec.yaml -----
name: flutter_audio_waveforms
description: A UI library for easily adding audio waveforms to your apps, with several customization options.
version: 1.1.1+3
homepage: https://github.com/rutvik110/flutter_audio_waveforms

environment:
  sdk: ">=2.12.0 <3.0.0"
  flutter: ">=1.17.0"

dependencies:
  collection: ^1.15.0
  flutter:
    sdk: flutter
    

dev_dependencies:
  flutter_test:
    sdk: flutter
  analyzer: ^2.8.0
  dart_code_metrics: ^4.8.0
  very_good_analysis: ^2.4.0

# For information on the generic Dart part of this file, see the
# following page: https://dart.dev/tools/pub/pubspec

# The following section is specific to Flutter.
flutter:

  # To add assets to your package, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg
  #
  # For details regarding assets in packages, see
  # https://flutter.dev/assets-and-images/#from-packages
  #
  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/assets-and-images/#resolution-aware.

  # To add custom fonts to your package, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts in packages, see
  # https://flutter.dev/custom-fonts/#from-packages

----- END ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/pubspec.yaml -----

----- BEGIN ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/test/flutter_audio_waveforms_test.dart -----
import 'package:flutter_test/flutter_test.dart';

void main() {
  // test('adds one to input values', () {
  //   final calculator = Calculator();
  //   expect(calculator.addOne(2), 3);
  //   expect(calculator.addOne(-7), -6);
  //   expect(calculator.addOne(0), 1);
  // });
}

----- END ./native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/test/flutter_audio_waveforms_test.dart -----

----- BEGIN ./native_implementation/pluggins/native_add/android/build.gradle -----
// The Android Gradle Plugin builds the native code with the Android NDK.

group 'com.example.native_add'
version '1.0'

buildscript {
    repositories {
        google()
        mavenCentral()
    }

    dependencies {
        // The Android Gradle Plugin knows how to build native code with the NDK.
        classpath 'com.android.tools.build:gradle:7.3.0'
    }
}

rootProject.allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

apply plugin: 'com.android.library'

android {
    // Bumping the plugin compileSdkVersion requires all clients of this plugin
    // to bump the version in their app.
    compileSdkVersion 31

    // Bumping the plugin ndkVersion requires all clients of this plugin to bump
    // the version in their app and to download a newer version of the NDK.
    ndkVersion "23.1.7779620"

//     externalNativeBuild {
//    cmake {
//        // cppFlags are configured according to your selection
//        // of "Customize C++ Support", in this codelab's
//        //    "Create a Sample App with the C++ Template",
//        //    step 6
//        cppFlags "-std=c++17"
//    }

//     }

    // Invoke the shared CMake build with the Android Gradle Plugin.
    externalNativeBuild {
        cmake {
            path "../src/CMakeLists.txt"
             version "3.10.2"

            // The default CMake version for the Android Gradle Plugin is 3.10.2.
            // https://developer.android.com/studio/projects/install-ndk#vanilla_cmake
            //
            // The Flutter tooling requires that developers have CMake 3.10 or later
            // installed. You should not increase this version, as doing so will cause
            // the plugin to fail to compile for some customers of the plugin.
            // version "3.10.2"
        }
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    defaultConfig {
        minSdkVersion 16
    }
}

----- END ./native_implementation/pluggins/native_add/android/build.gradle -----

----- BEGIN ./native_implementation/pluggins/native_add/android/settings.gradle -----
rootProject.name = 'native_add'

----- END ./native_implementation/pluggins/native_add/android/settings.gradle -----

----- BEGIN ./native_implementation/pluggins/native_add/example/android/app/build.gradle -----
def localProperties = new Properties()
def localPropertiesFile = rootProject.file('local.properties')
if (localPropertiesFile.exists()) {
    localPropertiesFile.withReader('UTF-8') { reader ->
        localProperties.load(reader)
    }
}

def flutterRoot = localProperties.getProperty('flutter.sdk')
if (flutterRoot == null) {
    throw new GradleException("Flutter SDK not found. Define location with flutter.sdk in the local.properties file.")
}

def flutterVersionCode = localProperties.getProperty('flutter.versionCode')
if (flutterVersionCode == null) {
    flutterVersionCode = '1'
}

def flutterVersionName = localProperties.getProperty('flutter.versionName')
if (flutterVersionName == null) {
    flutterVersionName = '1.0'
}

apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply from: "$flutterRoot/packages/flutter_tools/gradle/flutter.gradle"

android {
    namespace "com.example.native_add_example"
    compileSdkVersion flutter.compileSdkVersion
    ndkVersion flutter.ndkVersion

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    kotlinOptions {
        jvmTarget = '1.8'
    }

    sourceSets {
        main.java.srcDirs += 'src/main/kotlin'
    }

    defaultConfig {
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId "com.example.native_add_example"
        // You can update the following values to match your application needs.
        // For more information, see: https://docs.flutter.dev/deployment/android#reviewing-the-gradle-build-configuration.
        minSdkVersion flutter.minSdkVersion
        targetSdkVersion flutter.targetSdkVersion
        versionCode flutterVersionCode.toInteger()
        versionName flutterVersionName
    }

    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig signingConfigs.debug
        }
    }
}

flutter {
    source '../..'
}

dependencies {
    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"
}

----- END ./native_implementation/pluggins/native_add/example/android/app/build.gradle -----

----- BEGIN ./native_implementation/pluggins/native_add/example/android/build.gradle -----
buildscript {
    ext.kotlin_version = '1.7.10'
    repositories {
        google()
        mavenCentral()
    }

    dependencies {
        classpath 'com.android.tools.build:gradle:7.3.0'
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
    }
}

allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

rootProject.buildDir = '../build'
subprojects {
    project.buildDir = "${rootProject.buildDir}/${project.name}"
}
subprojects {
    project.evaluationDependsOn(':app')
}

tasks.register("clean", Delete) {
    delete rootProject.buildDir
}

----- END ./native_implementation/pluggins/native_add/example/android/build.gradle -----

----- BEGIN ./native_implementation/pluggins/native_add/example/android/settings.gradle -----
include ':app'

def localPropertiesFile = new File(rootProject.projectDir, "local.properties")
def properties = new Properties()

assert localPropertiesFile.exists()
localPropertiesFile.withReader("UTF-8") { reader -> properties.load(reader) }

def flutterSdkPath = properties.getProperty("flutter.sdk")
assert flutterSdkPath != null, "flutter.sdk not set in local.properties"
apply from: "$flutterSdkPath/packages/flutter_tools/gradle/app_plugin_loader.gradle"

----- END ./native_implementation/pluggins/native_add/example/android/settings.gradle -----

----- BEGIN ./native_implementation/pluggins/native_add/example/ios/Runner/Runner-Bridging-Header.h -----
#import "GeneratedPluginRegistrant.h"

----- END ./native_implementation/pluggins/native_add/example/ios/Runner/Runner-Bridging-Header.h -----

----- BEGIN ./native_implementation/pluggins/native_add/example/lib/main.dart -----
import 'package:flutter/material.dart';
import 'dart:async';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  late int sumResult;
  late Future<int> sumAsyncResult;

  @override
  void initState() {
    super.initState();
    // sumResult = native_add.sumTwoInt(1, 2);
    // sumAsyncResult = native_add.sumAsync(3, 4);
  }

  @override
  Widget build(BuildContext context) {
    const textStyle = TextStyle(fontSize: 25);
    const spacerSmall = SizedBox(height: 10);
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Native Packages'),
        ),
        body: SingleChildScrollView(
          child: Container(
            padding: const EdgeInsets.all(10),
            child: Column(
              children: [
                const Text(
                  'This calls a native function through FFI that is shipped as source in the package. '
                  'The native code is built as part of the Flutter Runner build.',
                  style: textStyle,
                  textAlign: TextAlign.center,
                ),
                spacerSmall,
                Text(
                  'sum(1, 2) = $sumResult',
                  style: textStyle,
                  textAlign: TextAlign.center,
                ),
                spacerSmall,
                FutureBuilder<int>(
                  future: sumAsyncResult,
                  builder: (BuildContext context, AsyncSnapshot<int> value) {
                    final displayValue =
                        (value.hasData) ? value.data : 'loading';
                    return Text(
                      'await sumAsync(3, 4) = $displayValue',
                      style: textStyle,
                      textAlign: TextAlign.center,
                    );
                  },
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

----- END ./native_implementation/pluggins/native_add/example/lib/main.dart -----

----- BEGIN ./native_implementation/pluggins/native_add/example/linux/main.cc -----
#include "my_application.h"

int main(int argc, char** argv) {
  g_autoptr(MyApplication) app = my_application_new();
  return g_application_run(G_APPLICATION(app), argc, argv);
}

----- END ./native_implementation/pluggins/native_add/example/linux/main.cc -----

----- BEGIN ./native_implementation/pluggins/native_add/example/linux/my_application.cc -----
#include "my_application.h"

#include <flutter_linux/flutter_linux.h>
#ifdef GDK_WINDOWING_X11
#include <gdk/gdkx.h>
#endif

#include "flutter/generated_plugin_registrant.h"

struct _MyApplication {
  GtkApplication parent_instance;
  char** dart_entrypoint_arguments;
};

G_DEFINE_TYPE(MyApplication, my_application, GTK_TYPE_APPLICATION)

// Implements GApplication::activate.
static void my_application_activate(GApplication* application) {
  MyApplication* self = MY_APPLICATION(application);
  GtkWindow* window =
      GTK_WINDOW(gtk_application_window_new(GTK_APPLICATION(application)));

  // Use a header bar when running in GNOME as this is the common style used
  // by applications and is the setup most users will be using (e.g. Ubuntu
  // desktop).
  // If running on X and not using GNOME then just use a traditional title bar
  // in case the window manager does more exotic layout, e.g. tiling.
  // If running on Wayland assume the header bar will work (may need changing
  // if future cases occur).
  gboolean use_header_bar = TRUE;
#ifdef GDK_WINDOWING_X11
  GdkScreen* screen = gtk_window_get_screen(window);
  if (GDK_IS_X11_SCREEN(screen)) {
    const gchar* wm_name = gdk_x11_screen_get_window_manager_name(screen);
    if (g_strcmp0(wm_name, "GNOME Shell") != 0) {
      use_header_bar = FALSE;
    }
  }
#endif
  if (use_header_bar) {
    GtkHeaderBar* header_bar = GTK_HEADER_BAR(gtk_header_bar_new());
    gtk_widget_show(GTK_WIDGET(header_bar));
    gtk_header_bar_set_title(header_bar, "native_add_example");
    gtk_header_bar_set_show_close_button(header_bar, TRUE);
    gtk_window_set_titlebar(window, GTK_WIDGET(header_bar));
  } else {
    gtk_window_set_title(window, "native_add_example");
  }

  gtk_window_set_default_size(window, 1280, 720);
  gtk_widget_show(GTK_WIDGET(window));

  g_autoptr(FlDartProject) project = fl_dart_project_new();
  fl_dart_project_set_dart_entrypoint_arguments(project, self->dart_entrypoint_arguments);

  FlView* view = fl_view_new(project);
  gtk_widget_show(GTK_WIDGET(view));
  gtk_container_add(GTK_CONTAINER(window), GTK_WIDGET(view));

  fl_register_plugins(FL_PLUGIN_REGISTRY(view));

  gtk_widget_grab_focus(GTK_WIDGET(view));
}

// Implements GApplication::local_command_line.
static gboolean my_application_local_command_line(GApplication* application, gchar*** arguments, int* exit_status) {
  MyApplication* self = MY_APPLICATION(application);
  // Strip out the first argument as it is the binary name.
  self->dart_entrypoint_arguments = g_strdupv(*arguments + 1);

  g_autoptr(GError) error = nullptr;
  if (!g_application_register(application, nullptr, &error)) {
     g_warning("Failed to register: %s", error->message);
     *exit_status = 1;
     return TRUE;
  }

  g_application_activate(application);
  *exit_status = 0;

  return TRUE;
}

// Implements GObject::dispose.
static void my_application_dispose(GObject* object) {
  MyApplication* self = MY_APPLICATION(object);
  g_clear_pointer(&self->dart_entrypoint_arguments, g_strfreev);
  G_OBJECT_CLASS(my_application_parent_class)->dispose(object);
}

static void my_application_class_init(MyApplicationClass* klass) {
  G_APPLICATION_CLASS(klass)->activate = my_application_activate;
  G_APPLICATION_CLASS(klass)->local_command_line = my_application_local_command_line;
  G_OBJECT_CLASS(klass)->dispose = my_application_dispose;
}

static void my_application_init(MyApplication* self) {}

MyApplication* my_application_new() {
  return MY_APPLICATION(g_object_new(my_application_get_type(),
                                     "application-id", APPLICATION_ID,
                                     "flags", G_APPLICATION_NON_UNIQUE,
                                     nullptr));
}

----- END ./native_implementation/pluggins/native_add/example/linux/my_application.cc -----

----- BEGIN ./native_implementation/pluggins/native_add/example/linux/my_application.h -----
#ifndef FLUTTER_MY_APPLICATION_H_
#define FLUTTER_MY_APPLICATION_H_

#include <gtk/gtk.h>

G_DECLARE_FINAL_TYPE(MyApplication, my_application, MY, APPLICATION,
                     GtkApplication)

/**
 * my_application_new:
 *
 * Creates a new Flutter-based application.
 *
 * Returns: a new #MyApplication.
 */
MyApplication* my_application_new();

#endif  // FLUTTER_MY_APPLICATION_H_

----- END ./native_implementation/pluggins/native_add/example/linux/my_application.h -----

----- BEGIN ./native_implementation/pluggins/native_add/example/pubspec.yaml -----
name: native_add_example
description: Demonstrates how to use the native_add plugin.
# The following line prevents the package from being accidentally published to
# pub.dev using `flutter pub publish`. This is preferred for private packages.
publish_to: 'none' # Remove this line if you wish to publish to pub.dev

# The following defines the version and build number for your application.
# A version number is three numbers separated by dots, like 1.2.43
# followed by an optional build number separated by a +.
# Both the version and the builder number may be overridden in flutter
# build by specifying --build-name and --build-number, respectively.
# In Android, build-name is used as versionName while build-number used as versionCode.
# Read more about Android versioning at https://developer.android.com/studio/publish/versioning
# In iOS, build-name is used as CFBundleShortVersionString while build-number is used as CFBundleVersion.
# Read more about iOS versioning at
# https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html
# In Windows, build-name is used as the major, minor, and patch parts
# of the product and file versions while build-number is used as the build suffix.
version: 1.0.0+1

environment:
  sdk: '>=3.0.6 <4.0.0'

# Dependencies specify other packages that your package needs in order to work.
# To automatically upgrade your package dependencies to the latest versions
# consider running `flutter pub upgrade --major-versions`. Alternatively,
# dependencies can be manually updated by changing the version numbers below to
# the latest version available on pub.dev. To see which dependencies have newer
# versions available, run `flutter pub outdated`.
dependencies:
  flutter:
    sdk: flutter

  native_add:
    # When depending on this package from a real application you should use:
    #   native_add: ^x.y.z
    # See https://dart.dev/tools/pub/dependencies#version-constraints
    # The example app is bundled with the plugin so we use a path dependency on
    # the parent directory to use the current plugin's version.
    path: ../

  # The following adds the Cupertino Icons font to your application.
  # Use with the CupertinoIcons class for iOS style icons.
  cupertino_icons: ^1.0.2

dev_dependencies:
  flutter_test:
    sdk: flutter

  # The "flutter_lints" package below contains a set of recommended lints to
  # encourage good coding practices. The lint set provided by the package is
  # activated in the `analysis_options.yaml` file located at the root of your
  # package. See that file for information about deactivating specific lint
  # rules and activating additional ones.
  flutter_lints: ^2.0.0

# For information on the generic Dart part of this file, see the
# following page: https://dart.dev/tools/pub/pubspec

# The following section is specific to Flutter packages.
flutter:

  # The following line ensures that the Material Icons font is
  # included with your application, so that you can use the icons in
  # the material Icons class.
  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg

  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/assets-and-images/#resolution-aware

  # For details regarding adding assets from package dependencies, see
  # https://flutter.dev/assets-and-images/#from-packages

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts from package dependencies,
  # see https://flutter.dev/custom-fonts/#from-packages

----- END ./native_implementation/pluggins/native_add/example/pubspec.yaml -----

----- BEGIN ./native_implementation/pluggins/native_add/example/windows/runner/flutter_window.cpp -----
#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());

  flutter_controller_->engine()->SetNextFrameCallback([&]() {
    this->Show();
  });

  // Flutter can complete the first frame before the "show window" callback is
  // registered. The following call ensures a frame is pending to ensure the
  // window is shown. It is a no-op if the first frame hasn't completed yet.
  flutter_controller_->ForceRedraw();

  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}

----- END ./native_implementation/pluggins/native_add/example/windows/runner/flutter_window.cpp -----

----- BEGIN ./native_implementation/pluggins/native_add/example/windows/runner/flutter_window.h -----
#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_

----- END ./native_implementation/pluggins/native_add/example/windows/runner/flutter_window.h -----

----- BEGIN ./native_implementation/pluggins/native_add/example/windows/runner/main.cpp -----
#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t *command_line, _In_ int show_command) {
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments =
      GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.Create(L"native_add_example", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}

----- END ./native_implementation/pluggins/native_add/example/windows/runner/main.cpp -----

----- BEGIN ./native_implementation/pluggins/native_add/example/windows/runner/resource.h -----
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON                    101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

----- END ./native_implementation/pluggins/native_add/example/windows/runner/resource.h -----

----- BEGIN ./native_implementation/pluggins/native_add/example/windows/runner/utils.cpp -----
#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE *unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  int target_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      -1, nullptr, 0, nullptr, nullptr)
    -1; // remove the trailing null character
  int input_length = (int)wcslen(utf16_string);
  std::string utf8_string;
  if (target_length <= 0 || target_length > utf8_string.max_size()) {
    return utf8_string;
  }
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      input_length, utf8_string.data(), target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}

----- END ./native_implementation/pluggins/native_add/example/windows/runner/utils.cpp -----

----- BEGIN ./native_implementation/pluggins/native_add/example/windows/runner/utils.h -----
#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_

----- END ./native_implementation/pluggins/native_add/example/windows/runner/utils.h -----

----- BEGIN ./native_implementation/pluggins/native_add/example/windows/runner/win32_window.cpp -----
#include "win32_window.h"

#include <dwmapi.h>
#include <flutter_windows.h>

#include "resource.h"

namespace {

/// Window attribute that enables dark mode window decorations.
///
/// Redefined in case the developer's machine has a Windows SDK older than
/// version 10.0.22000.0.
/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
#define DWMWA_USE_IMMERSIVE_DARK_MODE 20
#endif

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

/// Registry key for app theme preference.
///
/// A value of 0 indicates apps should use dark mode. A non-zero or missing
/// value indicates apps should use light mode.
constexpr const wchar_t kGetPreferredBrightnessRegKey[] =
  L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
constexpr const wchar_t kGetPreferredBrightnessRegValue[] = L"AppsUseLightTheme";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
  }
  FreeLibrary(user32_module);
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registrar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() {
  ++g_active_window_count;
}

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::Create(const std::wstring& title,
                         const Point& origin,
                         const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  UpdateTheme(window);

  return OnCreate();
}

bool Win32Window::Show() {
  return ShowWindow(window_handle_, SW_SHOWNORMAL);
}

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window,
                                      UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd,
                            UINT const message,
                            WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;

    case WM_DWMCOLORIZATIONCOLORCHANGED:
      UpdateTheme(hwnd);
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() {
  return window_handle_;
}

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

void Win32Window::UpdateTheme(HWND const window) {
  DWORD light_mode;
  DWORD light_mode_size = sizeof(light_mode);
  LSTATUS result = RegGetValue(HKEY_CURRENT_USER, kGetPreferredBrightnessRegKey,
                               kGetPreferredBrightnessRegValue,
                               RRF_RT_REG_DWORD, nullptr, &light_mode,
                               &light_mode_size);

  if (result == ERROR_SUCCESS) {
    BOOL enable_dark_mode = light_mode == 0;
    DwmSetWindowAttribute(window, DWMWA_USE_IMMERSIVE_DARK_MODE,
                          &enable_dark_mode, sizeof(enable_dark_mode));
  }
}

----- END ./native_implementation/pluggins/native_add/example/windows/runner/win32_window.cpp -----

----- BEGIN ./native_implementation/pluggins/native_add/example/windows/runner/win32_window.h -----
#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates a win32 window with |title| that is positioned and sized using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size this function will scale the inputted width and height as
  // as appropriate for the default monitor. The window is invisible until
  // |Show| is called. Returns true if the window was created successfully.
  bool Create(const std::wstring& title, const Point& origin, const Size& size);

  // Show the current window. Returns true if the window was successfully shown.
  bool Show();

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window,
                                 UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window,
                                  UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  // Update the window frame's theme to match the system theme.
  static void UpdateTheme(HWND const window);

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_

----- END ./native_implementation/pluggins/native_add/example/windows/runner/win32_window.h -----

----- BEGIN ./native_implementation/pluggins/native_add/ios/Classes/native_add.cpp -----
#include "../../src/filter_util.cpp"
#include "../../src/filter_base.cpp"
#include "../../src/high_pass_filter.cpp"
#include "../../src/low_pass_filter.cpp"
#include "../../src/notch_filter.cpp"
#include "../../src/sample_buffer.cpp"
#include "../../src/envelope.cpp"
----- END ./native_implementation/pluggins/native_add/ios/Classes/native_add.cpp -----

----- BEGIN ./native_implementation/pluggins/native_add/lib/allocation.dart -----
// Copyright (c) 2019, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:ffi';
import 'dart:io';

// Note that kernel32.dll is the correct name in both 32-bit and 64-bit.
final DynamicLibrary stdlib = Platform.isWindows
    ? DynamicLibrary.open("kernel32.dll")
    : DynamicLibrary.process();

typedef PosixMallocNative = Pointer Function(IntPtr);
typedef PosixMalloc = Pointer Function(int);
final PosixMalloc posixMalloc =
    stdlib.lookupFunction<PosixMallocNative, PosixMalloc>("malloc");

typedef PosixFreeNative = Void Function(Pointer);
typedef PosixFree = void Function(Pointer);
final PosixFree posixFree =
    stdlib.lookupFunction<PosixFreeNative, PosixFree>("free");

typedef WinGetProcessHeapFn = Pointer Function();
final WinGetProcessHeapFn winGetProcessHeap = stdlib
    .lookupFunction<WinGetProcessHeapFn, WinGetProcessHeapFn>("GetProcessHeap");
final Pointer processHeap = winGetProcessHeap();

typedef WinHeapAllocNative = Pointer Function(Pointer, Uint32, IntPtr);
typedef WinHeapAlloc = Pointer Function(Pointer, int, int);
final WinHeapAlloc winHeapAlloc =
    stdlib.lookupFunction<WinHeapAllocNative, WinHeapAlloc>("HeapAlloc");

typedef WinHeapFreeNative = Int32 Function(
    Pointer heap, Uint32 flags, Pointer memory);
typedef WinHeapFree = int Function(Pointer heap, int flags, Pointer memory);
final WinHeapFree winHeapFree =
    stdlib.lookupFunction<WinHeapFreeNative, WinHeapFree>("HeapFree");

/// Allocates memory on the native heap.
///
/// For POSIX-based systems, this uses malloc. On Windows, it uses HeapAlloc
/// against the default public heap. Allocation of either element size or count
/// of 0 is undefined.
///
/// Throws an ArgumentError on failure to allocate.
Pointer<T> allocate<T extends NativeType>({int count = 1, int sizeOfType = 2}) {
  final int totalSize = count * sizeOfType;
  Pointer<T> result;
  if (Platform.isWindows) {
    result = winHeapAlloc(processHeap, /*flags=*/ 0, totalSize).cast();
  } else {
    result = posixMalloc(totalSize).cast();
  }
  if (result.address == 0) {
    throw ArgumentError("Could not allocate $totalSize bytes.");
  }
  return result;
}

/// Releases memory on the native heap.
///
/// For POSIX-based systems, this uses free. On Windows, it uses HeapFree
/// against the default public heap. It may only be used against pointers
/// allocated in a manner equivalent to [allocate].
///
/// Throws an ArgumentError on failure to free.
///
// TODO(dartbug.com/36855): Once we have a ffi.Bool type we can use it instead
// of testing the return integer to be non-zero.
void free(Pointer pointer) {
  if (Platform.isWindows) {
    if (winHeapFree(processHeap, /*flags=*/ 0, pointer) == 0) {
      throw ArgumentError("Could not free $pointer.");
    }
  } else {
    posixFree(pointer);
  }
}

----- END ./native_implementation/pluggins/native_add/lib/allocation.dart -----

----- BEGIN ./native_implementation/pluggins/native_add/lib/main.dart -----
import 'dart:ffi' as ffi;
import 'dart:typed_data';

/*
*
*
*
* Filtering
*
*
*/
typedef InitHighPassFilterProcess = double Function(
    int, double, double, double);
typedef ApplyHighPassFilter = double Function(int, ffi.Pointer<ffi.Int16>, int);

typedef InitLowPassFilterProcess = double Function(int, double, double, double);
typedef ApplyLowPassFilter = double Function(int, ffi.Pointer<ffi.Int16>, int);

typedef InitNotchPassFilterProcess = double Function(
    int, int, double, double, double);
typedef ApplyNotchPassFilter = double Function(
    int, int, ffi.Pointer<ffi.Int16>, int);

typedef SetNotchFilterProcess = double Function(int, int);

typedef AddDataToSampleBuffer = double Function(ffi.Pointer<ffi.Int16>, int);

typedef GetEnvelopDataFromSampleBuffer = double Function(
    int offset, int len, int skip, ffi.Pointer<ffi.Int16> src);

typedef GetAudioAvgTime = int Function();
typedef GetAudioMinTime = int Function();

typedef GetAudioMaxTime = int Function();

typedef GetClassReset = double Function();

/*
*
*
*
* Microphone
*
*
*/
typedef CapturedSetAudio = double Function();

typedef example_foo = ffi.Int32 Function(
    ffi.Int32 bar, ffi.Pointer<ffi.NativeFunction<MicCallback>>);
typedef ExampleFoo = int Function(
    int bar, ffi.Pointer<ffi.NativeFunction<MicCallback>>);

typedef MicCallback = ffi.Int32 Function(ffi.Pointer<ffi.Int16>, ffi.Int32);

//  check isDataAvailable
typedef CheckAudioData = double Function(ffi.Pointer<ffi.Int16>);

typedef SetAudioData = double Function(ffi.Pointer<ffi.Int16>);

/// FFI bindings with cpp files
class NativeAddBindings {
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeAddBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeAddBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

// Mic stream from the window native code
  double listenMic() {
    return _capturingAudio();
  }

  late final CapturedSetAudio _capturingAudio =
      _lookup<ffi.NativeFunction<ffi.Double Function()>>('newlistenMic')
          .asFunction();

  double isAudioCaptureData(ffi.Pointer<ffi.Int16> mPointer) {
    return _isAudioCapture(mPointer);

    // Perform your operations here
  }

// getAudioElapseData
  int getAvgAudio() {
    return getAudioAverageTime();
  }

  int getMinAudio() {
    return getAudioMinTime();
  }

  int getMaxAudio() {
    return getAudioMaxTime();
  }

  late final GetAudioAvgTime getAudioAverageTime =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getAvg').asFunction();

  late final GetAudioMaxTime getAudioMaxTime =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getMin').asFunction();

  late final GetAudioMinTime getAudioMinTime =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getMax').asFunction();

//

  double resetSampleBuffer() {
    return resetSampleBufferClass();
  }

  late final GetClassReset resetSampleBufferClass =
      _lookup<ffi.NativeFunction<ffi.Double Function()>>('resetClassInstance')
          .asFunction();

  late final CheckAudioData _isAudioCapture = _lookup<
          ffi.NativeFunction<
              ffi.Double Function(
                ffi.Pointer<ffi.Int16>,
              )>>('isCheckData')
      .asFunction();

  /// Call initHighPassFilter to initialize or set filter configuration
  double initHighPassFilter(
      int channelCount, double sampleRate, double cutOff, double q) {
    return _initHighPassFilterProcess(channelCount, sampleRate, cutOff, q);
  }

  late final InitHighPassFilterProcess _initHighPassFilterProcess = _lookup<
          ffi.NativeFunction<
              ffi.Double Function(ffi.Int, ffi.Double, ffi.Double,
                  ffi.Double)>>('initHighPassFilter')
      .asFunction();

  double applyHighPassFilter(
      int channelIndex, ffi.Pointer<ffi.Int16> data, int sampleCount) {
    return _applyHighPassFilter(channelIndex, data, sampleCount);
  }

  late final ApplyHighPassFilter _applyHighPassFilter = _lookup<
          ffi.NativeFunction<
              ffi.Double Function(ffi.Int16, ffi.Pointer<ffi.Int16>,
                  ffi.Uint32)>>('applyHighPassFilter')
      .asFunction();

  /*
  *
  * Low pass filter
  *
  * */

  /// Call applyLowPassFilter to apply filter on every packet
  ///
  /// Modifies and returns the values in the same buffer.

  /// Call initLowPassFilter to initialise or set filter configuration
  double initLowPassFilter(
      int channelCount, double sampleRate, double cutOff, double q) {
    return _initLowPassFilterProcess(channelCount, sampleRate, cutOff, q);
  }

  late final InitLowPassFilterProcess _initLowPassFilterProcess = _lookup<
          ffi.NativeFunction<
              ffi.Double Function(ffi.Int, ffi.Double, ffi.Double,
                  ffi.Double)>>('initLowPassFilter')
      .asFunction();

  double applyLowPassFilter(
      int channelIndex, ffi.Pointer<ffi.Int16> data, int sampleCount) {
    return _applyLowPassFilter(channelIndex, data, sampleCount);
  }

  late final ApplyLowPassFilter _applyLowPassFilter = _lookup<
          ffi.NativeFunction<
              ffi.Double Function(ffi.Int16, ffi.Pointer<ffi.Int16>,
                  ffi.Uint32)>>('applyLowPassFilter')
      .asFunction();

  /// notch pass filter to initialise or set notchFilter configuration

  double setNotchPassFilter(int isNotch50, int isNotch60) {
    return _setNotchPassFilter(isNotch50, isNotch60);
  }

  late final SetNotchFilterProcess _setNotchPassFilter =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Int, ffi.Int)>>(
              'setNotch')
          .asFunction();

  double initNotchPassFilter(int isHertz50, int channelCount, double sampleRate,
      double cutOff, double q) {
    _initNotchPassFilterProcess(isHertz50, channelCount, sampleRate, cutOff, q);
    return 1;
  }

  late final InitNotchPassFilterProcess _initNotchPassFilterProcess = _lookup<
          ffi.NativeFunction<
              ffi.Double Function(ffi.Int, ffi.Int, ffi.Double, ffi.Double,
                  ffi.Double)>>('initNotchPassFilter')
      .asFunction();

  double applyNotchPassFilter(int isNotch50, int channelIndex,
      ffi.Pointer<ffi.Int16> data, int sampleCount) {
    return _applyNotchPassFilter(isNotch50, channelIndex, data, sampleCount);
  }

  late final ApplyNotchPassFilter _applyNotchPassFilter = _lookup<
          ffi.NativeFunction<
              ffi.Double Function(ffi.Int16, ffi.Int16, ffi.Pointer<ffi.Int16>,
                  ffi.Uint32)>>('applyNotchPassFilter')
      .asFunction();

  double addDataToSampleBuffer(ffi.Pointer<ffi.Int16> src, int length) {
    return _addDataSampleBuffer(src, length);
  }

  late final AddDataToSampleBuffer _addDataSampleBuffer = _lookup<
          ffi.NativeFunction<
              ffi.Double Function(
                  ffi.Pointer<ffi.Int16>, ffi.Int)>>('addDataToSampleBuffer')
      .asFunction();

  double getEnvelopFromSampleBuffer(
      int offset, int length, int skip, ffi.Pointer<ffi.Int16> src) {
    final double resultArray = _getEnvelopSampleData(offset, length, skip, src);
    // Calculate the length of the Int16List based on the provided length
    // final int resultLength = length * 2; // Two Int16 elements per pair

    // Convert the Pointer<Int16> to Int16List
    // final Int16List resultList = resultArray.asTypedList(resultLength);
    // print("the result is $resultList");

    // Free the memory associated with the Pointer

    return resultArray;
  }

  late final GetEnvelopDataFromSampleBuffer _getEnvelopSampleData = _lookup<
          ffi.NativeFunction<
              ffi.Double Function(
                ffi.Int,
                ffi.Int,
                ffi.Int,
                ffi.Pointer<ffi.Int16>,
              )>>('getDataFromSampleBuffer')
      .asFunction();
}

----- END ./native_implementation/pluggins/native_add/lib/main.dart -----

----- BEGIN ./native_implementation/pluggins/native_add/lib/mic_listening_isolate.dart -----
import 'dart:async';
import 'dart:ffi' as ffi;
import 'dart:io';
import 'dart:isolate';
import 'dart:typed_data';

import 'package:native_add/allocation.dart';
import 'package:native_add/main.dart';

import 'model/sending_data.dart';

Isolate? _helperIsolateMic;
SendPort? _helperIsolateSendPortMic;

const String _libName = 'native_add';

//  main isolate for window mic

// Future<double> initHighValueFilter(int){}
/// The dynamic library in which the symbols for [NativeAddBindings] can be found.

final ffi.DynamicLibrary _dylib = () {
  if (Platform.isMacOS || Platform.isIOS) {
    return ffi.DynamicLibrary.open('$_libName.framework/$_libName');
  }
  if (Platform.isAndroid || Platform.isLinux) {
    return ffi.DynamicLibrary.open('lib$_libName.so');
  }
  if (Platform.isWindows) {
    return ffi.DynamicLibrary.open('$_libName.dll');
  }

  throw UnsupportedError('Unknown platform: ${Platform.operatingSystem}');
}();

final NativeAddBindings _bindingsMic = NativeAddBindings(_dylib);

// Unit - samples of int16
// i.e. bytes 4096
const int _bufferLength = 2048;

final ffi.Pointer<ffi.Int16> _micPointer = allocate<ffi.Int16>(
  count: _bufferLength,
  sizeOfType: ffi.sizeOf<ffi.Int16>(),
);

class _IsolateRequestForMic {
  final int id;
  final dynamic message;

  const _IsolateRequestForMic(this.id, this.message);
}

int _nextRequestId = 0;

/// Typically sent from one isolate to another.
class _IsolateResponseForMic {
  final int id;
  final dynamic result;

  const _IsolateResponseForMic(this.id, this.result);
}

final Map<int, Completer<MicAck>> _isolateResultsOfMic =
    <int, Completer<MicAck>>{};

Future<void> mainIsolateForMic(StreamController<Uint8List> micDataController,
    StreamController<PacketAddDetailModel> packetAddCalculateDetail) async {
  if (_helperIsolateMic == null) {
    _helperIsolateSendPortMic = await mainIsolateForMicHelperStart(
        micDataController, packetAddCalculateDetail);
  }
}

void resetClassInstance() {
  _bindingsMic.resetSampleBuffer();
}

Future<SendPort> mainIsolateForMicHelperStart(
    StreamController<Uint8List> micDataController,
    StreamController<PacketAddDetailModel> packetAddCalculateDetail) async {
  final Completer<SendPort> completerSendPortForMic = Completer<SendPort>();

  final ReceivePort response = ReceivePort();
  response.listen((dynamic message) {
    if (message is SendPort) {
      // The helper isolate sent us the port on which we can sent it requests.
      completerSendPortForMic.complete(message);
      return;
    }

    if (message is _IsolateResponseForMic) {
      if (message.result is MicAck) {
        switch (message.result) {
          case MicAck.micStarted:
            final Completer<MicAck> completer =
                _isolateResultsOfMic[message.id]!;

            completer.complete(message.result);

            // Remove the completer from the Map and free up memory
            _isolateResultsOfMic.remove(message.id);

            break;

          case MicAck.micStopped:
            break;
        }
      }

      return;
    }
    if (message is SendingDataToDart) {
      micDataController.add(message.asInt16List.buffer.asUint8List());
      PacketAddDetailModel packetAddDetailModel = PacketAddDetailModel(
          averageTime: message.averageTime,
          maxTime: message.maxTime,
          minTime: message.minTime);
      packetAddCalculateDetail.add(packetAddDetailModel);
    } else {
      throw UnsupportedError(
          'Unsupported message type: ${message.runtimeType}');
    }
  });

  _helperIsolateMic = await Isolate.spawn((SendPort sendPort) async {
    final ReceivePort helperReceivePortMic = ReceivePort();

    helperReceivePortMic.listen((dynamic data) async {
      // Todo pass the address:
      // final pointer = ffi.Pointer<ffi.Int16>.fromAddress(micData.offsetInBytes);

      // Future.delayed(const Duration(milliseconds: 1));
      if (data is _IsolateRequestForMic) {
        if (data.message is MicCommands) {
          switch (data.message) {
            case MicCommands.startMic:
              // Future.delayed(Duration(milliseconds: 100)).then((value) {
              initializeMic();
              _IsolateResponseForMic response;
              response = _IsolateResponseForMic(data.id, MicAck.micStarted);

              sendPort.send(response);

              continuouslyCheckMicData(sendPort);
              break;

            case MicCommands.stopMic:
              break;

            default:
              throw UnsupportedError(
                  'Unsupported message type: ${data.message}}');
          }
        }
      }
    });

    sendPort.send(helperReceivePortMic.sendPort);
  }, response.sendPort);

  return completerSendPortForMic.future;
}

/// Called only once
Future<MicAck> listenMicOfAudio() async {
  final int requestId = _nextRequestId++;
  final _IsolateRequestForMic request =
      _IsolateRequestForMic(requestId, MicCommands.startMic);
  final Completer<MicAck> completer = Completer<MicAck>();
  _isolateResultsOfMic[requestId] = completer;
  _helperIsolateSendPortMic?.send(request);
  return completer.future;
}

Future<void> continuouslyCheckMicData(SendPort isolateToMainMic) async {
  // int counter = 0;
  final Duration pollDuration = Platform.isWindows
      ? const Duration(milliseconds: 10)
      : const Duration(microseconds: 100);
  bool isFetchingData = false;
  Stopwatch stopwatch = Stopwatch();

  stopwatch.start();
  Timer.periodic(pollDuration, (timer) {
    // counter++;
    if (isFetchingData) return;
    isFetchingData = true;
    double isCheck = _bindingsMic.isAudioCaptureData(_micPointer);

    if (isCheck == 1.0) {
      // print(
      //     "stopwatch.elapsedMilliseconds: ${stopwatch.elapsedMilliseconds}, _bufferLength: ${_bufferLength / 2}");

      stopwatch.reset();
      Int16List int16list = _micPointer.asTypedList(_bufferLength);

      // counter++;
      // isolateToMainMic.send(int16list);
      // MicDataWithDetail micDataWithDetail = MicDataWithDetail(
      //     micData: int16list,
      //     upComingDataTiming: stopwatch.elapsedMilliseconds);
//  sending data to worker
      // Uint8List uint8list = Uint8List.fromList(int16list);
      int elapse = _bindingsMic.getAvgAudio();
      int minTime = _bindingsMic.getMinAudio();
      int maxTime = _bindingsMic.getMaxAudio();
      SendingDataToDart sendingDataToDart = SendingDataToDart(
          asInt16List: int16list,
          averageTime: elapse,
          maxTime: maxTime,
          minTime: minTime);
      isolateToMainMic.send(sendingDataToDart);
    }
    isFetchingData = false;
  });
}

class MicDataWithDetail {
  final Int16List micData;
  final int upComingDataTiming;
  MicDataWithDetail({required this.micData, required this.upComingDataTiming});
}

Future<void> initializeMic() async {
  double result1 = _bindingsMic.listenMic();
  print("From dart : mic listnening started in CPP - result $result1");
}

enum MicCommands {
  startMic,
  stopMic,
}

enum MicAck {
  micStarted,
  micStopped,
  micFailure,
}

----- END ./native_implementation/pluggins/native_add/lib/mic_listening_isolate.dart -----

----- BEGIN ./native_implementation/pluggins/native_add/lib/model/enveloping_data/enveloping_config.dart -----
import 'dart:ffi' as ffi;

import '../../allocation.dart';

class EnvelopingConfig {
  EnvelopingConfig()
      : _envelopBufferLength = _defaultPixel * 2,
        _pixelCount = _defaultPixel,
        envelopingBuffer = allocate<ffi.Int16>(
          count: _defaultLen * 2,
          sizeOfType: ffi.sizeOf<ffi.Int16>(),
        );

  static const int _defaultLen = 44100 * 120;
  static const int _defaultPixel = 2000;

  int _skipCount = _defaultLen ~/ _defaultPixel;

  int _pixelCount;

  /// Includes both min and max
  /// [_pixelCount] * 2
  int _envelopBufferLength;

  int get envelopBufferLength => _envelopBufferLength;

  int _samplesToFetch = _defaultLen;
  int get sampleLength => _samplesToFetch;

  ffi.Pointer<ffi.Int16> envelopingBuffer;

  /// Returns skip count
  /// [bufferSize] - sample rate * time(in seconds)
  /// [pixelCount] - pixels / graph points
  int setConfig({int? pixelCount, int? bufferSize}) {
    // print("Buffer size is ${bufferSize}");
    if (pixelCount != null) _setPixelCount(pixelCount);
    if (bufferSize != null) _setSampleBufferSize(bufferSize);
    return _setSkipPoints();
  }

  void _setPixelCount(int pxCount) {
    _pixelCount = pxCount;
    _envelopBufferLength = 2 * _pixelCount;

    // Free the existing buffer
    free(envelopingBuffer);

    // Reallocate the existing buffer
    envelopingBuffer = allocate<ffi.Int16>(
      count: _envelopBufferLength,
      sizeOfType: ffi.sizeOf<ffi.Int16>(),
    );
  }

  /// Length as per buffer size give in cpp file
  void _setSampleBufferSize(int buffSize) {
    _samplesToFetch = buffSize;
  }

  int get skipCount => _skipCount;

  int _setSkipPoints() {
    if (_pixelCount == 0) {
      // Handle the case where _pixelCount is zero to avoid division by zero.
      return 0; // or some default value based on your requirements
    }

    _skipCount = _samplesToFetch ~/ _pixelCount;
    return _skipCount;
  }
}

----- END ./native_implementation/pluggins/native_add/lib/model/enveloping_data/enveloping_config.dart -----

----- BEGIN ./native_implementation/pluggins/native_add/lib/model/filter_model/filter_base.dart -----
class FilterSettings {
  final int? sampleRate;
  final int? cutOff;

  const FilterSettings({
    this.sampleRate,
    this.cutOff,
  });

  factory FilterSettings.fromJson(Map<String, dynamic> json) => FilterSettings(
        sampleRate: json["SampleRate"],
        cutOff: json["cutOff"],
      );

  Map<String, dynamic> toJson() => {
        "SampleRate": sampleRate,
        "cutOff": cutOff,
      };
}

----- END ./native_implementation/pluggins/native_add/lib/model/filter_model/filter_base.dart -----

----- BEGIN ./native_implementation/pluggins/native_add/lib/model/filter_model/filter_model_export.dart -----
export 'filter_base.dart';
export 'filterbase_setting.dart';
export 'filter_select_enum.dart';

----- END ./native_implementation/pluggins/native_add/lib/model/filter_model/filter_model_export.dart -----

----- BEGIN ./native_implementation/pluggins/native_add/lib/model/filter_model/filter_select_enum.dart -----
enum FilterType {
  notchFilter,
  highPassFilter,
  lowPassFilter,
}

----- END ./native_implementation/pluggins/native_add/lib/model/filter_model/filter_select_enum.dart -----

----- BEGIN ./native_implementation/pluggins/native_add/lib/model/filter_model/filterbase_setting.dart -----
import 'filter_select_enum.dart';

class FilterSetup {
  const FilterSetup({
    this.isFilterOn = true,
    required this.filterType,
    required this.filterConfiguration,
    required this.channelCount,
  });

  final bool isFilterOn;
  final FilterType filterType;
  final int channelCount;
  final FilterConfiguration filterConfiguration;

  Map<String, dynamic> toJson() {
    return {
      'isFilterOn': isFilterOn,
      'filterType': filterType.toString(), // Assuming FilterType is an enum
      'channelCount': channelCount,
      'filterConfiguration': filterConfiguration.toJson(),
    };
  }

  FilterSetup copyWith({
    bool? isFilterOn,
    FilterType? filterType,
    int? channelCount,
    FilterConfiguration? filterConfiguration,
  }) {
    return FilterSetup(
      isFilterOn: isFilterOn ?? this.isFilterOn,
      filterType: filterType ?? this.filterType,
      channelCount: channelCount ?? this.channelCount,
      filterConfiguration: filterConfiguration ?? this.filterConfiguration,
    );
  }
}

class FilterConfiguration {
  const FilterConfiguration({
    required this.cutOffFrequency,
    required this.sampleRate,
  });

  final int cutOffFrequency;
  final int sampleRate;

  Map<String, dynamic> toJson() {
    return {
      'cutOffFrequency': cutOffFrequency,
      'sampleRate': sampleRate,
    };
  }

  
}

----- END ./native_implementation/pluggins/native_add/lib/model/filter_model/filterbase_setting.dart -----

----- BEGIN ./native_implementation/pluggins/native_add/lib/model/model.dart -----
export 'filter_model/filter_model_export.dart';
export 'sending_data.dart';

----- END ./native_implementation/pluggins/native_add/lib/model/model.dart -----

----- BEGIN ./native_implementation/pluggins/native_add/lib/model/sending_data.dart -----
import 'dart:typed_data';

class SendingDataToDart {
  final int averageTime;
  final int maxTime;
  final int minTime;
  final Int16List asInt16List;
  SendingDataToDart(
      {required this.asInt16List,
      required this.averageTime,
      required this.maxTime,
      required this.minTime});
}

class PacketAddDetailModel {
  final int averageTime;
  final int maxTime;
  final int minTime;

  PacketAddDetailModel(
      {required this.averageTime,
      required this.maxTime,
      required this.minTime});
}

----- END ./native_implementation/pluggins/native_add/lib/model/sending_data.dart -----

----- BEGIN ./native_implementation/pluggins/native_add/lib/native_add.dart -----
/*
For Mac:
Pods->native_add->Frameworks and libraries
AudioToolbox.framework
AudioUnit.framework
CoreAudio.framework
CoreFoundation.framework
*/

import 'dart:async';
import 'dart:io';
import 'dart:isolate';
import 'dart:typed_data';
import 'dart:ffi' as ffi;
import 'package:native_add/main.dart';
import 'package:native_add/model/enveloping_data/enveloping_config.dart';
import 'package:native_add/model/model.dart';

import 'allocation.dart';

const String _libName = 'native_add';

Isolate? _helperIsolate;
SendPort? _helperIsolateSendPort;

int maxValue = 0;
int minValue = 0;
int offset = 0;
double screenWidthInPhysicalPixels = 0;

// TODO: Remove, for testing only
// int channelIndex = 0;

const int _channelCount = 6;

// TODO: Increase the buffer size to accomodate larger packets coming from main isolate
/// Number of Int16 values to be held in buffer for each channel
const int _bufferLength = 2000;
// EnvelopingConfig? envelopingConfig;
int positionSinceBeginning = 0;

/// Buffer shared between Dart, JS and WASM
///
/// Memory not freed as it will used throughout the life of the program
final List<ffi.Pointer<ffi.Int16>> _mPointer = List.generate(
  _channelCount,
  (index) => allocate<ffi.Int16>(
    count: _bufferLength,
    sizeOfType: ffi.sizeOf<ffi.Int16>(),
  ),
);

// double getScreenWidthInPhysicalPixels() {
//   final physicalSize = ui.window.physicalSize;
//   double devicePixelRatio = ui.window.devicePixelRatio;

//   screenWidthInPhysicalPixels = physicalSize.width * devicePixelRatio;
//   print("the pixel count is $screenWidthInPhysicalPixels");
//   return screenWidthInPhysicalPixels;
// }

final List<EnvelopingConfig> _envelopingConfig = List.generate(
  _channelCount,
  (index) => EnvelopingConfig(),
);

int is50Hertz = 0;

Future<void> spawnHelperIsolate() async {
  if (_helperIsolate == null) {
    _helperIsolateSendPort = await _mHelperIsolateSendPort;
  }
}

/// [duration] in milliseconds

// Future<double> initHighValueFilter(int){}
/// The dynamic library in which the symbols for [NativeAddBindings] can be found.
final ffi.DynamicLibrary _dylib = () {
  if (Platform.isMacOS || Platform.isIOS) {
    return ffi.DynamicLibrary.open('$_libName.framework/$_libName');
  }
  if (Platform.isAndroid || Platform.isLinux) {
    return ffi.DynamicLibrary.open('lib$_libName.so');
  }
  if (Platform.isWindows) {
    return ffi.DynamicLibrary.open('$_libName.dll');
  }

  throw UnsupportedError('Unknown platform: ${Platform.operatingSystem}');
}();

/// The bindings to the native functions in [_dylib].
final NativeAddBindings _bindings = NativeAddBindings(_dylib);

/// Typically sent from one isolate to another.
class _IsolateRequest {
  final int id;
  final List<int> dataArray;
  final int dataLength;
  final int sampleLength;
  final int channelIndex;
  final int skipCount;
  final bool isSetPosition;

  const _IsolateRequest(this.id, this.skipCount, this.sampleLength,
      this.dataArray, this.dataLength, this.channelIndex, this.isSetPosition);
}

/// Typically sent from one isolate to another.
class _IsolateResponse {
  final int id;
  final Uint8List result;

  const _IsolateResponse(this.id, this.result);
}

/// Counter to identify [_IsolateRequest]s and [_IsolateResponse]s.
int _nextRequestId = 0;

/// Mapping from [_IsolateRequest] `id`s to the completers corresponding to the correct future of the pending request.
final Map<int, Completer<Uint8List>> _isolateResults =
    <int, Completer<Uint8List>>{};

/// The SendPort belonging to the helper isolate.
Future<SendPort> _mHelperIsolateSendPort = () async {
  // The helper isolate is going to send us back a SendPort, which we want to wait for.
  final Completer<SendPort> sendPortCompleter = Completer<SendPort>();

  // Receive port on the main isolate to receive messages from the helper.
  // We receive two types of messages:
  // 1. A port to send messages on.
  // 2. Responses to requests we sent.
  final ReceivePort receivePort = ReceivePort()
    ..listen((dynamic data) {
      if (data is SendPort) {
        // The helper isolate sent us the port on which we can sent it requests.
        sendPortCompleter.complete(data);
        return;
      }
      if (data is _IsolateResponse) {
        // print("the mpointer ${data.result.map((e) => e)}");
        // print("Response is ${data.result.length}");
        // The helper isolate sent us a response to a request we sent.
        // print("the length of  ${data.result.length}");
        if (!_isolateResults.containsKey(data.id)) {
          print("Response id mismatch");
          return;
        }
        // Extract the completer from the Map
        final Completer<Uint8List> completer = _isolateResults[data.id]!;

        // Complete the completer with its result
        // print("the result index ");
        completer.complete(data.result);

        // Remove the completer from the Map and free up memory
        _isolateResults.remove(data.id);
        return;
      }
      throw UnsupportedError('Unsupported message type: ${data.runtimeType}');
    });

  _helperIsolate = await Isolate.spawn((SendPort sendPort) async {
    bool isLowPassFilter = false;
    bool isHighPassFilter = false;
    bool isNotchPassFilter = false;

    final ReceivePort helperReceivePort = ReceivePort()
      ..listen((dynamic data) async {
        if (data is FilterSetup) {
          switch (data.filterType) {
            case FilterType.notchFilter:
              isNotchPassFilter = data.isFilterOn;
              initNotchPassFilter(data);
              break;
            case FilterType.highPassFilter:
              isHighPassFilter = data.isFilterOn;
              initHighPassFilter(data);
              break;
            case FilterType.lowPassFilter:
              isLowPassFilter = data.isFilterOn;
              initLowPassFilter(data);
              break;
          }
        } else if (data is _IsolateRequest) {
          _setValuesInSharedBuffer(
              data.dataArray, data.dataLength, data.channelIndex);
          if (isHighPassFilter) {
            _bindings.applyHighPassFilter(data.channelIndex,
                _mPointer[data.channelIndex], data.dataLength);
          }
          if (isLowPassFilter) {
            _bindings.applyLowPassFilter(data.channelIndex,
                _mPointer[data.channelIndex], data.dataLength);
          }
          if (isNotchPassFilter) {
            _bindings.applyNotchPassFilter(is50Hertz, data.channelIndex,
                _mPointer[data.channelIndex], data.dataLength);
          }
          _bindings.addDataToSampleBuffer(
              _mPointer[data.channelIndex], data.dataLength);

          if (data.isSetPosition == true) {
            print("the isSet Position is${data.isSetPosition}");

            positionSinceBeginning = 0;
          } else {
            positionSinceBeginning += data.dataLength;
          }

          // printTheValue(sampleLength, skipCount);
          // print(
          //     "the sampleLength ${_envelopingConfig[data.channelIndex].sampleLength}");
          // print(
          //     "the skip Count ${_envelopingConfig[data.channelIndex].skipCount}");
          _bindings.getEnvelopFromSampleBuffer(
              positionSinceBeginning - data.sampleLength,
              data.sampleLength,
              data.skipCount,
              _envelopingConfig[data.channelIndex].envelopingBuffer);

          final _IsolateResponse response = _IsolateResponse(
              data.id,
              _envelopingConfig[data.channelIndex]
                  .envelopingBuffer
                  .asTypedList(
                      _envelopingConfig[data.channelIndex].envelopBufferLength)
                  .buffer
                  .asUint8List());

          // print(
          //     "envelopBufferLength: ${_envelopingConfig[data.channelIndex].envelopBufferLength}");

          // final _IsolateResponse response = _IsolateResponse(
          //     data.id,
          //     _mPointer[data.channelIndex]
          //         .asTypedList(data.dataLength)
          //         .buffer
          //         .asUint8List());
          sendPort.send(response);
          return;
        }
      });

    // Send the port to the main isolate on which we can receive requests.
    sendPort.send(helperReceivePort.sendPort);
  }, receivePort.sendPort);

  // Wait until the helper isolate has sent us back the SendPort on which we
  // can start sending requests.
  return sendPortCompleter.future;
}();
int tempBufferSize = 0;
int tempSkipCount = 0;

// Below function is used to reset

Future<void> positionSinceBeginningSet() async {
  isResetPosition = true;
  await Future.delayed(const Duration(milliseconds: 100));
  isResetPosition = false;
}

/// Set values int the native buffer
void _setValuesInSharedBuffer(
    List<int> data, int valueCount, int channelIndex) {
  Int16List bytes = _mPointer[channelIndex].asTypedList(valueCount);
  bytes.setAll(0, data);
  return;
}

bool isResetPosition = false;

/// Called for every packet
Future<Uint8List> filterArrayElements({
  required List<int> array,
  required int length,
  required int channelIndex,
  required int upComingSampleLength,
  required int upComingSkipCount,
}) async {
  final int requestId = _nextRequestId++;

  final setPosition = isResetPosition;
  final _IsolateRequest request = _IsolateRequest(requestId, upComingSkipCount,
      upComingSampleLength, array, length, channelIndex, setPosition);
  final Completer<Uint8List> completer = Completer<Uint8List>();
  _isolateResults[requestId] = completer;

  _helperIsolateSendPort?.send(request);
  return completer.future;
}

bool initHighPassFilter(FilterSetup filterBaseSettingsModel) {
  _helperIsolateSendPort?.send(filterBaseSettingsModel);
  _bindings.initHighPassFilter(
    filterBaseSettingsModel.channelCount,
    double.parse(
        filterBaseSettingsModel.filterConfiguration.sampleRate.toString()),
    double.parse(
        filterBaseSettingsModel.filterConfiguration.cutOffFrequency.toString()),
    0.5,
  );
  return true;
}

bool initLowPassFilter(FilterSetup filterBaseSettingsModel) {
  _helperIsolateSendPort?.send(filterBaseSettingsModel);
  _bindings.initLowPassFilter(
    filterBaseSettingsModel.channelCount,
    double.parse(
        filterBaseSettingsModel.filterConfiguration.sampleRate.toString()),
    double.parse(
        filterBaseSettingsModel.filterConfiguration.cutOffFrequency.toString()),
    0.5,
  );
  return true;
}

bool initNotchPassFilter(FilterSetup filterBaseSettingsModel) {
  _helperIsolateSendPort?.send(filterBaseSettingsModel);
  is50Hertz =
      filterBaseSettingsModel.filterConfiguration.cutOffFrequency == 50 ? 1 : 0;

  _bindings.initNotchPassFilter(
    is50Hertz,
    filterBaseSettingsModel.channelCount,
    double.parse(
        filterBaseSettingsModel.filterConfiguration.sampleRate.toString()),
    double.parse(
        filterBaseSettingsModel.filterConfiguration.cutOffFrequency.toString()),
    0.5,
  );

  return true;
}

----- END ./native_implementation/pluggins/native_add/lib/native_add.dart -----

----- BEGIN ./native_implementation/pluggins/native_add/macos/Classes/native_add.cpp -----
#include "../../src/filter_util.cpp"
#include "../../src/filter_base.cpp"
#include "../../src/high_pass_filter.cpp"
#include "../../src/low_pass_filter.cpp"
#include "../../src/mac_capture_audio.cpp"
#include "../../src/notch_filter.cpp"
#include "../../src/sample_buffer.cpp"
#include "../../src/envelope.cpp"
#include "../../src/timing_debug.cpp"
----- END ./native_implementation/pluggins/native_add/macos/Classes/native_add.cpp -----

----- BEGIN ./native_implementation/pluggins/native_add/pubspec.yaml -----
name: native_add
description: A new Flutter FFI plugin project.
version: 0.0.1
homepage:

environment:
  sdk: '>=3.0.6 <4.0.0'
  flutter: ">=3.3.0"

dependencies:
  flutter:
    sdk: flutter
  plugin_platform_interface: ^2.0.2

dev_dependencies:
  ffi: ^2.0.1
  ffigen: ^6.1.2
  flutter_test:
    sdk: flutter
  flutter_lints: ^2.0.0

# For information on the generic Dart part of this file, see the
# following page: https://dart.dev/tools/pub/pubspec

# The following section is specific to Flutter packages.
flutter:
  # This section identifies this Flutter project as a plugin project.
  # The 'pluginClass' specifies the class (in Java, Kotlin, Swift, Objective-C, etc.)
  # which should be registered in the plugin registry. This is required for
  # using method channels.
  # The Android 'package' specifies package in which the registered class is.
  # This is required for using method channels on Android.
  # The 'ffiPlugin' specifies that native code should be built and bundled.
  # This is required for using `dart:ffi`.
  # All these are used by the tooling to maintain consistency when
  # adding or updating assets for this project.
  #
  # Please refer to README.md for a detailed explanation.
  plugin:
    platforms:
      android:
        ffiPlugin: true
      ios:
        ffiPlugin: true
      linux:
        ffiPlugin: true
      macos:
        ffiPlugin: true
      windows:
        ffiPlugin: true

  # To add assets to your plugin package, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg
  #
  # For details regarding assets in packages, see
  # https://flutter.dev/assets-and-images/#from-packages
  #
  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/assets-and-images/#resolution-aware

  # To add custom fonts to your plugin package, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts in packages, see
  # https://flutter.dev/custom-fonts/#from-packages

----- END ./native_implementation/pluggins/native_add/pubspec.yaml -----

----- BEGIN ./native_implementation/pluggins/native_add/src/MyAudioSInk.h -----
// #pragma once

// //
// #include <audioclient.h>
// #include <Mmdeviceapi.h>
// #include <fstream>
// #include <iostream>
// #include <cmath>

// using namespace std;

// class MyAudioSink
// {

// private:
//     size_t data_chunk_pos;
//     size_t file_length;
//     ofstream mainFile;

//     // sample format
//     WORD wFormatTag;
//     WORD nChannels;
//     DWORD nSamplesPerSec;
//     DWORD nAvgBytesPerSec;
//     WORD nBlockAlign;
//     WORD wBitsPerSample;
//     WORD cbSize;
//     int test;

// public:
//     bool bComplete;

//     HRESULT SetFormat(WAVEFORMATEX *pwfx);
//     HRESULT CopyData(BYTE *pData, UINT32 numFramesAvailable, BOOL *bDone);
// };

----- END ./native_implementation/pluggins/native_add/src/MyAudioSInk.h -----

----- BEGIN ./native_implementation/pluggins/native_add/src/MyAudioSink.cpp -----
// #pragma once

// #include "MyAudioSink.h"
// #include <string.h>

// namespace little_endian_io
// {
//     template <typename Word>
//     std::ostream &write_word(std::ostream &outs, Word value, unsigned size = sizeof(Word))
//     {

//         for (; size; --size, value >>= 8)
//             outs.put(static_cast<char>(value & 0xFF));
//         return outs;
//     }
// }
// using namespace little_endian_io;

// HRESULT MyAudioSink::SetFormat(WAVEFORMATEX *pwfx)
// {

//     // Update our format variables
//     wFormatTag = pwfx->WAVE_FORMAT_PCM;
//     nChannels = pwfx->nChannels;
//     nSamplesPerSec = pwfx->nSamplesPerSec;
//     nAvgBytesPerSec = pwfx->nAvgBytesPerSec;
//     nBlockAlign = pwfx->nBlockAlign;
//     wBitsPerSample = pwfx->wBitsPerSample;
//     cbSize = pwfx->cbSize;

//     return S_OK;
// }

// HRESULT MyAudioSink::CopyData(BYTE *pData, UINT32 numFramesAvailable, BOOL *bDone)
// {
//     // TODO

//     // forgot how to do this part, figure it out
//     for (int i = 0; i < numFramesAvailable; i++)
//     {
//         mainFile.write((const char *)pData + (i * nBlockAlign), nBlockAlign);
//     }

//     // test
//     test++;
//     if (test >= nBlockAlign * 120)
//         bComplete = true;

//     // check if our main function is done to finish capture
//     if (bComplete)
//         *bDone = true;

//     return S_OK;
// }

----- END ./native_implementation/pluggins/native_add/src/MyAudioSink.cpp -----

----- BEGIN ./native_implementation/pluggins/native_add/src/capture_audio.cpp -----
#include "capture_audio.h"
#include "timing_debug.h"

// // Constants for audio configuration
// const int SAMPLE_RATE = 44100;
// const int FRAMES_PER_BUFFER = 256;
// const int CIRCULAR_BUFFER_SIZE = 8192;
#define REFTIMES_PER_SEC 10000000
#define REFTIMES_PER_MILLISEC 10000

#define EXIT_ON_ERROR(hres) \
    if (FAILED(hres))       \
    {                       \
        goto Exit;          \
    }
#define SAFE_RELEASE(punk) \
    if ((punk) != NULL)    \
    {                      \
        (punk)->Release(); \
        (punk) = NULL;     \
    }

// MicCallback globalMicCallback = nullptr;
// FUNCTION_ATTRIBUTE int32_t onMicCallback(int32_t bar, MicCallback callback)
// {
//     std::cout << "Callback run" << std::endl;
//     return callback(nullptr, bar);
// }

TimingDebug timing_Debug;

const CLSID CLSID_MMDeviceEnumerator = __uuidof(MMDeviceEnumerator);
const IID IID_IMMDeviceEnumerator = __uuidof(IMMDeviceEnumerator);
const IID IID_IAudioClient = __uuidof(IAudioClient);
const IID IID_IAudioCaptureClient = __uuidof(IAudioCaptureClient);
HRESULT RecordAudioStream(MyAudioSink *pMySink)

{
    HRESULT hr;
    REFERENCE_TIME hnsRequestedDuration = REFTIMES_PER_SEC;
    REFERENCE_TIME hnsActualDuration;
    UINT32 bufferFrameCount;
    UINT32 numFramesAvailable;
    IMMDeviceEnumerator *pEnumerator = NULL;
    IMMDevice *pDevice = NULL;
    IAudioClient *pAudioClient = NULL;
    IAudioCaptureClient *pCaptureClient = NULL;
    WAVEFORMATEX *pwfx = new WAVEFORMATEX;
    UINT32 packetLength = 0;
    int totalTime = 0;

    BOOL bDone = FALSE;
    BYTE *pData;
    DWORD flags;

    UINT64 mCount = 0;
    long long oldTs = 0;

    hr = CoCreateInstance(
        CLSID_MMDeviceEnumerator, NULL,
        CLSCTX_ALL, IID_IMMDeviceEnumerator,
        (void **)&pEnumerator);
    EXIT_ON_ERROR(hr)

    hr = pEnumerator->GetDefaultAudioEndpoint(
        eCapture, eConsole, &pDevice);
    EXIT_ON_ERROR(hr)

    hr = pDevice->Activate(
        IID_IAudioClient, CLSCTX_ALL,
        NULL, (void **)&pAudioClient);
    EXIT_ON_ERROR(hr)

    hr = pAudioClient->GetMixFormat(&pwfx);
    hr = pwfx->nSamplesPerSec;
    std::cout << "sampling rate : " << hr << std::endl;

    hr = pwfx->cbSize;
    std::cout << "cb Size : " << hr << std::endl;

    hr = pwfx->nAvgBytesPerSec;
    std::cout << "Average byte per second : " << hr << std::endl;

    hr = pwfx->nChannels;
    std::cout << "no.of channel : " << hr << std::endl;

    hr = pwfx->wBitsPerSample;
    std::cout << "bits per Sample : " << hr << std::endl;

    hr = pwfx->nBlockAlign;
    std::cout << "n block Align : " << hr << std::endl;

    hr = pwfx->wFormatTag;
    std::cout << "format tag : " << hr << std::endl;

    switch (pwfx->wFormatTag)
    {
    case WAVE_FORMAT_PCM:
        std::cout << "WAVE_FORMAT_PCM" << std::endl;
        break;

    case WAVE_FORMAT_IEEE_FLOAT:
        std::cout << "WAVE_FORMAT_IEEE_FLOAT" << std::endl;
        break;

    case WAVE_FORMAT_EXTENSIBLE:
        std::cout << "WAVE_FORMAT_EXTENSIBLE" << std::endl;

        WAVEFORMATEXTENSIBLE *pWaveFormatExtensible = reinterpret_cast<WAVEFORMATEXTENSIBLE *>(pwfx);

        if (pWaveFormatExtensible->SubFormat == KSDATAFORMAT_SUBTYPE_PCM)
        {
            std::cout << "KSDATAFORMAT_SUBTYPE_PCM" << std::endl;
        }
        else if (pWaveFormatExtensible->SubFormat == KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)
        {
            std::cout << "KSDATAFORMAT_SUBTYPE_IEEE_FLOAT" << std::endl;
        }
        break;
    }
    EXIT_ON_ERROR(hr)

    hr = pAudioClient->Initialize(
        AUDCLNT_SHAREMODE_SHARED,
        0,
        hnsRequestedDuration,
        0,
        pwfx,
        NULL);
    EXIT_ON_ERROR(hr)

    // Get the size of the allocated buffer.
    hr = pAudioClient->GetBufferSize(&bufferFrameCount);
    EXIT_ON_ERROR(hr)

    hr = pAudioClient->GetService(
        IID_IAudioCaptureClient,
        (void **)&pCaptureClient);
    EXIT_ON_ERROR(hr)

    // Notify the audio sink which format to use.
    hr = pMySink->SetFormat(pwfx);
    EXIT_ON_ERROR(hr)
    hr = pwfx->nSamplesPerSec = 44100;
    std::cout << "error on sample set " << hr << std::endl;

    EXIT_ON_ERROR(hr)
    hr = pwfx->nSamplesPerSec;
    std::cout << "sampling rate  after set: " << hr << std::endl;

    // Calculate the actual duration of the allocated buffer.
    hnsActualDuration = (double)REFTIMES_PER_SEC *
                        bufferFrameCount / pwfx->nSamplesPerSec;
    std::cout << "time taken" << hnsActualDuration << std::endl;

    hr = pAudioClient->Start(); // Start recording.
    EXIT_ON_ERROR(hr)

    // Each loop fills about half of the shared buffer.
    while (bDone == FALSE)
    {
        auto start = std::chrono::high_resolution_clock::now();
        // auto start = std::chrono::duration_cast<std::chrono::microseconds>(end - start);

        // std::cout << "start :" < < < < std::endl;
        // Sleep for half the buffer duration.
        // Sleep(hnsActualDuration / REFTIMES_PER_MILLISEC / 2);

        hr = pCaptureClient->GetNextPacketSize(&packetLength);
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);

        // totalTime+ =

        // if()
        // std::cout << "Time taken by GetNextPacketSize: " << duration.count() << " microSecond" << std::endl;
        // std::cout << "packet length :" << packetLength << std::endl;
        EXIT_ON_ERROR(hr)

        while (packetLength != 0)
        {
            // Get the available data in the shared buffer.
            hr = pCaptureClient->GetBuffer(
                &pData,
                &numFramesAvailable,
                &flags, NULL, NULL);
            EXIT_ON_ERROR(hr)

            if (flags & AUDCLNT_BUFFERFLAGS_SILENT)
            {
                pData = NULL; // Tell CopyData to write silence.
            }

            // Copy the available capture data to the audio sink.
            hr = pMySink->CopyData(
                pData, numFramesAvailable, &bDone);

            /*
            For timing the loop
            */
            // long long _ts = getTime();
            // std::cout << "Current timestamp in microseconds: " << _ts - oldTs << std::endl;
            // oldTs = _ts;

            EXIT_ON_ERROR(hr)

            hr = pCaptureClient->ReleaseBuffer(numFramesAvailable);
            EXIT_ON_ERROR(hr)

            hr = pCaptureClient->GetNextPacketSize(&packetLength);
            EXIT_ON_ERROR(hr)
        }
    }

    hr = pAudioClient->Stop(); // Stop recording.
    EXIT_ON_ERROR(hr)

Exit:
    CoTaskMemFree(pwfx);
    SAFE_RELEASE(pEnumerator)
    SAFE_RELEASE(pDevice)
    SAFE_RELEASE(pAudioClient)
    SAFE_RELEASE(pCaptureClient)

    return hr;
}

void SetSampleRate(WAVEFORMATEX *pwfx, DWORD newSampleRate)
{
    if (pwfx)
    {
        pwfx->nSamplesPerSec = newSampleRate;
    }
}
// HRESULT RecordAudioStream(MyAudioSink *pMySink);

HRESULT RecordAudioStream(MyAudioSink *pMySink);

#ifdef __cplusplus
extern "C"
{
#endif
    MyAudioSink pMySink;

    void RecordInThread()
    {
        HRESULT hr;
        hr = RecordAudioStream(&pMySink);
        std::cout << "done" << std::endl;
    }

    FUNCTION_ATTRIBUTE double newlistenMic()
    {
        std::thread myThread(RecordInThread);
        myThread.detach(); // Wait for the thread to finish
        return 101;
    }

    FUNCTION_ATTRIBUTE double isCheckData(int16_t *micOutputData)
    {

        double result = pMySink.DisplayData(micOutputData);
        // std::cout <<  "result in cpp : " << result << std::endl;
        if (result >= 0.0)
        {

            timing_Debug.noteTime();
            // auto current_time = std::chrono::steady_clock::now();
            // auto elapsed_time = std::chrono::duration_cast<std::chrono::milliseconds>(current_time - pMySink.start_time);
            // int seconds = static_cast<int>(elapsed_time.count());
            // Now you can use 'seconds' as an integer
            // std::cout << "result in seconds: " << seconds << std::endl;
            // timing.noteTime(seconds);
            // std::cout << "Elapsed Time: " << timing.getElapsedTime() << std::endl;
            // std::cout << "Max Time: " << timing.getMaxTime() << std::endl;
            // std::cout << "Min Time: " << timing.getMinTime() << std::endl;

            // auto elapsed_time = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - pMySink->start_time).count();
            // std::cout << "result in epoch : " << elapsed_time << std::endl;
            return 1.0;
        }
        return 0.0;
    }

    EXTERNC FUNCTION_ATTRIBUTE int getAvg()
    {

        return timing_Debug.getAvg();
    }
    EXTERNC FUNCTION_ATTRIBUTE int getMin()
    {

        return timing_Debug.getMinTime();
    }
    EXTERNC FUNCTION_ATTRIBUTE int getMax()
    {

        return timing_Debug.getMaxTime();
    }

#ifdef __cplusplus
}

#endif

----- END ./native_implementation/pluggins/native_add/src/capture_audio.cpp -----

----- BEGIN ./native_implementation/pluggins/native_add/src/capture_audio.h -----
#ifndef CAPTURE_AUDIO_C
#define CAPTURE_AUDIO_C

#include <iostream>
#include <vector>
#include <queue>
#include <audioclient.h>
#include <mmdeviceapi.h>
#include <fstream>
#include <iostream>
#include <cmath>
#include <thread>
#include <algorithm>
#include <cstdint>

#include <chrono>

#ifdef __cplusplus
#define EXTERNC extern "C"
#else
#define EXTERNC
#endif

#if defined(__GNUC__)
#define FUNCTION_ATTRIBUTE __attribute__((visibility("default"))) __attribute__((used))
#elif defined(_MSC_VER)
#define FUNCTION_ATTRIBUTE __declspec(dllexport)
#endif

class MyAudioSink
{
public:
    MyAudioSink()
    {
        sinkData = new int16_t[bufferLength]; // Allocate memory for 16384 16-bit integers
        writeIndex = 0;
        readIndex = 0;
        dataCount = 0;
    }
    std::chrono::steady_clock::time_point start_time;

    ~MyAudioSink()
    {
        delete[] sinkData;
    }

    HRESULT CopyData(BYTE *pData, UINT32 numFramesAvailable, BOOL *bDone)
    {

        start_time = std::chrono::steady_clock::now();

        isCopyingData = true;

        uint32_t numSamples = numFramesAvailable * 2;
        uint32_t numBytes = numSamples * 4;
        int16_t *outputData = new int16_t[numSamples];

        for (uint32_t i = 0; i < numBytes; i += 8)
        {
            float sample1 = ((float *)pData)[i / 4];
            float sample2 = ((float *)pData)[(i / 4) + 1];

            // intSample1 matches with right microphone
            int16_t intSample1 = (int16_t)(sample1 * 32767);

            // intSample2 matches with left microphone
            int16_t intSample2 = (int16_t)(sample2 * 32767);

            // To take average of channels
            // sinkData[writeIndex] = static_cast<INT16>((intSample1 + intSample2) / 2);

            // To take one channel at a time
            sinkData[writeIndex] = intSample2;
            writeIndex = (writeIndex + 1) % (bufferLength);
            dataCount++;
        }

        delete[] outputData;
        // for (UINT32 i = 0; i < numFramesAvailable * 4; i += 8)
        // {
        //     float floatValue;

        //     // Copy 4 bytes of pData to a float variable
        //     memcpy(&floatValue, &pData[i], sizeof(float));

        //     // Convert the float value to a 2-byte int16 value
        //     INT16 int16Value = static_cast<INT16>(floatValue * 32767); // Scaling the float value and casting to int16

        //     // Uncomment to print the microphone values
        //     // std::cout << int16Value << std::endl;

        //     // Increment and wrap the write index
        //     sinkData[writeIndex] = int16Value;
        //     writeIndex = (writeIndex + 1) % (bufferLength);
        //     dataCount++;
        // }
        isCopyingData = false;
        return S_OK;
    }

    HRESULT SetFormat(WAVEFORMATEX *pwfx)
    {
        // Update our format variables
        wFormatTag = pwfx->wFormatTag;
        nChannels = pwfx->nChannels;
        nSamplesPerSec = pwfx->nSamplesPerSec;
        nAvgBytesPerSec = pwfx->nAvgBytesPerSec;
        nBlockAlign = pwfx->nBlockAlign;
        wBitsPerSample = pwfx->wBitsPerSample;
        cbSize = pwfx->cbSize;

        return S_OK;
    }

    double DisplayData(int16_t *outData)
    {
        if (isCopyingData)
            return -5;
        // auto start_time = std::chrono::high_resolution_clock::now();

        // /*
        // For timing the Loop
        // */
        // // long long _ts = getTime();
        // // std::cout << "DisplayData timestamp in microseconds: " << _ts - lastTs << std::endl;
        // // lastTs = _ts;

        if (dataCount >= packetReadSize && outData)
        {
            if (readIndex + packetReadSize >= bufferLength)
            {
                // index 8
                // Packet read size 5
                int samplesTillEnd = (bufferLength - 1) - readIndex;
                int samplesAtBeginning = packetReadSize - samplesTillEnd;

                // Copy the data from readIndex + 1 to start of outData
                if (samplesTillEnd != 0)
                {
                    memcpy(outData, sinkData + readIndex + 1, samplesTillEnd * sizeof(int16_t));
                }

                // Copy the data from start of sinkData to the remaing outData
                if (samplesAtBeginning != 0)
                {
                    memcpy(outData + samplesTillEnd, sinkData, samplesAtBeginning * sizeof(int16_t));
                }

                readIndex = samplesAtBeginning - 1;
            }
            else
            {
                memcpy(outData, sinkData + readIndex + 1, packetReadSize * sizeof(int16_t));
                readIndex += packetReadSize;
            }
            dataCount -= packetReadSize;
            return 1.0;
        }
        else
        {
            if (outData)
            {
                // std::cout << "Not enough data available." << std::endl;
            }
            else
            {
                // std::cout << "Output data pointer is null." << std::endl;
            }
            return -4.0;
        }

        return -1.0;
    }

protected:
private:
    const UINT32 bufferLength = 384000 * 2;

    size_t data_chunk_pos;
    size_t file_length;
    // sample format
    WORD wFormatTag;
    WORD nChannels;
    DWORD nSamplesPerSec;
    DWORD nAvgBytesPerSec;
    WORD nBlockAlign;
    WORD wBitsPerSample;
    WORD cbSize;
    int test;
    int16_t *sinkData;
    UINT32 writeIndex;
    UINT32 readIndex;
    UINT32 dataCount; // To track how much data we have in the buffer

    UINT64 lastTs;

    // change in dart also
    int packetReadSize = 2048;
    bool isCopyingData = false;
};

#endif
----- END ./native_implementation/pluggins/native_add/src/capture_audio.h -----

----- BEGIN ./native_implementation/pluggins/native_add/src/envelope.cpp -----
#include "envelope.h"

SampleBuffer sampleBuffer;

EXTERNC FUNCTION_ATTRIBUTE double addDataToSampleBuffer(int16_t *src, int len)
{
    // int64_t offset, int64_t len  required parameter
    sampleBuffer.addData(src, len);
    return 1.0;
}

static int64_t snapTo(int64_t val, int64_t increments)
{
    if (increments > 1)
    {
        val /= increments;
        val *= increments;
    }
    return val;
}

EXTERNC FUNCTION_ATTRIBUTE double getDataFromSampleBuffer(int offset, int len, int skip, int16_t *src)
{
    // std::cout << "get data is calling" << std::endl;
    // int64_t offset, int64_t len, int skip   *required  parameter
    const int64_t pos2 = offset + len;

    const int64_t pos1 = snapTo(offset, skip);

    // std::cout << "pos1 " << pos1 << std::endl;
    // std::cout << "pos2 " << pos2 << std::endl;
    // std::cout << "skip" << skip << std::endl;

    int64_t newLengthOfData = pos2 - pos1;

    // int sampleSkip = len ~ / 4000;
    // std::cout << " skip sample is " << sampleSkip << std::endl;

    std::vector<std::pair<int16_t, int16_t>>
        dataAfterEnvelop = sampleBuffer.getDataEnvelope(pos1, newLengthOfData, skip);

    // std::cout << "Data after envelop " << std::endl;
    size_t dataSize = dataAfterEnvelop.size() * 2; // Two int16_t elements per pair

    // Allocate memory for the int16_t array
    // src = int16_t[dataSize];

    // Copy data from vector to array
    // std::cout << "dataAfterEnvelop size " << dataAfterEnvelop.size() << std::endl;

    for (size_t i = 0; i < dataAfterEnvelop.size(); ++i)
    {
        size_t startIndex = 2 * i;
        int minValue = src[2 * i] = dataAfterEnvelop[i].first;
        int maxValue = src[(2 * i) + 1] = dataAfterEnvelop[i].second;
        // std::cout << " minValue is " << minValue << std::endl;
        // std::cout << "MaxValue at index " << startIndex + 1 << ": " << maxValue << std::endl;
    }

    return 1.0;
}

// std::vector<std::pair<int, int>> generateRandomData(size_t dataSize)
// {
//     std::vector<std::pair<int, int>> result;

//     std::random_device rd;
//     std::mt19937 gen(rd());
//     std::uniform_int_distribution<int> dist(-1000, 1000);

//     for (size_t i = 0; i < dataSize; ++i)
//     {
//         int randomValue1 = dist(gen);
//         int randomValue2 = dist(gen);
//         result.push_back(std::make_pair(randomValue1, randomValue2));
//     }

//     return result;
// }

// EXTERNC FUNCTION_ATTRIBUTE double getDataFromSampleBuffer(int offset, int len, int skip, int16_t *src)
// {
//     // std::cout << "get data is calling" << std::endl;
//     // int64_t offset, int64_t len, int skip   *required  parameter
//     const int64_t pos2 = offset + len;

//     const int64_t pos1 = snapTo(offset, skip);

//     // std::cout << "pos1 " << pos1 << std::endl;
//     // std::cout << "pos2 " << pos2 << std::endl;
//     // std::cout << "skip" << skip << std::endl;

//     int64_t newLengthOfData = pos2 - pos1;

//     // int sampleSkip = len ~ / 4000;
//     // std::cout << " skip sample is " << sampleSkip << std::endl;

//     std::vector<std::pair<int16_t, int16_t>>
//         dataAfterEnvelop = sampleBuffer.getDataEnvelope(pos1, newLengthOfData, skip);

//     // std::cout << "Data after envelop " << std::endl;
//     // size_t dataSize = dataAfterEnvelop.size() * 2; // Two int16_t elements per pair

//     // Allocate memory for the int16_t array
//     // src = int16_t[dataSize];

//     // Copy data from vector to array
//     // std::cout << "dataAfterEnvelop size " << dataAfterEnvelop.size() << std::endl;

//     std::vector<std::pair<int, int>> dataAfterEnvelop = generateRandomData(2000);

//     for (size_t i = 0; i < dataAfterEnvelop.size(); ++i)
//     {
//         size_t startIndex = 2 * i;
//         int minValue = src[2 * i] = dataAfterEnvelop[i].first;
//         int maxValue = src[(2 * i) + 1] = dataAfterEnvelop[i].second;
//         std::cout << " minValue is " << minValue << std::endl;
//         std::cout << "MaxValue at index " << startIndex + 1 << ": " << maxValue << std::endl;
//     }

//     return 1.0;
// }

EXTERNC FUNCTION_ATTRIBUTE double resetClassInstance()
{
    // int64_t offset, int64_t len  required parameter
    sampleBuffer.reset();

    return 1.0;
}
----- END ./native_implementation/pluggins/native_add/src/envelope.cpp -----

----- BEGIN ./native_implementation/pluggins/native_add/src/envelope.h -----
#ifndef ENVELOPE
#define ENVELOPE

#ifdef __cplusplus
#define EXTERNC extern "C"
#else
#define EXTERNC
#endif

#include <iostream>
#include <vector>
#include <random>
#include "sample_buffer.h"

EXTERNC FUNCTION_ATTRIBUTE double addDataToSampleBuffer(int16_t *src, int len);

EXTERNC FUNCTION_ATTRIBUTE double getDataFromSampleBuffer(int offset, int len, int skip, int16_t *src);

#endif
----- END ./native_implementation/pluggins/native_add/src/envelope.h -----

----- BEGIN ./native_implementation/pluggins/native_add/src/filter_base.cpp -----
#include "filter_base.h"

double FilterBase::getSamplingRate()
{
    return samplingRate;
}

void FilterBase::initWithSamplingRate(double sr)
{
    samplingRate = sr;

    for (double &coefficient : coefficients)
    {
        coefficient = 0.0f;
    }

    gInputKeepBuffer[0] = 0.0f;
    gInputKeepBuffer[1] = 0.0f;
    gOutputKeepBuffer[0] = 0.0f;
    gOutputKeepBuffer[1] = 0.0f;

    one = 1.0f;
}

void FilterBase::setCoefficients()
{
    coefficients[0] = b0;
    coefficients[1] = b1;
    coefficients[2] = b2;
    coefficients[3] = a1;
    coefficients[4] = a2;
}

void FilterBase::filter(int16_t *data, int32_t numFrames, bool flush)
{
    auto *tempdoubleBuffer = (double *)std::malloc(numFrames * sizeof(double));
    for (int32_t i = numFrames - 1; i >= 0; i--)
    {
        tempdoubleBuffer[i] = (double)data[i];
    }
    filterContiguousData(tempdoubleBuffer, numFrames);
    if (flush)
    {
        for (int32_t i = numFrames - 1; i >= 0; i--)
        {
            data[i] = 0;
        }
    }
    else
    {
        for (int32_t i = numFrames - 1; i >= 0; i--)
        {
            data[i] = (int16_t)tempdoubleBuffer[i];
        }
    }
    free(tempdoubleBuffer);
}

void FilterBase::filterContiguousData(double *data, int32_t numFrames)
{
    // Provide buffer for processing
    auto *tInputBuffer = (double *)std::malloc((numFrames + 2) * sizeof(double));
    auto *tOutputBuffer = (double *)std::malloc((numFrames + 2) * sizeof(double));

    // Copy the data
    memcpy(tInputBuffer, gInputKeepBuffer, 2 * sizeof(double));
    memcpy(tOutputBuffer, gOutputKeepBuffer, 2 * sizeof(double));
    memcpy(&(tInputBuffer[2]), data, numFrames * sizeof(double));

    // Do the processing
    // vDSP_deq22(tInputBuffer, 1, coefficients, tOutputBuffer, 1, numFrames);
    // https://developer.apple.com/library/ios/documentation/Accelerate/Reference/vDSPRef/index.html#//apple_ref/c/func/vDSP_deq22
    int n;
    for (n = 2; n < numFrames + 2; n++)
    {
        tOutputBuffer[n] = tInputBuffer[n] * coefficients[0] + tInputBuffer[n - 1] * coefficients[1] +
                           tInputBuffer[n - 2] * coefficients[2] - tOutputBuffer[n - 1] * coefficients[3] -
                           tOutputBuffer[n - 2] * coefficients[4];
    }

    // Copy the data
    memcpy(data, tOutputBuffer, numFrames * sizeof(double));
    memcpy(gInputKeepBuffer, &(tInputBuffer[numFrames]), 2 * sizeof(double));
    memcpy(gOutputKeepBuffer, &(tOutputBuffer[numFrames]), 2 * sizeof(double));

    free(tInputBuffer);
    free(tOutputBuffer);
}

void FilterBase::intermediateVariables(double Fc, double Q)
{
    omega = 2 * M_PI * Fc / samplingRate;
    omegaS = sin(omega);
    omegaC = cos(omega);
    alpha = omegaS / (2 * Q);
}

----- END ./native_implementation/pluggins/native_add/src/filter_base.cpp -----

----- BEGIN ./native_implementation/pluggins/native_add/src/filter_base.h -----
//
// Created by Stanislav Mircic  <stanislav at backyardbrains.com>
//

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

#ifndef SPIKE_RECORDER_ANDROID_FILTERBASE
#define SPIKE_RECORDER_ANDROID_FILTERBASE

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <stdint.h>

#ifdef __cplusplus
#define EXTERNC extern "C"
#else
#define EXTERNC
#endif

class FilterBase
{
public:
    int val;
    FilterBase() = default;

    double getSamplingRate();

    void initWithSamplingRate(double sr);

    void setCoefficients();
    void filter(int16_t *data, int32_t numFrames, bool flush);

    void filterContiguousData(double *data, int32_t numFrames);
    void intermediateVariables(double Fc, double Q);

    double one;
    double samplingRate;
    double gInputKeepBuffer[2];
    double gOutputKeepBuffer[2];
    double omega, omegaS, omegaC, alpha;
    double coefficients[5];
    double a0, a1, a2, b0, b1, b2;

protected:
private:
};

#endif
----- END ./native_implementation/pluggins/native_add/src/filter_base.h -----

----- BEGIN ./native_implementation/pluggins/native_add/src/filter_util.cpp -----
#include "filter_util.h"
----- END ./native_implementation/pluggins/native_add/src/filter_util.cpp -----

----- BEGIN ./native_implementation/pluggins/native_add/src/filter_util.h -----
#ifndef FILTER_UTIL_H
#define FILTER_UTIL_H

#include "high_pass_filter.h"
#include "low_pass_filter.h"

#endif
----- END ./native_implementation/pluggins/native_add/src/filter_util.h -----

----- BEGIN ./native_implementation/pluggins/native_add/src/high_pass_filter.cpp -----
//
// Created by Stanislav Mircic  <stanislav at backyardbrains.com>
//

#include "high_pass_filter.h"

HighPassFilter highPassFilters[6];

void HighPassFilter::calculateCoefficients()
{
    if ((cornerFrequency != 0.0f) && (Q != 0.0f))
    {
        intermediateVariables(cornerFrequency, Q);

        a0 = 1 + alpha;
        b0 = ((1 + omegaC) / 2) / a0;
        b1 = (-1 * (1 + omegaC)) / a0;
        b2 = ((1 + omegaC) / 2) / a0;
        a1 = (-2 * omegaC) / a0;
        a2 = (1 - alpha) / a0;

        setCoefficients();
    }
}

void HighPassFilter::setCornerFrequency(double newCornerFrequency)
{
    cornerFrequency = newCornerFrequency;
    calculateCoefficients();
}

void HighPassFilter::setQ(double newQ)
{
    Q = newQ;
    calculateCoefficients();
}

EXTERNC FUNCTION_ATTRIBUTE double initHighPassFilter(int channelCount, double sampleRate, double highCutOff, double q)
{
    for (int32_t i = 0; i < channelCount; i++)
    {
        // HighPassFilter highPassFilter = highPassFilters[i];
        highPassFilters[i].initWithSamplingRate(sampleRate);
        if (highCutOff > sampleRate / 2.0f)
            highCutOff = sampleRate / 2.0f;
        highPassFilters[i].setCornerFrequency(highCutOff);
        highPassFilters[i].setQ(q);
    }
    return 1;
}

EXTERNC FUNCTION_ATTRIBUTE double applyHighPassFilter(int16_t channelIdx, int16_t *data, int32_t sampleCount)
{
    highPassFilters[channelIdx].filter(data, sampleCount, false);
    return 1;
}
// EXTERNC FUNCTION_ATTRIBUTE double listenMic();
// EXTERNC FUNCTION_ATTRIBUTE double listenMic()
// {
//     double q = 5.0;
//     double r = 5.0;
//     double w;
//     w = q + r;
//     return w;
// }

----- END ./native_implementation/pluggins/native_add/src/high_pass_filter.cpp -----

----- BEGIN ./native_implementation/pluggins/native_add/src/high_pass_filter.h -----
//
// Created by Stanislav Mircic  <stanislav at backyardbrains.com>
//
#ifndef SPIKE_RECORDER_ANDROID_HIGHPASSFILTER
#define SPIKE_RECORDER_ANDROID_HIGHPASSFILTER

#include "filter_base.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <stdint.h>

#ifdef __cplusplus
#define EXTERNC extern "C"
#else
#define EXTERNC
#endif

#if defined(__GNUC__)
#define FUNCTION_ATTRIBUTE __attribute__((visibility("default"))) __attribute__((used))
#elif defined(_MSC_VER)
#define FUNCTION_ATTRIBUTE __declspec(dllexport)
#endif

class HighPassFilter : public FilterBase
{
public:
    HighPassFilter() = default;
    void calculateCoefficients();
    void setCornerFrequency(double newCornerFrequency);
    void setQ(double newQ);
    double cornerFrequency;
    double Q;

protected:
private:
};

// EXTERNC FUNCTION_ATTRIBUTE double createHighPassFilter(short channelCount, double sampleRate, double highCutOff, double q);

EXTERNC FUNCTION_ATTRIBUTE double initHighPassFilter(int channelCount, double sampleRate, double highCutOff, double q);

EXTERNC FUNCTION_ATTRIBUTE double applyHighPassFilter(int16_t channelIdx, int16_t *data, int32_t sampleCount);

#endif
----- END ./native_implementation/pluggins/native_add/src/high_pass_filter.h -----

----- BEGIN ./native_implementation/pluggins/native_add/src/low_pass_filter.cpp -----
//
// Created by Stanislav Mircic  <stanislav at backyardbrains.com>
//

#include "low_pass_filter.h"

int logIdx = -1;
LowPassFilter lowPassFilters[6];

double LowPassFilter::myCreateLowPassFilter(int16_t channelCount, double sampleRate, double cutOff, double q)
{
    return 1;
}

void LowPassFilter::calculateCoefficients()
{
    if ((cornerFrequency != 0.0f) && (Q != 0.0f))
    {
        intermediateVariables(cornerFrequency, Q);

        a0 = 1 + alpha;
        b0 = ((1 - omegaC) / 2) / a0;
        b1 = ((1 - omegaC)) / a0;
        b2 = ((1 - omegaC) / 2) / a0;
        a1 = (-2 * omegaC) / a0;
        a2 = (1 - alpha) / a0;

        setCoefficients();
    }
}

void LowPassFilter::setCornerFrequency(double newCornerFrequency)
{
    cornerFrequency = newCornerFrequency;
    calculateCoefficients();
}

void LowPassFilter::setQ(double newQ)
{
    Q = newQ;
    calculateCoefficients();
}

EXTERNC FUNCTION_ATTRIBUTE double initLowPassFilter(int channelCount, double sampleRate, double cutOff, double q)
{
    for (int32_t i = 0; i < channelCount; i++)
    {
        // LowPassFilter lowPassFilter = lowPassFilters[i];
        lowPassFilters[i].initWithSamplingRate(sampleRate);
        if (cutOff > sampleRate / 2.0f)
            cutOff = sampleRate / 2.0f;
        lowPassFilters[i].setCornerFrequency(cutOff);
        lowPassFilters[i].setQ(q);
    }
    return lowPassFilters[0].omega;
}

EXTERNC FUNCTION_ATTRIBUTE double applyLowPassFilter(int16_t channelIdx, int16_t *data, int32_t sampleCount)
{
    if (lowPassFilters[channelIdx].omega != 0)
    {
        lowPassFilters[channelIdx].filter(data, sampleCount, false);
        return 1;
    }
    return -1;
}

----- END ./native_implementation/pluggins/native_add/src/low_pass_filter.cpp -----

----- BEGIN ./native_implementation/pluggins/native_add/src/low_pass_filter.h -----
//
// Created by Stanislav Mircic  <stanislav at backyardbrains.com>
//

#ifndef SPIKE_RECORDER_ANDROID_LOWPASSFILTER
#define SPIKE_RECORDER_ANDROID_LOWPASSFILTER

#include "filter_base.h"

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <stdint.h>

#ifdef __cplusplus
#define EXTERNC extern "C"
#else
#define EXTERNC
#endif

#if defined(__GNUC__)
#define FUNCTION_ATTRIBUTE __attribute__((visibility("default"))) __attribute__((used))
#elif defined(_MSC_VER)
#define FUNCTION_ATTRIBUTE __declspec(dllexport)
#endif

class LowPassFilter : public FilterBase
{
public:
    LowPassFilter() = default;
    double myCreateLowPassFilter(int16_t channelCount, double sampleRate, double cutOff, double q);
    void calculateCoefficients();
    void setCornerFrequency(double newCornerFrequency);
    void setQ(double newQ);
    double cornerFrequency = 0;
    double Q = 0;

protected:
private:
};



// EXTERNC FUNCTION_ATTRIBUTE double createLowPassFilter(int16_t channelCount, double sampleRate, double cutOff, double q);

EXTERNC FUNCTION_ATTRIBUTE double initLowPassFilter(int channelCount, double sampleRate, double cutOff, double q);

EXTERNC FUNCTION_ATTRIBUTE double applyLowPassFilter(int16_t channelIdx, int16_t *data, int32_t sampleCount);

#endif

----- END ./native_implementation/pluggins/native_add/src/low_pass_filter.h -----

----- BEGIN ./native_implementation/pluggins/native_add/src/mac_audio_sink.cpp -----
#ifndef MY_AUDIO_SINK
#define MY_AUDIO_SINK

class MacAudioSink
{
public:
    MacAudioSink()
    {
        sinkData = new int16_t[bufferLength]; // Allocate memory for 16384 16-bit integers
        writeIndex = 0;
        readIndex = 0;
        dataCount = 0;
    }

    ~MacAudioSink()
    {
        delete[] sinkData;
    }

    int CopyData(Float32 *pData, uint32_t numFramesAvailable, bool *bDone)
    {
        isCopyingData = true;
        // Cast pData to a float pointer for easier access to the samples
        // Float32 *pFloatData = (Float32 *)pData;

        for (uint32_t i = 0; i < numFramesAvailable; i++)
        {
            // Directly access the ith sample
            Float32 sample = pData[i];

            // Convert the float sample to a 16-bit integer
            int16_t intSample = static_cast<int16_t>(sample * 32767.0f);

            sinkData[writeIndex] = intSample;
            writeIndex = (writeIndex + 1) % (bufferLength);
            dataCount++;
        }
        isCopyingData = false;
        return 1; // Return a status code (1 for success in this case)
    }

    double DisplayData(int16_t *outData)
    {
        if(isCopyingData) return -5;
        if (dataCount >= packetReadSize && outData)
        {
            if (readIndex + packetReadSize >= bufferLength)
            {
                int samplesTillEnd = (bufferLength - 1) - readIndex;
                int samplesAtBeginning = packetReadSize - samplesTillEnd;

                // Copy the data from readIndex + 1 to start of outData
                if (samplesTillEnd != 0)
                {
                    memcpy(outData, sinkData + readIndex + 1, samplesTillEnd * sizeof(int16_t));
                }

                // Copy the data from start of sinkData to the remaining outData
                if (samplesAtBeginning != 0)
                {
                    memcpy(outData + samplesTillEnd, sinkData, samplesAtBeginning * sizeof(int16_t));
                }

                readIndex = samplesAtBeginning - 1;
            }
            else
            {
                memcpy(outData, sinkData + readIndex + 1, packetReadSize * sizeof(int16_t));
                readIndex += packetReadSize;
            }
            dataCount -= packetReadSize;
            return 1.0;
        }
        else
        {
            if (outData)
            {
                // std::cout << "Not enough data available." << std::endl;
            }
            else
            {
                // std::cout << "Output data pointer is null." << std::endl;
            }
            return -4.0;
        }

        return -1.0;
    }

protected:
private:
    const uint32_t bufferLength = 384000 * 2;

    size_t data_chunk_pos;
    size_t file_length;

    int16_t *sinkData;
    uint32_t writeIndex;
    uint32_t readIndex;
    uint32_t dataCount; // To track how much data we have in the buffer

    // change in dart also
    // unit - samples of int16
    // i.e. bytes 4096
    int packetReadSize = 2048;

    bool isCopyingData = false;
};

#endif
----- END ./native_implementation/pluggins/native_add/src/mac_audio_sink.cpp -----

----- BEGIN ./native_implementation/pluggins/native_add/src/mac_capture_audio.cpp -----

#ifdef __cplusplus
#define EXTERNC extern "C"
#else
#define EXTERNC
#endif

#if defined(__GNUC__)
#define FUNCTION_ATTRIBUTE __attribute__((visibility("default"))) __attribute__((used))
#elif defined(_MSC_VER)
#define FUNCTION_ATTRIBUTE __declspec(dllexport)
#endif

extern "C"
{
#include <CoreAudio/CoreAudio.h>
}
#include "timing_debug.h"
#include <cstdio>
#include <unistd.h> // for sleep function in C++
#include <string>

// Include your other C++ headers
#include "mac_audio_sink.cpp" // Replace with your actual header file

MacAudioSink macAudioSink;
TimingDebug timing_Debug;

// Define a callback function to handle input audio data
OSStatus audioInputCallback(
    AudioObjectID inDevice,
    const AudioTimeStamp *inNow,
    const AudioBufferList *inInputData,
    const AudioTimeStamp *inInputTime,
    AudioBufferList *outOutputData,
    const AudioTimeStamp *inOutputTime,
    void *inClientData)
{
    // if (inNow) {
    //     printf("AudioTimeStamp (inNow): mSampleTime: %f samples, mHostTime: %llu host ticks\n", inNow->mSampleTime, inNow->mHostTime);
    // }

    // if (inInputData) {
    //     printf("AudioBufferList (inInputData): Number of AudioBuffers: %u, Data Byte Size of first buffer: %u bytes\n", inInputData->mNumberBuffers, inInputData->mBuffers[0].mDataByteSize);
    // }

    // if (inInputTime) {
    //     printf("AudioTimeStamp (inInputTime): mSampleTime: %f samples, mHostTime: %llu host ticks\n", inInputTime->mSampleTime, inInputTime->mHostTime);
    // }

    // if (outOutputData) {
    //     printf("AudioBufferList (outOutputData): Number of AudioBuffers: %u\n", outOutputData->mNumberBuffers);
    // }

    // if (inOutputTime) {
    //     printf("AudioTimeStamp (inOutputTime): mSampleTime: %f samples, mHostTime: %llu host ticks\n", inOutputTime->mSampleTime, inOutputTime->mHostTime);
    // }

    // printf("Client Data Pointer: %p\n", inClientData);

    // For simplicity, we'll assume a single float channel and just print out the first sample
    // const Float32 *data = (const Float32 *)inInputData->mBuffers[0].mData;
    UInt32 dataByteSize = inInputData->mBuffers[0].mDataByteSize;

    // printf("Data Byte Size: %u bytes\n", dataByteSize);
    // printf("\n\n\n");

    // Calculate the number of samples in the buffer
    // Assuming that mDataByteSize is the size in bytes of the audio buffer
    // and that each sample is a Float32 (4 bytes)
    UInt32 numSamples = dataByteSize / sizeof(Float32);

    // for(UInt32 i = 0; i< numSamples;i++){
    //     printf("%d : %f\n", i, data[i]);
    // }

    // Create a new float* in heap
    Float32 *myArray = (Float32 *)malloc(sizeof(Float32) * numSamples);
    memcpy((void *)myArray, (void *)inInputData->mBuffers[0].mData, dataByteSize);

    // Call MyAudioSink's method to handle the data
    macAudioSink.CopyData(myArray, numSamples, nullptr);

    // Delete myArray
    free(myArray);

    return noErr;
}

const char *AudioFormatIDToString(AudioFormatID format)
{
    switch (format)
    {
    case kAudioFormatLinearPCM:
        return "lpcm";
    case kAudioFormatAC3:
        return "ac-3";
    // Add cases for each format
    default:
        return "Unknown Format";
    }
}

std::string AudioFormatFlagsToString(AudioFormatFlags flags)
{
    std::string result;
    if (flags & kAudioFormatFlagIsFloat)
        result += "Float, ";
    if (flags & kAudioFormatFlagIsBigEndian)
        result += "BigEndian, ";
    if (flags & kAudioFormatFlagIsSignedInteger)
        result += "SignedInteger, ";
    if (flags & kAudioFormatFlagIsPacked)
        result += "Packed, ";
    if (flags & kAudioFormatFlagIsAlignedHigh)
        result += "AlignedHigh, ";
    if (flags & kAudioFormatFlagIsNonInterleaved)
        result += "NonInterleaved, ";
    if (flags & kAudioFormatFlagIsNonMixable)
        result += "NonMixable, ";
    if (flags == kAudioFormatFlagsAreAllClear)
        return "All Flags Clear";
    if (result.empty())
        return "No Flags Set";
    return result.substr(0, result.size() - 2); // Remove trailing comma and space
}

#ifdef __cplusplus
extern "C"
{
#endif

    AudioDeviceID deviceID = kAudioObjectUnknown;
    // Set the input data source to our callback function
    AudioDeviceIOProcID procID = NULL;

    FUNCTION_ATTRIBUTE double newlistenMic()
    {

        UInt32 dataSize = sizeof(deviceID);
        AudioObjectPropertyAddress propertyAddress = {
            kAudioHardwarePropertyDefaultInputDevice,
            kAudioObjectPropertyScopeGlobal,
            kAudioObjectPropertyElementMaster};

        // Get the default input device
        OSStatus status = AudioObjectGetPropertyData(kAudioObjectSystemObject,
                                                     &propertyAddress,
                                                     0,
                                                     NULL,
                                                     &dataSize,
                                                     &deviceID);
        if (status != noErr)
        {
            fprintf(stderr, "Error getting default audio device\n");
            return -1;
        }

        // Get the device name
        CFStringRef deviceName = NULL;
        propertyAddress.mSelector = kAudioObjectPropertyName;
        dataSize = sizeof(deviceName);
        status = AudioObjectGetPropertyData(deviceID,
                                            &propertyAddress,
                                            0, NULL,
                                            &dataSize,
                                            &deviceName);
        if (status != noErr)
        {
            fprintf(stderr, "Error getting device name\n");
            return -1;
        }

        // Convert CFStringRef to C string if needed
        char name[128];
        if (CFStringGetCString(deviceName, name, sizeof(name), kCFStringEncodingUTF8))
        {
            printf("Device Name: %s\n", name);
        }
        else
        {
            fprintf(stderr, "Error converting device name to C string\n");
        }

        // Release the CFStringRef
        if (deviceName)
        {
            CFRelease(deviceName);
        }

        AudioStreamBasicDescription streamFormat;

        // Get the stream format of the default input device
        propertyAddress.mSelector = kAudioDevicePropertyStreamFormat;
        propertyAddress.mScope = kAudioDevicePropertyScopeInput;
        dataSize = sizeof(streamFormat);
        status = AudioObjectGetPropertyData(deviceID,
                                            &propertyAddress,
                                            0,
                                            NULL,
                                            &dataSize,
                                            &streamFormat);

        if (status != noErr)
        {
            fprintf(stderr, "Error getting audio stream format\n");
            return -1;
        }

        // Print the sample rate and bit depth
        printf("Sample Rate: %f Hz\n", streamFormat.mSampleRate);
        printf("Format ID: %u\n", streamFormat.mFormatID);
        printf("Audio Format: %s\n", AudioFormatIDToString(streamFormat.mFormatID));
        printf("Format Flags: %u\n", streamFormat.mFormatFlags);
        printf("Audio Format Flags: %s\n", AudioFormatFlagsToString(streamFormat.mFormatFlags).c_str());
        printf("Bytes Per Packet: %u\n", streamFormat.mBytesPerPacket);
        printf("Frames Per Packet: %u\n", streamFormat.mFramesPerPacket);
        printf("Bytes Per Frame: %u\n", streamFormat.mBytesPerFrame);
        printf("Channels Per Frame: %u\n", streamFormat.mChannelsPerFrame);
        printf("Bits Per Channel: %u bits\n", streamFormat.mBitsPerChannel);

        status = AudioDeviceCreateIOProcID(deviceID,
                                           audioInputCallback,
                                           NULL,
                                           &procID);
        if (status != noErr)
        {
            fprintf(stderr, "Error setting IOProc: OSStatus code = %d\n", status);
            return -1;
        }

        // Start the audio hardware
        status = AudioDeviceStart(deviceID, procID);
        if (status != noErr)
        {
            fprintf(stderr, "Error starting audio device\n");
            return -1;
        }

        return 101;
    }

    FUNCTION_ATTRIBUTE double isCheckData(int16_t *micOutputData)
    {
        double result = macAudioSink.DisplayData(micOutputData);
        // std::cout <<  "result in cpp : " << result << std::endl;
        if (result >= 0.0)
        {
            timing_Debug.noteTime();
            return 1.0;
        }
        return 0.0;
    }

    FUNCTION_ATTRIBUTE double stopMicrophone()
    {
        // Stop the audio hardware
        OSStatus status = AudioDeviceStop(deviceID, procID);
        if (status != noErr)
        {
            fprintf(stderr, "Error stopping audio device\n");
            return -1;
        }

        // Destroy the IO proc after stopping
        status = AudioDeviceDestroyIOProcID(deviceID, procID);
        if (status != noErr)
        {
            fprintf(stderr, "Error destroying IOProc\n");
            return -1;
        }

        return 1;
    }

    EXTERNC FUNCTION_ATTRIBUTE int getAvg()
    {

        return timing_Debug.getAvg();
    }
    EXTERNC FUNCTION_ATTRIBUTE int getMin()
    {

        return timing_Debug.getMinTime();
    }
    EXTERNC FUNCTION_ATTRIBUTE int getMax()
    {

        return timing_Debug.getMaxTime();
    }

#ifdef __cplusplus
}

#endif
----- END ./native_implementation/pluggins/native_add/src/mac_capture_audio.cpp -----

----- BEGIN ./native_implementation/pluggins/native_add/src/notch_filter.cpp -----
#include "notch_filter.h"

//
NotchFilter NotchFilters50[6];
NotchFilter NotchFilters60[6];
int isNotch50 = 0;
int isNotch60 = 0;
void NotchFilter::calculateCoefficients()
{
    if ((centerFrequency != 0.0f) && (Q != 0.0f))
    {
        intermediateVariables(centerFrequency, Q);

        a0 = (1 + alpha);
        b0 = 1 / a0;
        b1 = (-2 * omegaC) / a0;
        b2 = 1 / a0;
        a1 = (-2 * omegaC) / a0;
        a2 = (1 - alpha) / a0;
        setCoefficients();
    }
}

void NotchFilter::setCenterFrequency(double newCenterFrequency)
{
    centerFrequency = newCenterFrequency;
    calculateCoefficients();
}

void NotchFilter::setQ(double newQ)
{
    Q = newQ;
    calculateCoefficients();
}
double centerFrequency = 0;
double Q = 0;

EXTERNC FUNCTION_ATTRIBUTE double setNotch(int16_t _isNotch50, int16_t _isNotch60)
{
    isNotch50 = _isNotch50;
    isNotch60 = _isNotch60;
    return 1;
}

EXTERNC FUNCTION_ATTRIBUTE double initNotchPassFilter(int16_t _isNotch50, int16_t channelCount, double sampleRate, double cutOff, double q)
{
    for (int32_t i = 0; i < channelCount; i++)
    {

        // NotchFilter NotchFilter = NotchFilters[i];
        if (_isNotch50 == 1)
        {
            // std::cout << "init notchFilter : " << std::endl;

            NotchFilters50[i].initWithSamplingRate(sampleRate);
            if (cutOff > sampleRate / 2.0f)
                cutOff = sampleRate / 2.0f;
            NotchFilters50[i].setCenterFrequency(cutOff);
            NotchFilters50[i].setQ(q);
        }
        else
        {
            NotchFilters60[i].initWithSamplingRate(sampleRate);
            if (cutOff > sampleRate / 2.0f)
                cutOff = sampleRate / 2.0f;
            NotchFilters60[i].setCenterFrequency(cutOff);
            NotchFilters60[i].setQ(q);
        }
    }
    return NotchFilters50[0].omega;
}

EXTERNC FUNCTION_ATTRIBUTE double applyNotchPassFilter(int16_t _isNotch50, int16_t channelIdx, int16_t *data, int32_t sampleCount)
{
    if (_isNotch50 == 1)
    {
        if (NotchFilters50[channelIdx].omega != 0)
        {
            NotchFilters50[channelIdx].filter(data, sampleCount, false);
            return 1;
        }
        else
        {
            // return -1;
            return NotchFilters50[channelIdx].omega;
        }
    }
    else
    {
        if (NotchFilters60[channelIdx].omega != 0)
        {
            NotchFilters60[channelIdx].filter(data, sampleCount, false);
            return 1;
        }
        else
        {
            // return -1;
            return NotchFilters60[channelIdx].omega;
        }
    }
}

----- END ./native_implementation/pluggins/native_add/src/notch_filter.cpp -----

----- BEGIN ./native_implementation/pluggins/native_add/src/notch_filter.h -----
//
// Created by Stanislav Mircic  <stanislav at backyardbrains.com>
//
#ifndef SPIKE_RECORDER_ANDROID_NotchFilter
#define SPIKE_RECORDER_ANDROID_NotchFilter
// https://www.howtogeek.com/297721/how-to-create-and-use-symbolic-links-aka-symlinks-on-a-mac/
#include "filter_base.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <stdint.h>

#ifdef __cplusplus
#define EXTERNC extern "C"
#else
#define EXTERNC
#endif

#if defined(__GNUC__)
#define FUNCTION_ATTRIBUTE __attribute__((visibility("default"))) __attribute__((used))
#elif defined(_MSC_VER)
#define FUNCTION_ATTRIBUTE __declspec(dllexport)
#endif

class NotchFilter : public FilterBase
{
public:
    // NotchFilter(){};
    NotchFilter() = default;
    void calculateCoefficients();
    void setCenterFrequency(double newCenterFrequency);
    void setQ(double newQ);
    double centerFrequency;
    double Q;

protected:
private:
};

EXTERNC FUNCTION_ATTRIBUTE double setNotch(int16_t _isNotch50, int16_t _isNotch60);
EXTERNC FUNCTION_ATTRIBUTE double initNotchPassFilter(int16_t _isNotch50, int16_t channelCount, double sampleRate, double cutOff, double q);
EXTERNC FUNCTION_ATTRIBUTE double applyNotchPassFilter(int16_t _isNotch50, int16_t channelIdx, int16_t *data, int32_t sampleCount);

#endif

----- END ./native_implementation/pluggins/native_add/src/notch_filter.h -----

----- BEGIN ./native_implementation/pluggins/native_add/src/sample_buffer.cpp -----
#include "sample_buffer.h"

SampleBuffer::SampleBuffer(int64_t pos) : _pos(pos), _head(0), _buffer(new int16_t[SIZE]), _notEmpty(false)
{
    memset(_buffer, 0, sizeof(int16_t[SIZE]));
    memset(segmentsState, 0, sizeof(int[NUMBER_OF_SEGMENTS]));

    int size = SIZE / 2;

    // create SIZE_LOG2 (21) envelope arrays.
    for (int i = 0; i < SIZE_LOG2; i++, size /= 2)
    {
        _envelopes[i].assign(size + 1, std::pair<int16_t, int16_t>(0, 0));
    }
}

//
// Copy envelopes
//
SampleBuffer::SampleBuffer(const SampleBuffer &other) : _pos(other._pos), _head(other._head), _buffer(new int16_t[SIZE]), _notEmpty(false)
{

    // std::cout << "" << pos1 << std::endl;

    memcpy(_buffer, other._buffer, sizeof(int16_t[SIZE]));
    memcpy(segmentsState, other.segmentsState, sizeof(int[NUMBER_OF_SEGMENTS]));
    for (int i = 0; i < static_cast<int>(SIZE_LOG2); i++)
    {
        _envelopes[i] = other._envelopes[i];
    }
}

//
// Destructor
//
SampleBuffer::~SampleBuffer()
{
    delete[] _buffer;
}

//
// Assign (copy) envelope
//

void SampleBuffer::addData(const int16_t *src, int64_t len)
{
    if (len > 0)
        _notEmpty = true;
    for (int i = 0; i < len; i++)
    {
        for (int j = 1; j <= SIZE_LOG2; j++)
        {
            const int skipCount = (1 << j); // this is 2,4,8,....,2^21 = 2097152
            const int envelopeIndex = (j - 1);
            // This envelopeSampleIndex has same value for skipCount consecutive samples.
            // So for every level of envelope resolution (envelopeIndex) we find max and min sample
            // on interval of skipCount consecutive samples and store as one value of envelope
            // at envelopeSampleIndex index
            const unsigned int envelopeSampleIndex = (_head / skipCount); // ROUNDING on division!!!!

            // std::cout << "snvelopSampleIndex " << envelopeIndex << std::endl;

            if (envelopeSampleIndex >= _envelopes[envelopeIndex].size())
            {
                // this is basicaly error situation, should not ever happen
                continue;
            }

            // check if we have new min/max values with this new sample
            std::pair<int16_t, int16_t> &dst = _envelopes[envelopeIndex][envelopeSampleIndex];
            if (_head % skipCount == 0)
            {
                // if it is first in skipCount consecutive samples
                // take this to compare with others
                dst = std::pair<int16_t, int16_t>(*src, *src);
            }
            else
            {
                // if it is not first in skipCount consecutive samples
                //  compare and keep max and min
                dst = std::pair<int16_t, int16_t>(std::min(dst.first, *src), std::max(dst.second, *src));
            }
        }

        // add raw data to simple circular buffer
        // std::cout << "head " << _head << std::endl;

        _buffer[_head++] = *src++;

        if (_head == SIZE)
            _head = 0;
    }
    // std::cout << "Adding inside: _pos = " << _pos << "\n";
    _pos += len; // add to cumulative number of samples (number of samples since begining of the time)
    // std::cout << "After Adding inside: _pos = " << _pos << "\n";
    // std::cout<<"Head: "<<_head<<" Pos: "<<_pos<<"\n";
}

//
// Just copy raw data for one channel from interleaved "src" buffer to
// non-interleaved circular buffer "_buffer"
// for "stride" channel
// (just raw data, ignore envelopes)
// Move the reading head (tail) also by "len" samples
//
// Parameters:
// src - source buffer
// len - number of frames (or number of samples for single channel)
// stride - number of channels in one frame
//
void SampleBuffer::simpleAddData(const int16_t *src, int64_t len, int16_t stride)
{
    if (len > 0)
        _notEmpty = true;
    for (int i = 0; i < len; i++)
    {
        // copy data
        _buffer[_head++] = *src;

        // jump to next sample from the same channel
        src = src + stride;

        // wrap around circular buffer
        if (_head == SIZE)
            _head = 0;
    }

    // move reading head (tail) also
    _pos += len;
}

//
// Parameters:
//
//      dst - destination buffer
//      offset - offset in number of samples since begining of the time
//      len - number of samples to get
//
//   Gets raw data from circular bufer using index "offset" that is given
//   in number of the samples since begining of the time. Since "_pos" represents
//   cumulative number of the samples since begining of the time (this buffer has received)
//   offset must be smaller value (we can't fetch into future)
void SampleBuffer::getData(int16_t *dst, int64_t offset, int64_t len) const
{
    int64_t j = 0;
    for (int64_t i = offset - _pos; i < (offset - _pos + len); i++, j++)
    {
        //(i < -SIZE) - we already owervrite values
        if (i < -SIZE)
        {
            dst[j] = 0;
            // std::cout<<"Error - asking for data that does not exist\n";
        }
        else if (i >= 0) //(i >= 0) - asking for future values
        {
            // we will provide last value if we are asking for future values
            // in this way we will not have clicking sound in audio
            // as we would if we are sending zeros for signal with offset
            dst[j] = _buffer[(_head + -1 + SIZE) % SIZE];
            // std::cout<<"Old value"<<"\n";
        }
        else
        {

            dst[j] = _buffer[(_head + i + SIZE) % SIZE];
        }
    }
}

void SampleBuffer::getDataEnvelope(std::pair<int16_t, int16_t> *dst, int64_t offset, int64_t len, int skip) const
{

    // std::cout << " Pos is " << _pos << std::endl;
    // int rightValue = _pos + len;
    // std::cout << " right  int value " << rightValue << std::endl;

    // qDebug() << "SampleBuffer: CALLING getDataEnvelope(<dst>," << offset << "," << len << "," << skip << ") w/ force =" << force;
    const int64_t lllleft = (offset - _pos);        //(negative value)
    const int64_t rrrright = (offset - _pos + len); //(usually negative value if we don't ask for future)
    int j = 0;
    for (int64_t i = lllleft; i < rrrright; j++)
    {
        std::pair<int16_t, int16_t> bounding(0, 0);

        // if (i >= -SIZE) we still have that data in circular buffer
        //  (i + skip <= 0) we are not asking for future
        if (i >= -SIZE && i + skip <= 0)
        {
            // qDebug() << "Whole thing...";
            // we can process the whole thing

            // DEBUG: Stanislav

            uint64_t index = (_head + i + SIZE) % SIZE; // transform index "i" into circular buffer reference frame
            unsigned int remaining = skip;
            bounding = std::pair<int16_t, int16_t>(_buffer[index], _buffer[index]);
            while (remaining > 0)
            {
                // qDebug() << "index =" << index;
                int levels = -1;
                uint64_t multiplier = 1;
                while ((index % (multiplier * 2) == 0) && (multiplier * 2) <= remaining)
                {
                    multiplier *= 2;
                    levels++;
                }
                // qDebug() << "levels =" << levels << " multiplier =" << multiplier;
                if (levels >= 0 && levels < SIZE_LOG2 && (index / multiplier) < _envelopes[levels].size())
                {
                    // qDebug() << "A";
                    // qDebug() << "dst[" << j << "] examines Examining _envelopes[" << (levels-1) << "][" << (index/multiplier) << "]" << _envelopes[levels].size();
                    const std::pair<int16_t, int16_t> val = _envelopes[levels][index / multiplier];
                    // qDebug() << "OK";
                    if (val.first < bounding.first)
                        bounding.first = val.first;
                    if (val.second > bounding.second)
                        bounding.second = val.second;
                    index = (index + multiplier) % SIZE;
                    remaining -= multiplier;
                }
                else
                {
                    // qDebug() << "B";
                    const int16_t val = _buffer[index];
                    if (val > bounding.second)
                        bounding.second = val;
                    if (val < bounding.first)
                        bounding.first = val;
                    index = (index + 1) % SIZE;
                    remaining--;
                }
                // qDebug() << "OK2";
            }
            // qDebug() << "OK3";
            i += skip;
        }
        else if ((i < -SIZE && i + skip <= -SIZE) || i >= 0)
        {
            // qDebug() << "None...";
            // none of it
            i += skip;
        }
        else
        {
            // qDebug() << "Some...";
            // TODO some of it...
            i += skip;
        }
        // if (j > 1897) qDebug() << "dst[" << j << "] =" << bounding << (len / skip);
        dst[j] = bounding;
        // qDebug() << "zZz";
    }
    // qDebug() << "SampleBuffer: RETURNING";
}

std::vector<int16_t> SampleBuffer::getData(int64_t offset, int64_t len) const
{
    std::vector<int16_t> result(len);
    getData(result.data(), offset, len);

    return result;
}

//
// Parameters:
//    offset - offset in samples from begining of the time
//    len - number of samples to get
//    skip - get every "skip" sample (skip "skip"-1 sample after each sample)
//
//
//     returns len/skip data samples
//
std::vector<std::pair<int16_t, int16_t>> SampleBuffer::getDataEnvelope(int64_t offset, int64_t len, int skip) const
{
    // std::cout << "In SampleBuffer::getDataEnvelope" << std::endl;

    std::vector<std::pair<int16_t, int16_t>> result(len / skip);
    // std::cout << "len :  " << len << std::endl;
    // std::cout << "offset :  " << offset << std::endl;
    // std::cout << "skip :  " << skip << std::endl;
    // std::cout << "result length :  " << len / skip << std::endl;
    // << std::endl;
    getDataEnvelope(result.data(), offset, len, skip);
    // std::cout << "result from sampleBuffer : " << offset << std::endl;
    return result;
}

----- END ./native_implementation/pluggins/native_add/src/sample_buffer.cpp -----

----- BEGIN ./native_implementation/pluggins/native_add/src/sample_buffer.h -----
#ifndef BACKYARDBRAINS_SAMPLEBUFFER_H
#define BACKYARDBRAINS_SAMPLEBUFFER_H

#include <vector>
#include <cstring>
#include <cassert>
#include <stdint.h>
#include <iostream>

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <stdint.h>

//==============================================================================
// - This class has circular buffer "_buffer" with raw data for one channel
//   and 21 (SIZE_LOG2) envelopes
// - Each envelope contains subsampled data at different resolution.
// - Each envelope is half the length of previous envelope, namely contains signal at
//   half of the resolution
// - Each envelope contains two arrays. First array contains maximal values of signal and
//   second array contains minimal value of the signal
//
// Values in envelopes are added gradualy as we receive more and more data.
// When circular buffer "_buffer" starts from begining (rewinds) envelopes also start rewriting data
// from the begining
//
// Whole point is to have minimum and maximum on some interval that is phisicaly one pixel
// on the screen so that we can draw vertical line to indicate to user amplitude span of the signal
//
//
//        Look at "AudioView::drawData" it draws vertical lines for each "sample" (subsample)
//        glVertex3i(xc, -data[j].first*_channels[channel].gain*scale+y, 0);
//        glVertex3i(xc, -data[j].second*_channels[channel].gain*scale+y, 0);
//==============================================================================

#define NUMBER_OF_SEGMENTS 120
#define SEGMENT_SIZE 44100

#ifdef __cplusplus
#define EXTERNC extern "C"
#else
#define EXTERNC
#endif

#if defined(__GNUC__)
#define FUNCTION_ATTRIBUTE __attribute__((visibility("default"))) __attribute__((used))
#elif defined(_MSC_VER)
#define FUNCTION_ATTRIBUTE __declspec(dllexport)
#endif

class SampleBuffer
{
public:
    static const int64_t SIZE = NUMBER_OF_SEGMENTS * SEGMENT_SIZE;
    static const int SIZE_LOG2 = 21;

    //
    // Set initial values of parameters and create envelopes
    // create SIZE_LOG2 (21) envelope arrays. Every envelope is half the length of previous
    // each envelope has two arrays:
    // First array holds maximum values of signal (just subsampled)
    // Second array holds minimum values of signal (just subsampled)
    //
    SampleBuffer(int64_t pos = 0);
    //
    // Copy envelopes
    //
    SampleBuffer(const SampleBuffer &other);
    //
    // Destructor
    //
    ~SampleBuffer();
    SampleBuffer &operator=(const SampleBuffer &other)
    {
        _pos = other._pos;
        _head = other._head;
        memcpy(_buffer, other._buffer, sizeof(int16_t[SIZE]));
        memcpy(segmentsState, other.segmentsState, sizeof(int[NUMBER_OF_SEGMENTS]));
        for (int i = 0; i < SIZE_LOG2; i++)
        {
            _envelopes[i] = other._envelopes[i];
        }
        _notEmpty = other._notEmpty;
        return *this;
    }

    //
    // Assign (copy) envelope
    //

    //
    // Look at the explanation at the begining of this file
    //
    // Add raw data from src to circular buffer _buffer and
    // Make envelopes. Check for every sample and every envelope
    // do we have new maximum or minimum.
    //
    // Parameters:
    // src - data from one channel (deinterleaved)
    // len - length of data in samples0
    //
    void addData(const int16_t *src, int64_t len);

    //
    // Just copy raw data for one channel from interleaved "src" buffer to
    // non-interleaved circular buffer "_buffer"
    // for "stride" channel
    // (just raw data, ignore envelopes)
    // Move the reading head (tail) also by "len" samples
    //
    // Parameters:
    // src - source buffer
    // len - number of frames (or number of samples for single channel)
    // stride - number of channels in one frame
    //
    void simpleAddData(const int16_t *src, int64_t len, int16_t stride);

    //
    // Parameters:
    //
    //      dst - destination buffer
    //      offset - offset in number of samples since begining of the time
    //      len - number of samples to get
    //
    //   Gets raw data from circular bufer using index "offset" that is given
    //   in number of the samples since begining of the time. Since "_pos" represents
    //   cumulative number of the samples since begining of the time (this buffer has received)
    //   offset must be smaller value (we can't fetch into future)
    void getData(int16_t *dst, int64_t offset, int64_t len) const;

    void getDataEnvelope(std::pair<int16_t, int16_t> *dst, int64_t offset, int64_t len, int skip) const;

    std::vector<int16_t> getData(int64_t offset, int64_t len) const;

    //
    // Parameters:
    //    offset - offset in samples from begining of the time
    //    len - number of samples to get
    //    skip - get every "skip" sample (skip "skip"-1 sample after each sample)
    //
    //
    //     returns len/skip data samples
    //
    std::vector<std::pair<int16_t, int16_t>> getDataEnvelope(int64_t offset, int64_t len, int skip) const;
    int16_t at(int64_t pos) const
    {
        if (pos <= _pos - SIZE || pos >= _pos)
            return 0;
        return _buffer[(_head + pos - _pos + SIZE) % SIZE];
    }
    int64_t pos() const { return _pos; }

    void setPos(int64_t pos)
    {
        // std::cout<< "SampleBuffer: SETPOS CALLED "<<pos<<"\n";
        _pos = pos;
    }

    int head() const { return _head; }

    void setHead(int head)
    {
        _head = head % SIZE;
    }

    void reset()
    {
        //  std::cout<<"!!!!!!!!!!!!!!!!!! RESET buffer!!!!!!!!!!!\n";
        _pos = 0;
        _head = 0;
        memset(segmentsState, 0, sizeof(int[NUMBER_OF_SEGMENTS]));
        if (_notEmpty)
        {
            _notEmpty = false;
            memset(_buffer, 0, SIZE * sizeof(int16_t));

            for (int i = 0, size = SIZE / 2; i < SIZE_LOG2; i++, size /= 2)
                _envelopes[i].assign(size + 1, std::pair<int16_t, int16_t>(0, 0));
        }
    }
    bool empty() const { return !_notEmpty; }
    int segmentsState[NUMBER_OF_SEGMENTS];

private:
    // LOADED number of samples since begining of the time (we have to have that since
    // other parts of the application calculate samples from begining of the time
    // and this class has circular buffer that rewinds all the time)
    int64_t _pos;

    // LOADED number of bytes position of head in "_buffer" circular buffer
    int _head;

    // Circular buffer with raw data. Size is SIZE = 44100*60*1 samples
    int16_t *const _buffer;

    // There are SIZE_LOG2 (21) envelope arrays. Every envelope is half the length of previous
    // each envelope has two arrays:
    // First array holds maximum values of signal (just subsampled)
    // Second array holds minimum values of signal (just subsampled)
    std::vector<std::pair<int16_t, int16_t>> _envelopes[SIZE_LOG2];

    bool _notEmpty;
};

#endif

----- END ./native_implementation/pluggins/native_add/src/sample_buffer.h -----

----- BEGIN ./native_implementation/pluggins/native_add/src/timing_debug.cpp -----

#include "timing_debug.h"

long long TimingDebug::fetchTime()
{
    auto now = std::chrono::system_clock::now();
    auto duration = now.time_since_epoch();
    return std::chrono::duration_cast<std::chrono::milliseconds>(duration).count();
}

void TimingDebug::noteTime()
{

    long long time = fetchTime();
    //
    //
    long long elapsedTime = time - previousTimeStamp; // Calculate elapsed time

    if (previousTimeStamp != 0)
    {
        totalElapsedTime += elapsedTime;
    }
    previousTimeStamp = time;
    // std::cout << "elapsed time: " << elapsedTime << std::endl;
    // std::cout << "fetch time: " << time << std::endl;
    // std::cout << "Elapsed Time: " << totalElapsedTime << std::endl;
    // std::cout << "previous Time: " << previousTimeStamp << std::endl;
    // std::cout << "maxTime: " << getMaxTime() << std::endl;
    // std::cout << "minTime: " << getMinTime() << std::endl;

    setMinTime(elapsedTime);
    setMaxTime(elapsedTime);
    setAvgTime(elapsedTime);
}

void TimingDebug::setMinTime(long long latestTime)
{
    if (latestTime < minTime)
    {
        minTime = latestTime;
    }
}

void TimingDebug::setMaxTime(long long latestTime)
{
    if (latestTime > maxTime)
    {
        maxTime = latestTime;
    }
}

void TimingDebug::setAvgTime(long long latestTime)
{
    count++;
    averageTime = totalElapsedTime / count;
    // std::cout << "Average Time: " << averageTime << std::endl;
}

// void TimingDebug::reset()
// {
//     maxTime = 0;
//     minTime = 0;
//     previousTimeStamp = 0;
// }

// EXTERNC FUNCTION_ATTRIBUTE int getTimeMic()
// {
//     auto current_time = std::chrono::steady_clock::now();
//     auto elapsed_time = std::chrono::duration_cast<std::chrono::milliseconds>(current_time - pMySink.start_time);
//     int seconds = static_cast<int>(elapsed_time.count());
//     // // Now you can use 'seconds' as an integer
//     // // std::cout << "result in seconds: " << seconds << std::endl;
//     timingDebug.noteTime(seconds);
//     std::cout << "Elapsed Time: " << timingDebug.getElapsedTime() << std::endl;
//     // std::cout << "Max Time: " << timing.getMaxTime() << std::endl;
//     // std::cout << "Min Time: " << timing.getMinTime() << std::endl;

//     return timingDebug.getElapsedTime();
// }

----- END ./native_implementation/pluggins/native_add/src/timing_debug.cpp -----

----- BEGIN ./native_implementation/pluggins/native_add/src/timing_debug.h -----
#ifndef BACKYARDBRAINS_TIMINGBUFFER_H
#define BACKYARDBRAINS_TIMINGBUFFER_H

#include <iostream>
//

#include <chrono>

#ifdef __cplusplus
#define EXTERNC extern "C"
#else
#define EXTERNC
#endif

#if defined(__GNUC__)
#define FUNCTION_ATTRIBUTE __attribute__((visibility("default"))) __attribute__((used))
#elif defined(_MSC_VER)
#define FUNCTION_ATTRIBUTE __declspec(dllexport)
#endif

class TimingDebug
{
public:
    long long totalElapsedTime = 0;
    void noteTime();
    // Getter functions
    int getMaxTime() const { return maxTime; }
    int getMinTime() const { return minTime; }
    int getAvg() const
    {
        return averageTime;
    }
    // int getElapsedTime() const { return elapsedTime; } // Getter for elapsed time

private:
    long long maxTime = LLONG_MAX;
    long long minTime = LLONG_MIN;
    long long averageTime = 0;
    long long previousTimeStamp = 0;
    long long count = 0;

    long long fetchTime();
    void setMinTime(long long latestTime); // Updated: Added parameter to setMinTime
    void setMaxTime(long long latestTime);
    void setAvgTime(long long latestTime);
};

// EXTERNC FUNCTION_ATTRIBUTE int getTimeMic();

// EXTERNC FUNCTION_ATTRIBUTE int getMin();

// EXTERNC FUNCTION_ATTRIBUTE int getMax();
#endif

----- END ./native_implementation/pluggins/native_add/src/timing_debug.h -----

----- BEGIN ./pubspec.yaml -----
name: spikerbox_architecture
description: A new Flutter project.
# The following line prevents the package from being accidentally published to
# pub.dev using `flutter pub publish`. This is preferred for private packages.
publish_to: 'none' # Remove this line if you wish to publish to pub.dev

# The following defines the version and build number for your application.
# A version number is three numbers separated by dots, like 1.2.43
# followed by an optional build number separated by a +.
# Both the version and the builder number may be overridden in flutter
# build by specifying --build-name and --build-number, respectively.
# In Android, build-name is used as versionName while build-number used as versionCode.
# Read more about Android versioning at https://developer.android.com/studio/publish/versioning
# In iOS, build-name is used as CFBundleShortVersionString while build-number is used as CFBundleVersion.
# Read more about iOS versioning at
# https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html
# In Windows, build-name is used as the major, minor, and patch parts
# of the product and file versions while build-number is used as the build suffix.
version: 1.0.0+1

environment:
  sdk: '>=2.19.1 <3.0.0'

# Dependencies specify other packages that your package needs in order to work.
# To automatically upgrade your package dependencies to the latest versions
# consider running `flutter pub upgrade --major-versions`. Alternatively,
# dependencies can be manually updated by changing the version numbers below to
# the latest version available on pub.dev. To see which dependencies have newer
# versions available, run `flutter pub outdated`.
dependencies:
  flutter:
    sdk: flutter
  native_add:
    path : native_implementation/pluggins/native_add/

  # mic_stream:
  #   path : native_implementation/pluggins/mic_stream/

  flutter_audio_waveforms:
    path : native_implementation/pluggins/flutter_audio_waveforms1.1.1.3/

  # The following adds the Cupertino Icons font to your application.
  # Use with the CupertinoIcons class for iOS style icons.
  cupertino_icons: ^1.0.6
  syncfusion_flutter_charts: ^21.1.36
  http: ^1.1.0
  isolated_worker: ^0.1.1
  usb_serial: ^0.5.1
  permission_handler: ^11.0.0
  flutter_libserialport: ^0.3.0
  serial: ^0.0.4
  squadron: ^5.1.6
  isolate_manager: ^4.1.1
  wasm_interop: ^2.0.1
  provider: ^6.0.5
  path_provider: ^2.1.1
  url_launcher: ^6.1.14
  ffi: ^2.1.0
  just_audio: ^0.9.35
  audio_session: ^0.1.16
  # flutter_soloud: ^1.2.4
  fps_widget: 1.0.1+1
  mic_stream: ^0.7.1+2
  sound_stream_now: ^1.0.0
  serial_communication: ^0.0.2
  # flutter_audio_waveforms: ^1.2.1+8
  # flutter_audio_waveforms: ^1.2.1+8

  
  
  

  # inject_js: ^2.0.0
  # web_ffi: ^0.7.2
dependency_overrides:
  http: ^0.13.1
  

dev_dependencies:
  flutter_test:
    sdk: flutter

  # The "flutter_lints" package below contains a set of recommended lints to
  # encourage good coding practices. The lint set provided by the package is
  # activated in the `analysis_options.yaml` file located at the root of your
  # package. See that file for information about deactivating specific lint
  # rules and activating additional ones.
  flutter_lints: ^2.0.3

# For information on the generic Dart part of this file, see the
# following page: https://dart.dev/tools/pub/pubspec

# The following section is specific to Flutter packages.
flutter:

  # The following line ensures that the Material Icons font is
  # included with your application, so that you can use the icons in
  # the material Icons class.
  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  assets:
    - assets/
    - assets/spiker_logo.jpeg
    # - assets/recordwithsoftware.txt
  #   - images/a_dot_ham.jpeg

  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/assets-and-images/#resolution-aware

  # For details regarding adding assets from package dependencies, see
  # https://flutter.dev/assets-and-images/#from-packages

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts from package dependencies,
  # see https://flutter.dev/custom-fonts/#from-packages

----- END ./pubspec.yaml -----

----- BEGIN ./test/widget_test.dart -----
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:spikerbox_architecture/main.dart';

void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(const MyApp());

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}

----- END ./test/widget_test.dart -----

----- BEGIN ./web/envelope.cpp -----
#include <emscripten/bind.h>
#include <emscripten/val.h>
#include <emscripten.h>
using namespace emscripten;

#ifdef __cplusplus
#define EXTERNC extern "C"
#else
#define EXTERNC
#endif

#include <iostream>
#include <vector>
#include <random>
#include "sample_buffer.cpp"

SampleBuffer sampleBuffer;

EXTERNC FUNCTION_ATTRIBUTE double addDataToSampleBuffer(int16_t *src, int64_t len)
{
    // int64_t offset, int64_t len  required parameter
    sampleBuffer.addData(src, len);
    return 1.0;
}

static int64_t snapTo(int64_t val, int64_t increments)
{
    if (increments > 1)
    {
        val /= increments;
        val *= increments;
    }
    return val;
}

EXTERNC FUNCTION_ATTRIBUTE double getDataFromSampleBuffer(int32_t offset, int32_t len, int32_t skip, int16_t *src)
{

    std::cout << "offset " << offset << std::endl;
    std::cout << "len " << offset << std::endl;

    std::cout << "skip " << offset << std::endl;

    std::cout << "offset " << src.len << std::endl;
    // std::cout << "get data is calling" << std::endl;
    // int64_t offset, int64_t len, int skip   *required  parameter
    const int64_t pos2 = offset + len;

    const int64_t pos1 = snapTo(offset, skip);

    // std::cout << "pos1 " << pos1 << std::endl;
    // std::cout << "pos2 " << pos2 << std::endl;
    // std::cout << "skip" << skip << std::endl;

    int64_t newLengthOfData = pos2 - pos1;

    // int sampleSkip = len ~ / 4000;
    // std::cout << " skip sample is " << sampleSkip << std::endl;

    std::vector<std::pair<int16_t, int16_t>>
        dataAfterEnvelop = sampleBuffer.getDataEnvelope(pos1, newLengthOfData, skip);

    // std::cout << "Data after envelop " << std::endl;
    size_t dataSize = dataAfterEnvelop.size() * 2; // Two int16_t elements per pair

    // Allocate memory for the int16_t array
    // src = int16_t[dataSize];

    // Copy data from vector to array
    // std::cout << "dataAfterEnvelop size " << dataAfterEnvelop.size() << std::endl;

    for (size_t i = 0; i < dataAfterEnvelop.size(); ++i)
    {
        size_t startIndex = 2 * i;
        int minValue = src[2 * i] = dataAfterEnvelop[i].first;
        int maxValue = src[(2 * i) + 1] = dataAfterEnvelop[i].second;
        // std::cout << " minValue is " << minValue << std::endl;
        // std::cout << "MaxValue at index " << startIndex + 1 << ": " << maxValue << std::endl;
    }

    return 1.0;
}
EXTERNC FUNCTION_ATTRIBUTE double resetClassInstance()
{
    // int64_t offset, int64_t len  required parameter
    sampleBuffer.reset();

    return 1.0;
}

----- END ./web/envelope.cpp -----

----- BEGIN ./web/filter_base.cpp -----
#include <emscripten/bind.h>
#include <emscripten/val.h>
#include <emscripten.h>
using namespace emscripten;

//
// Created by Stanislav Mircic  <stanislav at backyardbrains.com>
//

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

#ifndef SPIKE_RECORDER_ANDROID_FILTERBASE
#define SPIKE_RECORDER_ANDROID_FILTERBASE

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <stdint.h>

#ifdef __cplusplus
#define EXTERNC extern "C"
#else
#define EXTERNC
#endif

class FilterBase
{
public:
    int val;

    // FilterBase(){
    // }
    FilterBase() = default;

    double getSamplingRate()
    {
        return samplingRate;
    }

    void initWithSamplingRate(double sr)
    {
        samplingRate = sr;
        // omega = 0;
        // omegaS = 0;
        // omegaC = 0;
        // alpha = 0;
        // gInputKeepBuffer[0]=0;
        // gInputKeepBuffer[1]=0;
        // gOutputKeepBuffer[0]=0;
        // gOutputKeepBuffer[1]=0;
        // double gInputKeepBuffer[2];
        // double gOutputKeepBuffer[2];
        // double omega, omegaS, omegaC, alpha;
        // double coefficients[5];
        // double a0, a1, a2, b0, b1, b2;

        for (double &coefficient : coefficients)
        {
            coefficient = 0.0f;
        }

        gInputKeepBuffer[0] = 0.0f;
        gInputKeepBuffer[1] = 0.0f;
        gOutputKeepBuffer[0] = 0.0f;
        gOutputKeepBuffer[1] = 0.0f;

        one = 1.0f;
    }

    void setCoefficients()
    {
        coefficients[0] = b0;
        coefficients[1] = b1;
        coefficients[2] = b2;
        coefficients[3] = a1;
        coefficients[4] = a2;
    }
    void filter(int16_t *data, int32_t numFrames, bool flush)
    {
        auto *tempdoubleBuffer = (double *)std::malloc(numFrames * sizeof(double));
        for (int32_t i = numFrames - 1; i >= 0; i--)
        {
            tempdoubleBuffer[i] = (double)data[i];
        }
        filterContiguousData(tempdoubleBuffer, numFrames);
        if (flush)
        {
            for (int32_t i = numFrames - 1; i >= 0; i--)
            {
                data[i] = 0;
            }
        }
        else
        {
            for (int32_t i = numFrames - 1; i >= 0; i--)
            {
                data[i] = (int16_t)tempdoubleBuffer[i];
            }
        }
        free(tempdoubleBuffer);
    }

    void filterContiguousData(double *data, int32_t numFrames)
    {
        // Provide buffer for processing
        auto *tInputBuffer = (double *)std::malloc((numFrames + 2) * sizeof(double));
        auto *tOutputBuffer = (double *)std::malloc((numFrames + 2) * sizeof(double));

        // Copy the data
        memcpy(tInputBuffer, gInputKeepBuffer, 2 * sizeof(double));
        memcpy(tOutputBuffer, gOutputKeepBuffer, 2 * sizeof(double));
        memcpy(&(tInputBuffer[2]), data, numFrames * sizeof(double));

        // Do the processing
        // vDSP_deq22(tInputBuffer, 1, coefficients, tOutputBuffer, 1, numFrames);
        // https://developer.apple.com/library/ios/documentation/Accelerate/Reference/vDSPRef/index.html#//apple_ref/c/func/vDSP_deq22
        int n;
        for (n = 2; n < numFrames + 2; n++)
        {
            tOutputBuffer[n] = tInputBuffer[n] * coefficients[0] + tInputBuffer[n - 1] * coefficients[1] +
                               tInputBuffer[n - 2] * coefficients[2] - tOutputBuffer[n - 1] * coefficients[3] -
                               tOutputBuffer[n - 2] * coefficients[4];
        }

        // Copy the data
        memcpy(data, tOutputBuffer, numFrames * sizeof(double));
        memcpy(gInputKeepBuffer, &(tInputBuffer[numFrames]), 2 * sizeof(double));
        memcpy(gOutputKeepBuffer, &(tOutputBuffer[numFrames]), 2 * sizeof(double));

        free(tInputBuffer);
        free(tOutputBuffer);
    }
    void intermediateVariables(double Fc, double Q)
    {
        omega = 2 * M_PI * Fc / samplingRate;
        omegaS = sin(omega);
        omegaC = cos(omega);
        alpha = omegaS / (2 * Q);
    }

    double one;
    double samplingRate;
    double gInputKeepBuffer[2];
    double gOutputKeepBuffer[2];
    double omega, omegaS, omegaC, alpha;
    double coefficients[5];
    double a0, a1, a2, b0, b1, b2;

protected:
private:
};

#endif
----- END ./web/filter_base.cpp -----

----- BEGIN ./web/filter_base.h -----
//
// Created by Stanislav Mircic  <stanislav at backyardbrains.com>
//

// #include <FilterBase.h>
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

#ifndef SPIKE_RECORDER_ANDROID_FILTERBASE
#define SPIKE_RECORDER_ANDROID_FILTERBASE

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <stdint.h>

#ifdef __cplusplus
#define EXTERNC extern "C"
#else
#define EXTERNC
#endif

class FilterBase
{
public:
    int val;

    // FilterBase(){
    // }
    FilterBase() = default;

    double getSamplingRate()
    {
        return samplingRate;
    }

    void initWithSamplingRate(double sr)
    {
        samplingRate = sr;
        // omega = 0;
        // omegaS = 0;
        // omegaC = 0;
        // alpha = 0;
        // gInputKeepBuffer[0]=0;
        // gInputKeepBuffer[1]=0;
        // gOutputKeepBuffer[0]=0;
        // gOutputKeepBuffer[1]=0;
        // double gInputKeepBuffer[2];
        // double gOutputKeepBuffer[2];
        // double omega, omegaS, omegaC, alpha;
        // double coefficients[5];
        // double a0, a1, a2, b0, b1, b2;

        for (double &coefficient : coefficients)
        {
            coefficient = 0.0f;
        }

        gInputKeepBuffer[0] = 0.0f;
        gInputKeepBuffer[1] = 0.0f;
        gOutputKeepBuffer[0] = 0.0f;
        gOutputKeepBuffer[1] = 0.0f;

        one = 1.0f;
    }

    void setCoefficients()
    {
        coefficients[0] = b0;
        coefficients[1] = b1;
        coefficients[2] = b2;
        coefficients[3] = a1;
        coefficients[4] = a2;
    }
    void filter(int16_t *data, int32_t numFrames, bool flush)
    {
        auto *tempdoubleBuffer = (double *)std::malloc(numFrames * sizeof(double));
        for (int32_t i = numFrames - 1; i >= 0; i--)
        {
            tempdoubleBuffer[i] = (double)data[i];
        }
        filterContiguousData(tempdoubleBuffer, numFrames);
        if (flush)
        {
            for (int32_t i = numFrames - 1; i >= 0; i--)
            {
                data[i] = 0;
            }
        }
        else
        {
            for (int32_t i = numFrames - 1; i >= 0; i--)
            {
                data[i] = (int16_t)tempdoubleBuffer[i];
            }
        }
        free(tempdoubleBuffer);
    }

    void filterContiguousData(double *data, int32_t numFrames)
    {
        // Provide buffer for processing
        auto *tInputBuffer = (double *)std::malloc((numFrames + 2) * sizeof(double));
        auto *tOutputBuffer = (double *)std::malloc((numFrames + 2) * sizeof(double));

        // Copy the data
        memcpy(tInputBuffer, gInputKeepBuffer, 2 * sizeof(double));
        memcpy(tOutputBuffer, gOutputKeepBuffer, 2 * sizeof(double));
        memcpy(&(tInputBuffer[2]), data, numFrames * sizeof(double));

        // Do the processing
        // vDSP_deq22(tInputBuffer, 1, coefficients, tOutputBuffer, 1, numFrames);
        // https://developer.apple.com/library/ios/documentation/Accelerate/Reference/vDSPRef/index.html#//apple_ref/c/func/vDSP_deq22
        int n;
        for (n = 2; n < numFrames + 2; n++)
        {
            tOutputBuffer[n] = tInputBuffer[n] * coefficients[0] + tInputBuffer[n - 1] * coefficients[1] +
                               tInputBuffer[n - 2] * coefficients[2] - tOutputBuffer[n - 1] * coefficients[3] -
                               tOutputBuffer[n - 2] * coefficients[4];
        }

        // Copy the data
        memcpy(data, tOutputBuffer, numFrames * sizeof(double));
        memcpy(gInputKeepBuffer, &(tInputBuffer[numFrames]), 2 * sizeof(double));
        memcpy(gOutputKeepBuffer, &(tOutputBuffer[numFrames]), 2 * sizeof(double));

        free(tInputBuffer);
        free(tOutputBuffer);
    }
    void intermediateVariables(double Fc, double Q)
    {
        omega = 2 * M_PI * Fc / samplingRate;
        omegaS = sin(omega);
        omegaC = cos(omega);
        alpha = omegaS / (2 * Q);
    }

    double one;
    double samplingRate;
    double gInputKeepBuffer[2];
    double gOutputKeepBuffer[2];
    double omega, omegaS, omegaC, alpha;
    double coefficients[5];
    double a0, a1, a2, b0, b1, b2;

protected:
private:
};

// EXTERNC double createFilters(){
//     return 30;
// }
#endif

----- END ./web/filter_base.h -----

----- BEGIN ./web/high_pass_filter.cpp -----
#include <emscripten/bind.h>
#include <emscripten/val.h>
#include <emscripten.h>
using namespace emscripten;

//
// Created by Stanislav Mircic  <stanislav at backyardbrains.com>
//
#ifndef SPIKE_RECORDER_ANDROID_HIGHPASSFILTER
#define SPIKE_RECORDER_ANDROID_HIGHPASSFILTER

#include "filter_base.cpp"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <stdint.h>

#ifdef __cplusplus
#define EXTERNC extern "C"
#else
#define EXTERNC
#endif

#if defined(__GNUC__)
#define FUNCTION_ATTRIBUTE __attribute__((visibility("default"))) __attribute__((used))
#elif defined(_MSC_VER)
#define FUNCTION_ATTRIBUTE __declspec(dllexport)
#endif

class HighPassFilter : public FilterBase
{
public:
    // LowPassFilter(){};
    HighPassFilter() = default;
    void calculateCoefficients()
    {
        if ((cornerFrequency != 0.0f) && (Q != 0.0f))
        {
            intermediateVariables(cornerFrequency, Q);

            a0 = 1 + alpha;
            b0 = ((1 + omegaC) / 2) / a0;
            b1 = (-1 * (1 + omegaC)) / a0;
            b2 = ((1 + omegaC) / 2) / a0;
            a1 = (-2 * omegaC) / a0;
            a2 = (1 - alpha) / a0;

            setCoefficients();
        }
    }

    void setCornerFrequency(double newCornerFrequency)
    {
        cornerFrequency = newCornerFrequency;
        calculateCoefficients();
    }

    void setQ(double newQ)
    {
        Q = newQ;
        calculateCoefficients();
    }

protected:
    double cornerFrequency;
    double Q;

private:
};

// HighPassFilter* highPassFilters;
HighPassFilter highPassFilters[6];
EXTERNC FUNCTION_ATTRIBUTE double createHighPassFilter(short channelCount, double sampleRate, double highCutOff, double q)
{
    // highPassFilters = new HighPassFilter[channelCount];
    for (int32_t i = 0; i < channelCount; i++)
    {
        // HighPassFilter highPassFilter = HighPassFilter();
        highPassFilters[i].initWithSamplingRate(sampleRate);
        if (highCutOff > sampleRate / 2.0f)
            highCutOff = sampleRate / 2.0f;
        highPassFilters[i].setCornerFrequency(highCutOff);
        highPassFilters[i].setQ(q);
        // highPassFilters[i] = highPassFilter;
    }
    return 1;
}

EXTERNC FUNCTION_ATTRIBUTE double initHighPassFilter(short channelCount, double sampleRate, double highCutOff, double q)
{
    for (int32_t i = 0; i < channelCount; i++)
    {
        // HighPassFilter highPassFilter = highPassFilters[i];
        highPassFilters[i].initWithSamplingRate(sampleRate);
        if (highCutOff > sampleRate / 2.0f)
            highCutOff = sampleRate / 2.0f;
        highPassFilters[i].setCornerFrequency(highCutOff);
        highPassFilters[i].setQ(q);
    }
    return 52;
}

EXTERNC FUNCTION_ATTRIBUTE double applyHighPassFilter(int16_t channelIdx, int16_t *data, int32_t sampleCount)
{
    highPassFilters[channelIdx].filter(data, sampleCount, false);
    return 500;
    // data[0] = -321;
    // EM_ASM({
    //     console.log("C++ read", $0, $1);
    //     console.log(HEAP16.subarray($0, ($0 + 11)));
    //     const idx = HEAP16.indexOf(-321);
    //     console.log(idx, HEAP16.subarray($1 >> 2), ($1 + 20) >> 2);
    // },
    //        data, data);
    // return 511;
}

#endif

// EMSCRIPTEN_BINDINGS(my_module)
// {
//     class_<HighPassFilter>("HighPassFilter")
//         .constructor()
//         .function("calculateCoefficients", &HighPassFilter::calculateCoefficients)
//         .function("setCornerFrequency", &HighPassFilter::setCornerFrequency)
//         .function("setQ", &HighPassFilter::setQ);

//     function("createHighPassFilter", &createHighPassFilter);
//     function("initHighPassFilter", &initHighPassFilter);
//     function("applyHighPassFilter", &applyHighPassFilter);
// }
----- END ./web/high_pass_filter.cpp -----

----- BEGIN ./web/low_pass_filter.cpp -----
#include <emscripten/bind.h>
#include <emscripten/val.h>
#include <emscripten.h>
using namespace emscripten;

//
// Created by Stanislav Mircic  <stanislav at backyardbrains.com>
//
#ifndef SPIKE_RECORDER_ANDROID_LOWPASSFILTER
#define SPIKE_RECORDER_ANDROID_LOWPASSFILTER

#include "filter_base.cpp"

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <stdint.h>

#ifdef __cplusplus
#define EXTERNC extern "C"
#else
#define EXTERNC
#endif

#if defined(__GNUC__)
#define FUNCTION_ATTRIBUTE __attribute__((visibility("default"))) __attribute__((used))
#elif defined(_MSC_VER)
#define FUNCTION_ATTRIBUTE __declspec(dllexport)
#endif

class LowPassFilter : public FilterBase
{
public:
    // LowPassFilter(){};
    LowPassFilter() = default;
    void calculateCoefficients()
    {
        if ((cornerFrequency != 0.0f) && (Q != 0.0f))
        {
            intermediateVariables(cornerFrequency, Q);

            a0 = 1 + alpha;
            b0 = ((1 - omegaC) / 2) / a0;
            b1 = ((1 - omegaC)) / a0;
            b2 = ((1 - omegaC) / 2) / a0;
            a1 = (-2 * omegaC) / a0;
            a2 = (1 - alpha) / a0;

            setCoefficients();
        }
    }

    void setCornerFrequency(double newCornerFrequency)
    {
        cornerFrequency = newCornerFrequency;
        calculateCoefficients();
    }

    void setQ(double newQ)
    {
        Q = newQ;
        calculateCoefficients();
    }

protected:
    double cornerFrequency;
    double Q;

private:
};

// LowPassFilter* lowPassFilters;
LowPassFilter lowPassFilters[6];
EXTERNC FUNCTION_ATTRIBUTE double createLowPassFilter(short channelCount, double sampleRate, double lowCutOff, double q)
{
    // lowPassFilters = new LowPassFilter[channelCount];
    for (int32_t i = 0; i < channelCount; i++)
    {
        // LowPassFilter lowPassFilter = LowPassFilter();
        lowPassFilters[i].initWithSamplingRate(sampleRate);
        if (lowCutOff > sampleRate / 2.0f)
            lowCutOff = sampleRate / 2.0f;
        lowPassFilters[i].setCornerFrequency(lowCutOff);
        lowPassFilters[i].setQ(q);
        // lowPassFilters[i] = lowPassFilter;
    }
    return 1;
}

EXTERNC FUNCTION_ATTRIBUTE double initLowPassFilter(short channelCount, double sampleRate, double lowCutOff, double q)
{
    for (int32_t i = 0; i < channelCount; i++)
    {
        // HighPassFilter highPassFilter = highPassFilters[i];
        lowPassFilters[i].initWithSamplingRate(sampleRate);
        if (lowCutOff > sampleRate / 2.0f)
            lowCutOff = sampleRate / 2.0f;
        lowPassFilters[i].setCornerFrequency(lowCutOff);
        lowPassFilters[i].setQ(q);
    }
    return 100;
}

EXTERNC FUNCTION_ATTRIBUTE double applyLowPassFilter(int16_t channelIdx, int16_t *data, int32_t sampleCount)
{
    if (lowPassFilters[channelIdx].omega != 0)
    {
        lowPassFilters[channelIdx].filter(data, sampleCount, false);
        uintptr_t addr = reinterpret_cast<uintptr_t>(&data[0]);
        return (double)addr;
    }
    return -100;
}

#endif

// EMSCRIPTEN_BINDINGS(my_module)
// {
//     class_<LowPassFilter>("LowPassFilter")
//         .constructor()
//         .function("calculateCoefficients", &LowPassFilter::calculateCoefficients)
//         .function("setCornerFrequency", &LowPassFilter::setCornerFrequency)
//         .function("setQ", &LowPassFilter::setQ);
//     function("createLowPassFilter", &createLowPassFilter);
//     function("initLowPassFilter", &initLowPassFilter);
//     function("applyLowPassFilter", &applyLowPassFilter);
// }
----- END ./web/low_pass_filter.cpp -----

----- BEGIN ./web/main_entry_file.cpp -----
// This file is required because when compiling using emcc command we need "-pthread -s PROXY_TO_PTHREAD" to enable SharedArrayBuffer in WASM.
// and for threading WASM compiler needs main function as entry point.

#include <emscripten/val.h>
#include <emscripten/bind.h>
#include <emscripten.h>
using namespace emscripten;

#ifndef MAIN_ENTRY_FILE
#define MAIN_ENTRY_FILE

#ifdef __cplusplus
#define EXTERNC extern "C"
#else
#define EXTERNC
#endif

#if defined(__GNUC__)
#define FUNCTION_ATTRIBUTE __attribute__((visibility("default"))) __attribute__((used))
#elif defined(_MSC_VER)
#define FUNCTION_ATTRIBUTE __declspec(dllexport)
#endif

EXTERNC int main()
{
    return 0;
}

#endif
----- END ./web/main_entry_file.cpp -----

----- BEGIN ./web/native_add.cpp -----

#include <emscripten/bind.h>
using namespace emscripten;

#include <iostream>

extern "C" {
    int add(int a, int b) {
        return a + b;
    }
}

EMSCRIPTEN_BINDINGS(my_module) {
    function("add", &add);
}
----- END ./web/native_add.cpp -----

----- BEGIN ./web/notch_filter.cpp -----
#include <emscripten/bind.h>
#include <emscripten/val.h>
#include <emscripten.h>
using namespace emscripten;

#ifndef SPIKE_RECORDER_ANDROID_NOTCHFILTER
#define SPIKE_RECORDER_ANDROID_NOTCHFILTER
// https://www.howtogeek.com/297721/how-to-create-and-use-symbolic-links-aka-symlinks-on-a-mac/
#include "filter_base.cpp"

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <stdint.h>

#include <iostream>
#include <array>
#include <functional>
#include <vector>

#ifdef __cplusplus
#define EXTERNC extern "C"
#else
#define EXTERNC
#endif

#if defined(__GNUC__)
#define FUNCTION_ATTRIBUTE __attribute__((visibility("default"))) __attribute__((used))
#elif defined(_MSC_VER)
#define FUNCTION_ATTRIBUTE __declspec(dllexport)
#endif

class NotchFilter : public FilterBase
{
public:
    // NotchFilter(){};
    NotchFilter() = default;

    void calculateCoefficients()
    {
        if ((centerFrequency != 0.0f) && (Q != 0.0f))
        {
            intermediateVariables(centerFrequency, Q);

            a0 = (1 + alpha);
            b0 = 1 / a0;
            b1 = (-2 * omegaC) / a0;
            b2 = 1 / a0;
            a1 = (-2 * omegaC) / a0;
            a2 = (1 - alpha) / a0;
            setCoefficients();
        }
    }

    void setCenterFrequency(double newCenterFrequency)
    {
        centerFrequency = newCenterFrequency;
        calculateCoefficients();
    }

    void setQ(double newQ)
    {
        Q = newQ;
        calculateCoefficients();
    }
    double centerFrequency = 0;
    double Q = 0;

protected:
private:
};

//
NotchFilter NotchFilters50[6];
NotchFilter NotchFilters60[6];
int isNotch50 = 0;
int isNotch60 = 0;
EXTERNC FUNCTION_ATTRIBUTE double setNotch(int16_t _isNotch50, int16_t _isNotch60)
{
    isNotch50 = _isNotch50;
    isNotch60 = _isNotch60;
    return 1;
}

EXTERNC FUNCTION_ATTRIBUTE double initNotchFilter(int16_t _isNotch50, int16_t channelCount, double sampleRate, double cutOff, double q)
{
    for (int32_t i = 0; i < channelCount; i++)
    {
        // NotchFilter NotchFilter = NotchFilters[i];
        if (_isNotch50 == 1)
        {

            NotchFilters50[i].initWithSamplingRate(sampleRate);
            if (cutOff > sampleRate / 2.0f)
                cutOff = sampleRate / 2.0f;
            NotchFilters50[i].setCenterFrequency(cutOff);
            NotchFilters50[i].setQ(q);
        }
        else
        {
            NotchFilters60[i].initWithSamplingRate(sampleRate);
            if (cutOff > sampleRate / 2.0f)
                cutOff = sampleRate / 2.0f;
            NotchFilters60[i].setCenterFrequency(cutOff);
            NotchFilters60[i].setQ(q);
        }
    }
    return NotchFilters50[0].omega;
}

EXTERNC FUNCTION_ATTRIBUTE double applyNotchFilter(int16_t _isNotch50, int16_t channelIdx, int16_t *data, int32_t sampleCount)
{

    
    if (_isNotch50 == 1)
    {

        if (NotchFilters50[channelIdx].omega != 0)
        {
            NotchFilters50[channelIdx].filter(data, sampleCount, false);
            return 1;
        }
        else
        {
            return NotchFilters50[channelIdx].omega;
        }

        // NotchFilters50[channelIdx].filter(data, sampleCount, false);
    }

else
{

    if (NotchFilters60[channelIdx].omega != 0)
    {
        NotchFilters60[channelIdx].filter(data, sampleCount, false);
        // std::vector<short> output(raw.size());

        return 1;
    }
    else
    {

        return NotchFilters60[channelIdx].omega;
    }
}

    // NotchFilters60[channelIdx].filter(data, sampleCount, false);
}

#endif

----- END ./web/notch_filter.cpp -----

----- BEGIN ./web/sample_buffer.cpp -----
#include "sample_buffer.h"

SampleBuffer::SampleBuffer(int64_t pos) : _pos(pos), _head(0), _buffer(new int16_t[SIZE]), _notEmpty(false)
{
    memset(_buffer, 0, sizeof(int16_t[SIZE]));
    memset(segmentsState, 0, sizeof(int[NUMBER_OF_SEGMENTS]));

    int size = SIZE / 2;

    // create SIZE_LOG2 (21) envelope arrays.
    for (int i = 0; i < SIZE_LOG2; i++, size /= 2)
    {
        _envelopes[i].assign(size + 1, std::pair<int16_t, int16_t>(0, 0));
    }
}

//
// Copy envelopes
//
SampleBuffer::SampleBuffer(const SampleBuffer &other) : _pos(other._pos), _head(other._head), _buffer(new int16_t[SIZE]), _notEmpty(false)
{

    // std::cout << "" << pos1 << std::endl;

    memcpy(_buffer, other._buffer, sizeof(int16_t[SIZE]));
    memcpy(segmentsState, other.segmentsState, sizeof(int[NUMBER_OF_SEGMENTS]));
    for (int i = 0; i < static_cast<int>(SIZE_LOG2); i++)
    {
        _envelopes[i] = other._envelopes[i];
    }
}

//
// Destructor
//
SampleBuffer::~SampleBuffer()
{
    delete[] _buffer;
}

//
// Assign (copy) envelope
//

void SampleBuffer::addData(const int16_t *src, int64_t len)
{
    if (len > 0)
        _notEmpty = true;
    for (int i = 0; i < len; i++)
    {
        for (int j = 1; j <= SIZE_LOG2; j++)
        {
            const int skipCount = (1 << j); // this is 2,4,8,....,2^21 = 2097152
            const int envelopeIndex = (j - 1);

            // This envelopeSampleIndex has same value for skipCount consecutive samples.
            // So for every level of envelope resolution (envelopeIndex) we find max and min sample
            // on interval of skipCount consecutive samples and store as one value of envelope
            // at envelopeSampleIndex index
            const unsigned int envelopeSampleIndex = (_head / skipCount); // ROUNDING on division!!!!

            // std::cout << "snvelopSampleIndex " << envelopeIndex << std::endl;

            if (envelopeSampleIndex >= _envelopes[envelopeIndex].size())
            {
                // this is basicaly error situation, should not ever happen
                continue;
            }

            // check if we have new min/max values with this new sample
            std::pair<int16_t, int16_t> &dst = _envelopes[envelopeIndex][envelopeSampleIndex];
            if (_head % skipCount == 0)
            {
                // if it is first in skipCount consecutive samples
                // take this to compare with others
                dst = std::pair<int16_t, int16_t>(*src, *src);
            }
            else
            {
                // if it is not first in skipCount consecutive samples
                //  compare and keep max and min
                dst = std::pair<int16_t, int16_t>(std::min(dst.first, *src), std::max(dst.second, *src));
            }
        }

        // add raw data to simple circular buffer
        // std::cout << "head " << _head << std::endl;

        _buffer[_head++] = *src++;

        if (_head == SIZE)
            _head = 0;
    }
    // std::cout << "Adding inside: _pos = " << _pos << "\n";
    _pos += len; // add to cumulative number of samples (number of samples since begining of the time)
    // std::cout << "After Adding inside: _pos = " << _pos << "\n";
    // std::cout<<"Head: "<<_head<<" Pos: "<<_pos<<"\n";
}

//
// Just copy raw data for one channel from interleaved "src" buffer to
// non-interleaved circular buffer "_buffer"
// for "stride" channel
// (just raw data, ignore envelopes)
// Move the reading head (tail) also by "len" samples
//
// Parameters:
// src - source buffer
// len - number of frames (or number of samples for single channel)
// stride - number of channels in one frame
//
void SampleBuffer::simpleAddData(const int16_t *src, int64_t len, int16_t stride)
{
    if (len > 0)
        _notEmpty = true;
    for (int i = 0; i < len; i++)
    {
        // copy data
        _buffer[_head++] = *src;

        // jump to next sample from the same channel
        src = src + stride;

        // wrap around circular buffer
        if (_head == SIZE)
            _head = 0;
    }

    // move reading head (tail) also
    _pos += len;
}

//
// Parameters:
//
//      dst - destination buffer
//      offset - offset in number of samples since begining of the time
//      len - number of samples to get
//
//   Gets raw data from circular bufer using index "offset" that is given
//   in number of the samples since begining of the time. Since "_pos" represents
//   cumulative number of the samples since begining of the time (this buffer has received)
//   offset must be smaller value (we can't fetch into future)
void SampleBuffer::getData(int16_t *dst, int64_t offset, int64_t len) const
{
    int64_t j = 0;
    for (int64_t i = offset - _pos; i < (offset - _pos + len); i++, j++)
    {
        //(i < -SIZE) - we already owervrite values
        if (i < -SIZE)
        {
            dst[j] = 0;
            // std::cout<<"Error - asking for data that does not exist\n";
        }
        else if (i >= 0) //(i >= 0) - asking for future values
        {
            // we will provide last value if we are asking for future values
            // in this way we will not have clicking sound in audio
            // as we would if we are sending zeros for signal with offset
            dst[j] = _buffer[(_head + -1 + SIZE) % SIZE];
            // std::cout<<"Old value"<<"\n";
        }
        else
        {

            dst[j] = _buffer[(_head + i + SIZE) % SIZE];
        }
    }
}

void SampleBuffer::getDataEnvelope(std::pair<int16_t, int16_t> *dst, int64_t offset, int64_t len, int skip) const
{

    // std::cout << " Pos is " << _pos << std::endl;
    // int rightValue = _pos + len;
    // std::cout << " right  int value " << rightValue << std::endl;

    // qDebug() << "SampleBuffer: CALLING getDataEnvelope(<dst>," << offset << "," << len << "," << skip << ") w/ force =" << force;
    const int64_t lllleft = (offset - _pos);        //(negative value)
    const int64_t rrrright = (offset - _pos + len); //(usually negative value if we don't ask for future)
    int j = 0;
    for (int64_t i = lllleft; i < rrrright; j++)
    {
        std::pair<int16_t, int16_t> bounding(0, 0);

        // if (i >= -SIZE) we still have that data in circular buffer
        //  (i + skip <= 0) we are not asking for future
        if (i >= -SIZE && i + skip <= 0)
        {
            // qDebug() << "Whole thing...";
            // we can process the whole thing

            // DEBUG: Stanislav

            uint64_t index = (_head + i + SIZE) % SIZE; // transform index "i" into circular buffer reference frame
            unsigned int remaining = skip;
            bounding = std::pair<int16_t, int16_t>(_buffer[index], _buffer[index]);
            while (remaining > 0)
            {
                // qDebug() << "index =" << index;
                int levels = -1;
                uint64_t multiplier = 1;
                while ((index % (multiplier * 2) == 0) && (multiplier * 2) <= remaining)
                {
                    multiplier *= 2;
                    levels++;
                }
                // qDebug() << "levels =" << levels << " multiplier =" << multiplier;
                if (levels >= 0 && levels < SIZE_LOG2 && (index / multiplier) < _envelopes[levels].size())
                {
                    // qDebug() << "A";
                    // qDebug() << "dst[" << j << "] examines Examining _envelopes[" << (levels-1) << "][" << (index/multiplier) << "]" << _envelopes[levels].size();
                    const std::pair<int16_t, int16_t> val = _envelopes[levels][index / multiplier];
                    // qDebug() << "OK";
                    if (val.first < bounding.first)
                        bounding.first = val.first;
                    if (val.second > bounding.second)
                        bounding.second = val.second;
                    index = (index + multiplier) % SIZE;
                    remaining -= multiplier;
                }
                else
                {
                    // qDebug() << "B";
                    const int16_t val = _buffer[index];
                    if (val > bounding.second)
                        bounding.second = val;
                    if (val < bounding.first)
                        bounding.first = val;
                    index = (index + 1) % SIZE;
                    remaining--;
                }
                // qDebug() << "OK2";
            }
            // qDebug() << "OK3";
            i += skip;
        }
        else if ((i < -SIZE && i + skip <= -SIZE) || i >= 0)
        {
            // qDebug() << "None...";
            // none of it
            i += skip;
        }
        else
        {
            // qDebug() << "Some...";
            // TODO some of it...
            i += skip;
        }
        // if (j > 1897) qDebug() << "dst[" << j << "] =" << bounding << (len / skip);
        dst[j] = bounding;
        // qDebug() << "zZz";
    }
    // qDebug() << "SampleBuffer: RETURNING";
}

std::vector<int16_t> SampleBuffer::getData(int64_t offset, int64_t len) const
{
    std::vector<int16_t> result(len);
    getData(result.data(), offset, len);

    return result;
}

//
// Parameters:
//    offset - offset in samples from begining of the time
//    len - number of samples to get
//    skip - get every "skip" sample (skip "skip"-1 sample after each sample)
//
//
//     returns len/skip data samples
//
std::vector<std::pair<int16_t, int16_t>> SampleBuffer::getDataEnvelope(int64_t offset, int64_t len, int skip) const
{
    // std::cout << "In SampleBuffer::getDataEnvelope" << std::endl;

    std::vector<std::pair<int16_t, int16_t>> result(len / skip);
    // std::cout << "len :  " << len << std::endl;
    // std::cout << "offset :  " << offset << std::endl;
    // std::cout << "skip :  " << skip << std::endl;
    // std::cout << "result length :  " << len / skip << std::endl;
    // << std::endl;
    getDataEnvelope(result.data(), offset, len, skip);
    // std::cout << "result from sampleBuffer : " << offset << std::endl;
    return result;
}

----- END ./web/sample_buffer.cpp -----

----- BEGIN ./web/sample_buffer.h -----
#ifndef BACKYARDBRAINS_SAMPLEBUFFER_H
#define BACKYARDBRAINS_SAMPLEBUFFER_H

#include <vector>
#include <cstring>
#include <cassert>
#include <stdint.h>
#include <iostream>

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <stdint.h>

//==============================================================================
// - This class has circular buffer "_buffer" with raw data for one channel
//   and 21 (SIZE_LOG2) envelopes
// - Each envelope contains subsampled data at different resolution.
// - Each envelope is half the length of previous envelope, namely contains signal at
//   half of the resolution
// - Each envelope contains two arrays. First array contains maximal values of signal and
//   second array contains minimal value of the signal
//
// Values in envelopes are added gradualy as we receive more and more data.
// When circular buffer "_buffer" starts from begining (rewinds) envelopes also start rewriting data
// from the begining
//
// Whole point is to have minimum and maximum on some interval that is phisicaly one pixel
// on the screen so that we can draw vertical line to indicate to user amplitude span of the signal
//
//
//        Look at "AudioView::drawData" it draws vertical lines for each "sample" (subsample)
//        glVertex3i(xc, -data[j].first*_channels[channel].gain*scale+y, 0);
//        glVertex3i(xc, -data[j].second*_channels[channel].gain*scale+y, 0);
//==============================================================================

#define NUMBER_OF_SEGMENTS 120
#define SEGMENT_SIZE 44100

#ifdef __cplusplus
#define EXTERNC extern "C"
#else
#define EXTERNC
#endif

#if defined(__GNUC__)
#define FUNCTION_ATTRIBUTE __attribute__((visibility("default"))) __attribute__((used))
#elif defined(_MSC_VER)
#define FUNCTION_ATTRIBUTE __declspec(dllexport)
#endif

class SampleBuffer
{
public:
    static const int64_t SIZE = NUMBER_OF_SEGMENTS * SEGMENT_SIZE;
    static const int SIZE_LOG2 = 21;

    //
    // Set initial values of parameters and create envelopes
    // create SIZE_LOG2 (21) envelope arrays. Every envelope is half the length of previous
    // each envelope has two arrays:
    // First array holds maximum values of signal (just subsampled)
    // Second array holds minimum values of signal (just subsampled)
    //
    SampleBuffer(int64_t pos = 0);
    //
    // Copy envelopes
    //
    SampleBuffer(const SampleBuffer &other);
    //
    // Destructor
    //
    ~SampleBuffer();
    SampleBuffer &operator=(const SampleBuffer &other)
    {
        _pos = other._pos;
        _head = other._head;
        memcpy(_buffer, other._buffer, sizeof(int16_t[SIZE]));
        memcpy(segmentsState, other.segmentsState, sizeof(int[NUMBER_OF_SEGMENTS]));
        for (int i = 0; i < SIZE_LOG2; i++)
        {
            _envelopes[i] = other._envelopes[i];
        }
        _notEmpty = other._notEmpty;
        return *this;
    }

    //
    // Assign (copy) envelope
    //

    //
    // Look at the explanation at the begining of this file
    //
    // Add raw data from src to circular buffer _buffer and
    // Make envelopes. Check for every sample and every envelope
    // do we have new maximum or minimum.
    //
    // Parameters:
    // src - data from one channel (deinterleaved)
    // len - length of data in samples0
    //
    void addData(const int16_t *src, int64_t len);

    //
    // Just copy raw data for one channel from interleaved "src" buffer to
    // non-interleaved circular buffer "_buffer"
    // for "stride" channel
    // (just raw data, ignore envelopes)
    // Move the reading head (tail) also by "len" samples
    //
    // Parameters:
    // src - source buffer
    // len - number of frames (or number of samples for single channel)
    // stride - number of channels in one frame
    //
    void simpleAddData(const int16_t *src, int64_t len, int16_t stride);

    //
    // Parameters:
    //
    //      dst - destination buffer
    //      offset - offset in number of samples since begining of the time
    //      len - number of samples to get
    //
    //   Gets raw data from circular bufer using index "offset" that is given
    //   in number of the samples since begining of the time. Since "_pos" represents
    //   cumulative number of the samples since begining of the time (this buffer has received)
    //   offset must be smaller value (we can't fetch into future)
    void getData(int16_t *dst, int64_t offset, int64_t len) const;

    void getDataEnvelope(std::pair<int16_t, int16_t> *dst, int64_t offset, int64_t len, int skip) const;

    std::vector<int16_t> getData(int64_t offset, int64_t len) const;

    //
    // Parameters:
    //    offset - offset in samples from begining of the time
    //    len - number of samples to get
    //    skip - get every "skip" sample (skip "skip"-1 sample after each sample)
    //
    //
    //     returns len/skip data samples
    //
    std::vector<std::pair<int16_t, int16_t>> getDataEnvelope(int64_t offset, int64_t len, int skip) const;
    int16_t at(int64_t pos) const
    {
        if (pos <= _pos - SIZE || pos >= _pos)
            return 0;
        return _buffer[(_head + pos - _pos + SIZE) % SIZE];
    }
    int64_t pos() const { return _pos; }

    void setPos(int64_t pos)
    {
        // std::cout<< "SampleBuffer: SETPOS CALLED "<<pos<<"\n";
        _pos = pos;
    }

    int head() const { return _head; }

    void setHead(int head)
    {
        _head = head % SIZE;
    }

    void reset()
    {
        //  std::cout<<"!!!!!!!!!!!!!!!!!! RESET buffer!!!!!!!!!!!\n";
        _pos = 0;
        _head = 0;
        memset(segmentsState, 0, sizeof(int[NUMBER_OF_SEGMENTS]));
        if (_notEmpty)
        {
            _notEmpty = false;
            memset(_buffer, 0, SIZE * sizeof(int16_t));

            for (int i = 0, size = SIZE / 2; i < SIZE_LOG2; i++, size /= 2)
                _envelopes[i].assign(size + 1, std::pair<int16_t, int16_t>(0, 0));
        }
    }
    bool empty() const { return !_notEmpty; }
    int segmentsState[NUMBER_OF_SEGMENTS];

private:
    // LOADED number of samples since begining of the time (we have to have that since
    // other parts of the application calculate samples from begining of the time
    // and this class has circular buffer that rewinds all the time)
    int64_t _pos;

    // LOADED number of bytes position of head in "_buffer" circular buffer
    int _head;

    // Circular buffer with raw data. Size is SIZE = 44100*60*1 samples
    int16_t *const _buffer;

    // There are SIZE_LOG2 (21) envelope arrays. Every envelope is half the length of previous
    // each envelope has two arrays:
    // First array holds maximum values of signal (just subsampled)
    // Second array holds minimum values of signal (just subsampled)
    std::vector<std::pair<int16_t, int16_t>> _envelopes[SIZE_LOG2];

    bool _notEmpty;
};

#endif

----- END ./web/sample_buffer.h -----

----- BEGIN ./web/worker6788.dart -----
import 'dart:async';
import 'dart:convert';
import 'dart:html' as html;
import 'dart:js' as js;

import 'package:isolate_contactor/src/utils/exception.dart';
import 'package:js/js.dart' as pjs;
import 'package:js/js_util.dart' as js_util;

@pjs.JS('self')
external dynamic get globalScopeSelf;

/// dart compile js worker.dart -o worker.js -O4

/// In most cases you don't need to modify this function
void main() {
  callbackToStream('onmessage', (html.MessageEvent e) {
    return js_util.getProperty(e, 'data');
  }).listen((message) async {
    final Completer completer = Completer();
    completer.future.then(
      (value) => jsSendMessage(value),
      onError: (err, stack) =>
          jsSendMessage(IsolateException(err, stack).toJson()),
    );
    try {
      completer.complete(worker(message));
    } catch (err, stack) {
      jsSendMessage(IsolateException(err, stack).toJson());
    }
  });
}

/// TODO: Modify your function here:
///
///  Do this if you need to throw an exception
///
///  You should only throw the `message` instead of a whole Object because it may
///  not show as expected when sending back to the main app.
///
/// ``` dart
///  return throw 'This is an error that you need to catch in your main app';
/// ```
FutureOr<dynamic> worker(dynamic message) {
  // Best way to use this method is encoding the result to JSON
  // before sending to the main app, then you can decode it back to
  // the return type you want with `workerConverter`.
  return jsonEncode(message);
}

/// Internal function
Stream<T> callbackToStream<J, T>(
    String name, T Function(J jsValue) unwrapValue) {
  var controller = StreamController<T>.broadcast(sync: true);
  js_util.setProperty(js.context['self'], name, js.allowInterop((J event) {
    controller.add(unwrapValue(event));
  }));
  return controller.stream;
}

/// Internal function
void jsSendMessage(dynamic m) {
  js.context.callMethod('postMessage', [m]);
}

----- END ./web/worker6788.dart -----

----- BEGIN ./windows/cmake_install.cmake -----
# Install script for directory: C:/Users/pulki/OneDrive/spikerbox_flutter/windows

# Set the install prefix
if(NOT DEFINED CMAKE_INSTALL_PREFIX)
  set(CMAKE_INSTALL_PREFIX "$<TARGET_FILE_DIR:spikerbox_architecture>")
endif()
string(REGEX REPLACE "/$" "" CMAKE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}")

# Set the install configuration name.
if(NOT DEFINED CMAKE_INSTALL_CONFIG_NAME)
  if(BUILD_TYPE)
    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
           CMAKE_INSTALL_CONFIG_NAME "${BUILD_TYPE}")
  else()
    set(CMAKE_INSTALL_CONFIG_NAME "Release")
  endif()
  message(STATUS "Install configuration: \"${CMAKE_INSTALL_CONFIG_NAME}\"")
endif()

# Set the component getting installed.
if(NOT CMAKE_INSTALL_COMPONENT)
  if(COMPONENT)
    message(STATUS "Install component: \"${COMPONENT}\"")
    set(CMAKE_INSTALL_COMPONENT "${COMPONENT}")
  else()
    set(CMAKE_INSTALL_COMPONENT)
  endif()
endif()

# Is this installation the result of a crosscompile?
if(NOT DEFINED CMAKE_CROSSCOMPILING)
  set(CMAKE_CROSSCOMPILING "FALSE")
endif()

if(NOT CMAKE_INSTALL_LOCAL_ONLY)
  # Include the install script for the subdirectory.
  include("C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/flutter/cmake_install.cmake")
endif()

if(NOT CMAKE_INSTALL_LOCAL_ONLY)
  # Include the install script for the subdirectory.
  include("C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/cmake_install.cmake")
endif()

if(NOT CMAKE_INSTALL_LOCAL_ONLY)
  # Include the install script for the subdirectory.
  include("C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/plugins/flutter_libserialport/cmake_install.cmake")
endif()

if(NOT CMAKE_INSTALL_LOCAL_ONLY)
  # Include the install script for the subdirectory.
  include("C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/plugins/permission_handler_windows/cmake_install.cmake")
endif()

if(CMAKE_INSTALL_COMPONENT STREQUAL "Runtime" OR NOT CMAKE_INSTALL_COMPONENT)
  if(CMAKE_INSTALL_CONFIG_NAME MATCHES "^([Dd][Ee][Bb][Uu][Gg])$")
    list(APPEND CMAKE_ABSOLUTE_DESTINATION_FILES
     "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Debug/spikerbox_architecture.exe")
    if(CMAKE_WARN_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(WARNING "ABSOLUTE path INSTALL DESTINATION : ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    if(CMAKE_ERROR_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(FATAL_ERROR "ABSOLUTE path INSTALL DESTINATION forbidden (by caller): ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    file(INSTALL DESTINATION "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Debug" TYPE EXECUTABLE FILES "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Debug/spikerbox_architecture.exe")
  elseif(CMAKE_INSTALL_CONFIG_NAME MATCHES "^([Pp][Rr][Oo][Ff][Ii][Ll][Ee])$")
    list(APPEND CMAKE_ABSOLUTE_DESTINATION_FILES
     "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Profile/spikerbox_architecture.exe")
    if(CMAKE_WARN_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(WARNING "ABSOLUTE path INSTALL DESTINATION : ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    if(CMAKE_ERROR_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(FATAL_ERROR "ABSOLUTE path INSTALL DESTINATION forbidden (by caller): ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    file(INSTALL DESTINATION "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Profile" TYPE EXECUTABLE FILES "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Profile/spikerbox_architecture.exe")
  elseif(CMAKE_INSTALL_CONFIG_NAME MATCHES "^([Rr][Ee][Ll][Ee][Aa][Ss][Ee])$")
    list(APPEND CMAKE_ABSOLUTE_DESTINATION_FILES
     "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Release/spikerbox_architecture.exe")
    if(CMAKE_WARN_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(WARNING "ABSOLUTE path INSTALL DESTINATION : ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    if(CMAKE_ERROR_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(FATAL_ERROR "ABSOLUTE path INSTALL DESTINATION forbidden (by caller): ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    file(INSTALL DESTINATION "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Release" TYPE EXECUTABLE FILES "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Release/spikerbox_architecture.exe")
  endif()
endif()

if(CMAKE_INSTALL_COMPONENT STREQUAL "Runtime" OR NOT CMAKE_INSTALL_COMPONENT)
  if(CMAKE_INSTALL_CONFIG_NAME MATCHES "^([Dd][Ee][Bb][Uu][Gg])$")
    list(APPEND CMAKE_ABSOLUTE_DESTINATION_FILES
     "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Debug/data/icudtl.dat")
    if(CMAKE_WARN_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(WARNING "ABSOLUTE path INSTALL DESTINATION : ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    if(CMAKE_ERROR_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(FATAL_ERROR "ABSOLUTE path INSTALL DESTINATION forbidden (by caller): ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    file(INSTALL DESTINATION "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Debug/data" TYPE FILE FILES "C:/Users/pulki/OneDrive/spikerbox_flutter/windows/flutter/ephemeral/icudtl.dat")
  elseif(CMAKE_INSTALL_CONFIG_NAME MATCHES "^([Pp][Rr][Oo][Ff][Ii][Ll][Ee])$")
    list(APPEND CMAKE_ABSOLUTE_DESTINATION_FILES
     "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Profile/data/icudtl.dat")
    if(CMAKE_WARN_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(WARNING "ABSOLUTE path INSTALL DESTINATION : ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    if(CMAKE_ERROR_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(FATAL_ERROR "ABSOLUTE path INSTALL DESTINATION forbidden (by caller): ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    file(INSTALL DESTINATION "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Profile/data" TYPE FILE FILES "C:/Users/pulki/OneDrive/spikerbox_flutter/windows/flutter/ephemeral/icudtl.dat")
  elseif(CMAKE_INSTALL_CONFIG_NAME MATCHES "^([Rr][Ee][Ll][Ee][Aa][Ss][Ee])$")
    list(APPEND CMAKE_ABSOLUTE_DESTINATION_FILES
     "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Release/data/icudtl.dat")
    if(CMAKE_WARN_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(WARNING "ABSOLUTE path INSTALL DESTINATION : ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    if(CMAKE_ERROR_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(FATAL_ERROR "ABSOLUTE path INSTALL DESTINATION forbidden (by caller): ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    file(INSTALL DESTINATION "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Release/data" TYPE FILE FILES "C:/Users/pulki/OneDrive/spikerbox_flutter/windows/flutter/ephemeral/icudtl.dat")
  endif()
endif()

if(CMAKE_INSTALL_COMPONENT STREQUAL "Runtime" OR NOT CMAKE_INSTALL_COMPONENT)
  if(CMAKE_INSTALL_CONFIG_NAME MATCHES "^([Dd][Ee][Bb][Uu][Gg])$")
    list(APPEND CMAKE_ABSOLUTE_DESTINATION_FILES
     "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Debug/flutter_windows.dll")
    if(CMAKE_WARN_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(WARNING "ABSOLUTE path INSTALL DESTINATION : ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    if(CMAKE_ERROR_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(FATAL_ERROR "ABSOLUTE path INSTALL DESTINATION forbidden (by caller): ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    file(INSTALL DESTINATION "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Debug" TYPE FILE FILES "C:/Users/pulki/OneDrive/spikerbox_flutter/windows/flutter/ephemeral/flutter_windows.dll")
  elseif(CMAKE_INSTALL_CONFIG_NAME MATCHES "^([Pp][Rr][Oo][Ff][Ii][Ll][Ee])$")
    list(APPEND CMAKE_ABSOLUTE_DESTINATION_FILES
     "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Profile/flutter_windows.dll")
    if(CMAKE_WARN_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(WARNING "ABSOLUTE path INSTALL DESTINATION : ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    if(CMAKE_ERROR_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(FATAL_ERROR "ABSOLUTE path INSTALL DESTINATION forbidden (by caller): ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    file(INSTALL DESTINATION "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Profile" TYPE FILE FILES "C:/Users/pulki/OneDrive/spikerbox_flutter/windows/flutter/ephemeral/flutter_windows.dll")
  elseif(CMAKE_INSTALL_CONFIG_NAME MATCHES "^([Rr][Ee][Ll][Ee][Aa][Ss][Ee])$")
    list(APPEND CMAKE_ABSOLUTE_DESTINATION_FILES
     "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Release/flutter_windows.dll")
    if(CMAKE_WARN_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(WARNING "ABSOLUTE path INSTALL DESTINATION : ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    if(CMAKE_ERROR_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(FATAL_ERROR "ABSOLUTE path INSTALL DESTINATION forbidden (by caller): ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    file(INSTALL DESTINATION "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Release" TYPE FILE FILES "C:/Users/pulki/OneDrive/spikerbox_flutter/windows/flutter/ephemeral/flutter_windows.dll")
  endif()
endif()

if(CMAKE_INSTALL_COMPONENT STREQUAL "Runtime" OR NOT CMAKE_INSTALL_COMPONENT)
  if(CMAKE_INSTALL_CONFIG_NAME MATCHES "^([Dd][Ee][Bb][Uu][Gg])$")
    list(APPEND CMAKE_ABSOLUTE_DESTINATION_FILES
     "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Debug/flutter_libserialport_plugin.dll;C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Debug/serialport.dll;C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Debug/permission_handler_windows_plugin.dll")
    if(CMAKE_WARN_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(WARNING "ABSOLUTE path INSTALL DESTINATION : ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    if(CMAKE_ERROR_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(FATAL_ERROR "ABSOLUTE path INSTALL DESTINATION forbidden (by caller): ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    file(INSTALL DESTINATION "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Debug" TYPE FILE FILES
      "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/plugins/flutter_libserialport/Debug/flutter_libserialport_plugin.dll"
      "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/plugins/flutter_libserialport/libserialport/Debug/serialport.dll"
      "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/plugins/permission_handler_windows/Debug/permission_handler_windows_plugin.dll"
      )
  elseif(CMAKE_INSTALL_CONFIG_NAME MATCHES "^([Pp][Rr][Oo][Ff][Ii][Ll][Ee])$")
    list(APPEND CMAKE_ABSOLUTE_DESTINATION_FILES
     "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Profile/flutter_libserialport_plugin.dll;C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Profile/serialport.dll;C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Profile/permission_handler_windows_plugin.dll")
    if(CMAKE_WARN_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(WARNING "ABSOLUTE path INSTALL DESTINATION : ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    if(CMAKE_ERROR_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(FATAL_ERROR "ABSOLUTE path INSTALL DESTINATION forbidden (by caller): ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    file(INSTALL DESTINATION "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Profile" TYPE FILE FILES
      "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/plugins/flutter_libserialport/Profile/flutter_libserialport_plugin.dll"
      "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/plugins/flutter_libserialport/libserialport/Profile/serialport.dll"
      "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/plugins/permission_handler_windows/Profile/permission_handler_windows_plugin.dll"
      )
  elseif(CMAKE_INSTALL_CONFIG_NAME MATCHES "^([Rr][Ee][Ll][Ee][Aa][Ss][Ee])$")
    list(APPEND CMAKE_ABSOLUTE_DESTINATION_FILES
     "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Release/flutter_libserialport_plugin.dll;C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Release/serialport.dll;C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Release/permission_handler_windows_plugin.dll")
    if(CMAKE_WARN_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(WARNING "ABSOLUTE path INSTALL DESTINATION : ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    if(CMAKE_ERROR_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(FATAL_ERROR "ABSOLUTE path INSTALL DESTINATION forbidden (by caller): ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    file(INSTALL DESTINATION "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Release" TYPE FILE FILES
      "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/plugins/flutter_libserialport/Release/flutter_libserialport_plugin.dll"
      "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/plugins/flutter_libserialport/libserialport/Release/serialport.dll"
      "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/plugins/permission_handler_windows/Release/permission_handler_windows_plugin.dll"
      )
  endif()
endif()

if(CMAKE_INSTALL_COMPONENT STREQUAL "Runtime" OR NOT CMAKE_INSTALL_COMPONENT)
  if(CMAKE_INSTALL_CONFIG_NAME MATCHES "^([Dd][Ee][Bb][Uu][Gg])$")
    
  file(REMOVE_RECURSE "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Debug/data/flutter_assets")
  
  elseif(CMAKE_INSTALL_CONFIG_NAME MATCHES "^([Pp][Rr][Oo][Ff][Ii][Ll][Ee])$")
    
  file(REMOVE_RECURSE "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Profile/data/flutter_assets")
  
  elseif(CMAKE_INSTALL_CONFIG_NAME MATCHES "^([Rr][Ee][Ll][Ee][Aa][Ss][Ee])$")
    
  file(REMOVE_RECURSE "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Release/data/flutter_assets")
  
  endif()
endif()

if(CMAKE_INSTALL_COMPONENT STREQUAL "Runtime" OR NOT CMAKE_INSTALL_COMPONENT)
  if(CMAKE_INSTALL_CONFIG_NAME MATCHES "^([Dd][Ee][Bb][Uu][Gg])$")
    list(APPEND CMAKE_ABSOLUTE_DESTINATION_FILES
     "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Debug/data/flutter_assets")
    if(CMAKE_WARN_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(WARNING "ABSOLUTE path INSTALL DESTINATION : ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    if(CMAKE_ERROR_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(FATAL_ERROR "ABSOLUTE path INSTALL DESTINATION forbidden (by caller): ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    file(INSTALL DESTINATION "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Debug/data" TYPE DIRECTORY FILES "C:/Users/pulki/OneDrive/spikerbox_flutter/build//flutter_assets")
  elseif(CMAKE_INSTALL_CONFIG_NAME MATCHES "^([Pp][Rr][Oo][Ff][Ii][Ll][Ee])$")
    list(APPEND CMAKE_ABSOLUTE_DESTINATION_FILES
     "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Profile/data/flutter_assets")
    if(CMAKE_WARN_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(WARNING "ABSOLUTE path INSTALL DESTINATION : ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    if(CMAKE_ERROR_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(FATAL_ERROR "ABSOLUTE path INSTALL DESTINATION forbidden (by caller): ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    file(INSTALL DESTINATION "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Profile/data" TYPE DIRECTORY FILES "C:/Users/pulki/OneDrive/spikerbox_flutter/build//flutter_assets")
  elseif(CMAKE_INSTALL_CONFIG_NAME MATCHES "^([Rr][Ee][Ll][Ee][Aa][Ss][Ee])$")
    list(APPEND CMAKE_ABSOLUTE_DESTINATION_FILES
     "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Release/data/flutter_assets")
    if(CMAKE_WARN_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(WARNING "ABSOLUTE path INSTALL DESTINATION : ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    if(CMAKE_ERROR_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(FATAL_ERROR "ABSOLUTE path INSTALL DESTINATION forbidden (by caller): ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    file(INSTALL DESTINATION "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Release/data" TYPE DIRECTORY FILES "C:/Users/pulki/OneDrive/spikerbox_flutter/build//flutter_assets")
  endif()
endif()

if(CMAKE_INSTALL_COMPONENT STREQUAL "Runtime" OR NOT CMAKE_INSTALL_COMPONENT)
  if(CMAKE_INSTALL_CONFIG_NAME MATCHES "^([Pp][Rr][Oo][Ff][Ii][Ll][Ee])$")
    list(APPEND CMAKE_ABSOLUTE_DESTINATION_FILES
     "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Profile/data/app.so")
    if(CMAKE_WARN_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(WARNING "ABSOLUTE path INSTALL DESTINATION : ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    if(CMAKE_ERROR_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(FATAL_ERROR "ABSOLUTE path INSTALL DESTINATION forbidden (by caller): ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    file(INSTALL DESTINATION "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Profile/data" TYPE FILE FILES "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/app.so")
  elseif(CMAKE_INSTALL_CONFIG_NAME MATCHES "^([Rr][Ee][Ll][Ee][Aa][Ss][Ee])$")
    list(APPEND CMAKE_ABSOLUTE_DESTINATION_FILES
     "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Release/data/app.so")
    if(CMAKE_WARN_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(WARNING "ABSOLUTE path INSTALL DESTINATION : ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    if(CMAKE_ERROR_ON_ABSOLUTE_INSTALL_DESTINATION)
      message(FATAL_ERROR "ABSOLUTE path INSTALL DESTINATION forbidden (by caller): ${CMAKE_ABSOLUTE_DESTINATION_FILES}")
    endif()
    file(INSTALL DESTINATION "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/runner/Release/data" TYPE FILE FILES "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/app.so")
  endif()
endif()

if(CMAKE_INSTALL_COMPONENT)
  set(CMAKE_INSTALL_MANIFEST "install_manifest_${CMAKE_INSTALL_COMPONENT}.txt")
else()
  set(CMAKE_INSTALL_MANIFEST "install_manifest.txt")
endif()

string(REPLACE ";" "\n" CMAKE_INSTALL_MANIFEST_CONTENT
       "${CMAKE_INSTALL_MANIFEST_FILES}")
file(WRITE "C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/${CMAKE_INSTALL_MANIFEST}"
     "${CMAKE_INSTALL_MANIFEST_CONTENT}")

----- END ./windows/cmake_install.cmake -----

----- BEGIN ./windows/flutter/cmake_install.cmake -----
# Install script for directory: C:/Users/pulki/OneDrive/spikerbox_flutter/windows/flutter

# Set the install prefix
if(NOT DEFINED CMAKE_INSTALL_PREFIX)
  set(CMAKE_INSTALL_PREFIX "$<TARGET_FILE_DIR:spikerbox_architecture>")
endif()
string(REGEX REPLACE "/$" "" CMAKE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}")

# Set the install configuration name.
if(NOT DEFINED CMAKE_INSTALL_CONFIG_NAME)
  if(BUILD_TYPE)
    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
           CMAKE_INSTALL_CONFIG_NAME "${BUILD_TYPE}")
  else()
    set(CMAKE_INSTALL_CONFIG_NAME "Release")
  endif()
  message(STATUS "Install configuration: \"${CMAKE_INSTALL_CONFIG_NAME}\"")
endif()

# Set the component getting installed.
if(NOT CMAKE_INSTALL_COMPONENT)
  if(COMPONENT)
    message(STATUS "Install component: \"${COMPONENT}\"")
    set(CMAKE_INSTALL_COMPONENT "${COMPONENT}")
  else()
    set(CMAKE_INSTALL_COMPONENT)
  endif()
endif()

# Is this installation the result of a crosscompile?
if(NOT DEFINED CMAKE_CROSSCOMPILING)
  set(CMAKE_CROSSCOMPILING "FALSE")
endif()


----- END ./windows/flutter/cmake_install.cmake -----

----- BEGIN ./windows/plugins/flutter_libserialport/cmake_install.cmake -----
# Install script for directory: C:/Users/pulki/OneDrive/spikerbox_flutter/windows/flutter/ephemeral/.plugin_symlinks/flutter_libserialport/windows

# Set the install prefix
if(NOT DEFINED CMAKE_INSTALL_PREFIX)
  set(CMAKE_INSTALL_PREFIX "$<TARGET_FILE_DIR:spikerbox_architecture>")
endif()
string(REGEX REPLACE "/$" "" CMAKE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}")

# Set the install configuration name.
if(NOT DEFINED CMAKE_INSTALL_CONFIG_NAME)
  if(BUILD_TYPE)
    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
           CMAKE_INSTALL_CONFIG_NAME "${BUILD_TYPE}")
  else()
    set(CMAKE_INSTALL_CONFIG_NAME "Release")
  endif()
  message(STATUS "Install configuration: \"${CMAKE_INSTALL_CONFIG_NAME}\"")
endif()

# Set the component getting installed.
if(NOT CMAKE_INSTALL_COMPONENT)
  if(COMPONENT)
    message(STATUS "Install component: \"${COMPONENT}\"")
    set(CMAKE_INSTALL_COMPONENT "${COMPONENT}")
  else()
    set(CMAKE_INSTALL_COMPONENT)
  endif()
endif()

# Is this installation the result of a crosscompile?
if(NOT DEFINED CMAKE_CROSSCOMPILING)
  set(CMAKE_CROSSCOMPILING "FALSE")
endif()

if(NOT CMAKE_INSTALL_LOCAL_ONLY)
  # Include the install script for the subdirectory.
  include("C:/Users/pulki/OneDrive/spikerbox_flutter/build/windows/plugins/flutter_libserialport/libserialport/cmake_install.cmake")
endif()


----- END ./windows/plugins/flutter_libserialport/cmake_install.cmake -----

----- BEGIN ./windows/plugins/flutter_libserialport/libserialport/cmake_install.cmake -----
# Install script for directory: C:/Users/pulki/OneDrive/spikerbox_flutter/windows/flutter/ephemeral/.plugin_symlinks/flutter_libserialport/windows/libserialport

# Set the install prefix
if(NOT DEFINED CMAKE_INSTALL_PREFIX)
  set(CMAKE_INSTALL_PREFIX "$<TARGET_FILE_DIR:spikerbox_architecture>")
endif()
string(REGEX REPLACE "/$" "" CMAKE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}")

# Set the install configuration name.
if(NOT DEFINED CMAKE_INSTALL_CONFIG_NAME)
  if(BUILD_TYPE)
    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
           CMAKE_INSTALL_CONFIG_NAME "${BUILD_TYPE}")
  else()
    set(CMAKE_INSTALL_CONFIG_NAME "Release")
  endif()
  message(STATUS "Install configuration: \"${CMAKE_INSTALL_CONFIG_NAME}\"")
endif()

# Set the component getting installed.
if(NOT CMAKE_INSTALL_COMPONENT)
  if(COMPONENT)
    message(STATUS "Install component: \"${COMPONENT}\"")
    set(CMAKE_INSTALL_COMPONENT "${COMPONENT}")
  else()
    set(CMAKE_INSTALL_COMPONENT)
  endif()
endif()

# Is this installation the result of a crosscompile?
if(NOT DEFINED CMAKE_CROSSCOMPILING)
  set(CMAKE_CROSSCOMPILING "FALSE")
endif()


----- END ./windows/plugins/flutter_libserialport/libserialport/cmake_install.cmake -----

----- BEGIN ./windows/plugins/permission_handler_windows/cmake_install.cmake -----
# Install script for directory: C:/Users/pulki/OneDrive/spikerbox_flutter/windows/flutter/ephemeral/.plugin_symlinks/permission_handler_windows/windows

# Set the install prefix
if(NOT DEFINED CMAKE_INSTALL_PREFIX)
  set(CMAKE_INSTALL_PREFIX "$<TARGET_FILE_DIR:spikerbox_architecture>")
endif()
string(REGEX REPLACE "/$" "" CMAKE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}")

# Set the install configuration name.
if(NOT DEFINED CMAKE_INSTALL_CONFIG_NAME)
  if(BUILD_TYPE)
    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
           CMAKE_INSTALL_CONFIG_NAME "${BUILD_TYPE}")
  else()
    set(CMAKE_INSTALL_CONFIG_NAME "Release")
  endif()
  message(STATUS "Install configuration: \"${CMAKE_INSTALL_CONFIG_NAME}\"")
endif()

# Set the component getting installed.
if(NOT CMAKE_INSTALL_COMPONENT)
  if(COMPONENT)
    message(STATUS "Install component: \"${COMPONENT}\"")
    set(CMAKE_INSTALL_COMPONENT "${COMPONENT}")
  else()
    set(CMAKE_INSTALL_COMPONENT)
  endif()
endif()

# Is this installation the result of a crosscompile?
if(NOT DEFINED CMAKE_CROSSCOMPILING)
  set(CMAKE_CROSSCOMPILING "FALSE")
endif()


----- END ./windows/plugins/permission_handler_windows/cmake_install.cmake -----

----- BEGIN ./windows/runner/cmake_install.cmake -----
# Install script for directory: C:/Users/pulki/OneDrive/spikerbox_flutter/windows/runner

# Set the install prefix
if(NOT DEFINED CMAKE_INSTALL_PREFIX)
  set(CMAKE_INSTALL_PREFIX "$<TARGET_FILE_DIR:spikerbox_architecture>")
endif()
string(REGEX REPLACE "/$" "" CMAKE_INSTALL_PREFIX "${CMAKE_INSTALL_PREFIX}")

# Set the install configuration name.
if(NOT DEFINED CMAKE_INSTALL_CONFIG_NAME)
  if(BUILD_TYPE)
    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
           CMAKE_INSTALL_CONFIG_NAME "${BUILD_TYPE}")
  else()
    set(CMAKE_INSTALL_CONFIG_NAME "Release")
  endif()
  message(STATUS "Install configuration: \"${CMAKE_INSTALL_CONFIG_NAME}\"")
endif()

# Set the component getting installed.
if(NOT CMAKE_INSTALL_COMPONENT)
  if(COMPONENT)
    message(STATUS "Install component: \"${COMPONENT}\"")
    set(CMAKE_INSTALL_COMPONENT "${COMPONENT}")
  else()
    set(CMAKE_INSTALL_COMPONENT)
  endif()
endif()

# Is this installation the result of a crosscompile?
if(NOT DEFINED CMAKE_CROSSCOMPILING)
  set(CMAKE_CROSSCOMPILING "FALSE")
endif()


----- END ./windows/runner/cmake_install.cmake -----

----- BEGIN ./windows/runner/flutter_window.cpp -----
#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());

  flutter_controller_->engine()->SetNextFrameCallback([&]() {
    this->Show();
  });

  // Flutter can complete the first frame before the "show window" callback is
  // registered. The following call ensures a frame is pending to ensure the
  // window is shown. It is a no-op if the first frame hasn't completed yet.
  flutter_controller_->ForceRedraw();

  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}

----- END ./windows/runner/flutter_window.cpp -----

----- BEGIN ./windows/runner/flutter_window.h -----
#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_

----- END ./windows/runner/flutter_window.h -----

----- BEGIN ./windows/runner/main.cpp -----
#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t *command_line, _In_ int show_command) {
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments =
      GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.Create(L"spikerbox_flutter", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}

----- END ./windows/runner/main.cpp -----

----- BEGIN ./windows/runner/resource.h -----
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON                    101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

----- END ./windows/runner/resource.h -----

----- BEGIN ./windows/runner/utils.cpp -----
#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE *unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  int target_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      -1, nullptr, 0, nullptr, nullptr)
    -1; // remove the trailing null character
  int input_length = (int)wcslen(utf16_string);
  std::string utf8_string;
  if (target_length <= 0 || target_length > utf8_string.max_size()) {
    return utf8_string;
  }
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      input_length, utf8_string.data(), target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}

----- END ./windows/runner/utils.cpp -----

----- BEGIN ./windows/runner/utils.h -----
#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_

----- END ./windows/runner/utils.h -----

----- BEGIN ./windows/runner/win32_window.cpp -----
#include "win32_window.h"

#include <dwmapi.h>
#include <flutter_windows.h>

#include "resource.h"

namespace {

/// Window attribute that enables dark mode window decorations.
///
/// Redefined in case the developer's machine has a Windows SDK older than
/// version 10.0.22000.0.
/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
#define DWMWA_USE_IMMERSIVE_DARK_MODE 20
#endif

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

/// Registry key for app theme preference.
///
/// A value of 0 indicates apps should use dark mode. A non-zero or missing
/// value indicates apps should use light mode.
constexpr const wchar_t kGetPreferredBrightnessRegKey[] =
  L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
constexpr const wchar_t kGetPreferredBrightnessRegValue[] = L"AppsUseLightTheme";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
  }
  FreeLibrary(user32_module);
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registrar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() {
  ++g_active_window_count;
}

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::Create(const std::wstring& title,
                         const Point& origin,
                         const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  UpdateTheme(window);

  return OnCreate();
}

bool Win32Window::Show() {
  return ShowWindow(window_handle_, SW_SHOWNORMAL);
}

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window,
                                      UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd,
                            UINT const message,
                            WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;

    case WM_DWMCOLORIZATIONCOLORCHANGED:
      UpdateTheme(hwnd);
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() {
  return window_handle_;
}

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

void Win32Window::UpdateTheme(HWND const window) {
  DWORD light_mode;
  DWORD light_mode_size = sizeof(light_mode);
  LSTATUS result = RegGetValue(HKEY_CURRENT_USER, kGetPreferredBrightnessRegKey,
                               kGetPreferredBrightnessRegValue,
                               RRF_RT_REG_DWORD, nullptr, &light_mode,
                               &light_mode_size);

  if (result == ERROR_SUCCESS) {
    BOOL enable_dark_mode = light_mode == 0;
    DwmSetWindowAttribute(window, DWMWA_USE_IMMERSIVE_DARK_MODE,
                          &enable_dark_mode, sizeof(enable_dark_mode));
  }
}

----- END ./windows/runner/win32_window.cpp -----

----- BEGIN ./windows/runner/win32_window.h -----
#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates a win32 window with |title| that is positioned and sized using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size this function will scale the inputted width and height as
  // as appropriate for the default monitor. The window is invisible until
  // |Show| is called. Returns true if the window was created successfully.
  bool Create(const std::wstring& title, const Point& origin, const Size& size);

  // Show the current window. Returns true if the window was successfully shown.
  bool Show();

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window,
                                 UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window,
                                  UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  // Update the window frame's theme to match the system theme.
  static void UpdateTheme(HWND const window);

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_

----- END ./windows/runner/win32_window.h -----

